// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: test.capnp

#ifndef CAPNP_INCLUDED_d508eebdc2dc42b8_
#define CAPNP_INCLUDED_d508eebdc2dc42b8_

#include <capnp/generated-header-support.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9c8e9318b29d9cd3);
enum class TestEnum_9c8e9318b29d9cd3: uint16_t {
  FOO,
  BAR,
  BAZ,
  QUX,
  QUUX,
  CORGE,
  GRAULT,
  GARPLY,
};
CAPNP_DECLARE_ENUM(TestEnum, 9c8e9318b29d9cd3);
CAPNP_DECLARE_SCHEMA(a0a8f314b80b63fd);
CAPNP_DECLARE_SCHEMA(eb3f9ebe98c73cb6);
CAPNP_DECLARE_SCHEMA(e3da5a2ccd28c0d8);
CAPNP_DECLARE_SCHEMA(f49850f63c2bfa59);
CAPNP_DECLARE_SCHEMA(a9d5f8efe770022b);
CAPNP_DECLARE_SCHEMA(f47697362233ce52);
CAPNP_DECLARE_SCHEMA(fc76a82eecb7a718);
CAPNP_DECLARE_SCHEMA(ee0a6b99b7dc7ab2);
CAPNP_DECLARE_SCHEMA(afc5fd419f0d66d4);
CAPNP_DECLARE_SCHEMA(a2fb022ec7f30053);
CAPNP_DECLARE_SCHEMA(9e2e784c915329b6);
CAPNP_DECLARE_SCHEMA(89a9494f1b900f22);
CAPNP_DECLARE_SCHEMA(d005f6c63707670c);
CAPNP_DECLARE_SCHEMA(ff9ce111c6f8e5db);
CAPNP_DECLARE_SCHEMA(dc841556134c3103);
CAPNP_DECLARE_SCHEMA(e22ae74ff9113268);
CAPNP_DECLARE_SCHEMA(f5fcba89c0c1196f);
CAPNP_DECLARE_SCHEMA(f0fa30304066a4b3);
CAPNP_DECLARE_SCHEMA(b727c0d0091a001d);
CAPNP_DECLARE_SCHEMA(f77ed6f7454eec40);
CAPNP_DECLARE_SCHEMA(c7485a3516c7d3c8);
CAPNP_DECLARE_SCHEMA(db0afd413f4a313a);
CAPNP_DECLARE_SCHEMA(cc85a335569990e9);
CAPNP_DECLARE_SCHEMA(a017f0366827ee37);
CAPNP_DECLARE_SCHEMA(94f7e0b103b4b718);
CAPNP_DECLARE_SCHEMA(d9f2b5941a343bcd);
CAPNP_DECLARE_SCHEMA(b651d2fba42056d4);
enum class NestedEnum_b651d2fba42056d4: uint16_t {
  FOO,
  BAR,
};
CAPNP_DECLARE_ENUM(NestedEnum, b651d2fba42056d4);
CAPNP_DECLARE_SCHEMA(82cd03a53b29d76b);
CAPNP_DECLARE_SCHEMA(cfa0d546993a3df3);
enum class NestedEnum_cfa0d546993a3df3: uint16_t {
  BAZ,
  QUX,
  QUUX,
};
CAPNP_DECLARE_ENUM(NestedEnum, cfa0d546993a3df3);
CAPNP_DECLARE_SCHEMA(e78aac389e77b065);
CAPNP_DECLARE_SCHEMA(e41885c94393277e);
CAPNP_DECLARE_SCHEMA(8412c03b75b2cfee);
CAPNP_DECLARE_SCHEMA(e0fe5870b141ad69);
CAPNP_DECLARE_SCHEMA(a6411a353090145b);
CAPNP_DECLARE_SCHEMA(a8abf7a82928986c);
CAPNP_DECLARE_SCHEMA(ad7beedc4ed30742);
CAPNP_DECLARE_SCHEMA(ef9a34f2ff7cc646);
CAPNP_DECLARE_SCHEMA(c6abf1b0329e6227);
CAPNP_DECLARE_SCHEMA(943a234ca336b16a);
CAPNP_DECLARE_SCHEMA(8991bc0e74a594cd);
CAPNP_DECLARE_SCHEMA(ed267416528c7a24);
CAPNP_DECLARE_SCHEMA(9978837b037d58e6);
CAPNP_DECLARE_SCHEMA(ed5fa940f54a7904);
CAPNP_DECLARE_SCHEMA(bc743778f2597c7d);
CAPNP_DECLARE_SCHEMA(c2e364a40182013d);
CAPNP_DECLARE_SCHEMA(92fc29a80f3ddd5c);
CAPNP_DECLARE_SCHEMA(a851ad32cbc2ffea);
CAPNP_DECLARE_SCHEMA(a76e3c9bb7fd56d3);
CAPNP_DECLARE_SCHEMA(807280a2901aa079);
CAPNP_DECLARE_SCHEMA(c1973984dee98e3a);
CAPNP_DECLARE_SCHEMA(95b30dd14e01dda8);
CAPNP_DECLARE_SCHEMA(8ed75a7469f04ce3);
CAPNP_DECLARE_SCHEMA(bd5fe16e5170c492);
CAPNP_DECLARE_SCHEMA(c7e4c513a975492b);
CAPNP_DECLARE_SCHEMA(86232c1de4513e84);
CAPNP_DECLARE_SCHEMA(faf781ef89a00e39);
CAPNP_DECLARE_SCHEMA(9daec9823f171085);
CAPNP_DECLARE_SCHEMA(992edc677bef5a3c);
CAPNP_DECLARE_SCHEMA(dec497819d097c3c);
CAPNP_DECLARE_SCHEMA(8e4936003708dac2);
CAPNP_DECLARE_SCHEMA(91afd4a864dbb030);
CAPNP_DECLARE_SCHEMA(b24fe52e5b90f3eb);
CAPNP_DECLARE_SCHEMA(f6912d555f7b2f5e);
CAPNP_DECLARE_SCHEMA(9d5b8cd8de9922eb);
CAPNP_DECLARE_SCHEMA(f6a841117e19ac73);
CAPNP_DECLARE_SCHEMA(a9ab42b118d6d435);
CAPNP_DECLARE_SCHEMA(b6a0829c762b06f3);
CAPNP_DECLARE_SCHEMA(8839ed86c9794287);
CAPNP_DECLARE_SCHEMA(b84eecc799437049);
CAPNP_DECLARE_SCHEMA(e080f0fc54614f6f);
CAPNP_DECLARE_SCHEMA(c9e749e8dd54da5c);
CAPNP_DECLARE_SCHEMA(a5b46224e33581ad);
CAPNP_DECLARE_SCHEMA(8952716de9200dff);
CAPNP_DECLARE_SCHEMA(8e656edfb45ba6cf);
CAPNP_DECLARE_SCHEMA(b46a779beaf3384e);
CAPNP_DECLARE_SCHEMA(a9b2b1f52dde845d);
CAPNP_DECLARE_SCHEMA(f28f83667a557a04);
CAPNP_DECLARE_SCHEMA(8b9717a3f8d85a9a);
CAPNP_DECLARE_SCHEMA(f83f8caf54bdc486);
CAPNP_DECLARE_SCHEMA(df9ccdeb81a704c9);
CAPNP_DECLARE_SCHEMA(9aab8e25c808d71e);
CAPNP_DECLARE_SCHEMA(a54870440e919063);
CAPNP_DECLARE_SCHEMA(9427b2a71030338f);
CAPNP_DECLARE_SCHEMA(c5598844441096dc);
CAPNP_DECLARE_SCHEMA(abed745cd8c92095);
CAPNP_DECLARE_SCHEMA(d657409805207187);
CAPNP_DECLARE_SCHEMA(bbe5b10ebd841165);
CAPNP_DECLARE_SCHEMA(e4bf8760a0aded86);
CAPNP_DECLARE_SCHEMA(9747fed267e18cab);
CAPNP_DECLARE_SCHEMA(90794c40ae9ed82b);
CAPNP_DECLARE_SCHEMA(c1834c909dfff36b);
CAPNP_DECLARE_SCHEMA(8b9e0acc1bce0872);
CAPNP_DECLARE_SCHEMA(a32c242eab4fd252);
CAPNP_DECLARE_SCHEMA(b9c5472fc14639d5);
CAPNP_DECLARE_SCHEMA(aae78676ba1dbcbb);
CAPNP_DECLARE_SCHEMA(a25661f8942c24cc);
CAPNP_DECLARE_SCHEMA(db2194bab1b25c48);
CAPNP_DECLARE_SCHEMA(f346e8becc34c826);
CAPNP_DECLARE_SCHEMA(aaa4fc67c55b78fd);
CAPNP_DECLARE_SCHEMA(ed37d4414bf1157a);
CAPNP_DECLARE_SCHEMA(f6a160eb0b3687fa);
CAPNP_DECLARE_SCHEMA(e3201c2e657cf0fc);
CAPNP_DECLARE_SCHEMA(ce1810c84e108cdc);
CAPNP_DECLARE_SCHEMA(ff58bf5895b73ee2);
CAPNP_DECLARE_SCHEMA(a145449a15848a09);
CAPNP_DECLARE_SCHEMA(a567a743b6b4bf0d);
CAPNP_DECLARE_SCHEMA(d987eb8af5945021);
CAPNP_DECLARE_SCHEMA(9e55f87eb2ffa805);
CAPNP_DECLARE_SCHEMA(fe4d1147d7537f4c);
CAPNP_DECLARE_SCHEMA(900218d4541375d3);
CAPNP_DECLARE_SCHEMA(d26dd7a486f26cd7);
CAPNP_DECLARE_SCHEMA(feb875138580a065);
CAPNP_DECLARE_SCHEMA(a815a514acbab212);
CAPNP_DECLARE_SCHEMA(ec56db537c838603);
CAPNP_DECLARE_SCHEMA(c468785db6321458);
CAPNP_DECLARE_SCHEMA(d1f994d3d4fbbaed);
CAPNP_DECLARE_SCHEMA(c30860d747fd5019);
CAPNP_DECLARE_SCHEMA(ca4028a84b8fc2ed);
CAPNP_DECLARE_SCHEMA(d81b65e268fb3f34);
CAPNP_DECLARE_SCHEMA(bd579b448bfbcc7b);
CAPNP_DECLARE_SCHEMA(a00141d482942422);
CAPNP_DECLARE_SCHEMA(a4764c3483341eeb);
CAPNP_DECLARE_SCHEMA(b70341f0dafa28ef);
CAPNP_DECLARE_SCHEMA(d7c0fea759d6a0cf);
CAPNP_DECLARE_SCHEMA(8e59556fb309253f);
CAPNP_DECLARE_SCHEMA(dec09c6791841ebb);
CAPNP_DECLARE_SCHEMA(fb7ed666617fb649);
CAPNP_DECLARE_SCHEMA(ddc280dbee9c99b3);
CAPNP_DECLARE_SCHEMA(8139f596ebaf6185);
CAPNP_DECLARE_SCHEMA(88eb12a0e0af92b2);
CAPNP_DECLARE_SCHEMA(b874edc0d559b391);
CAPNP_DECLARE_SCHEMA(b04fcaddab714ba4);
CAPNP_DECLARE_SCHEMA(d044893357b42568);
CAPNP_DECLARE_SCHEMA(9bf141df4247d52f);
CAPNP_DECLARE_SCHEMA(d9ac8abb2a91cfbc);
CAPNP_DECLARE_SCHEMA(9b99d14f2f375b2d);
CAPNP_DECLARE_SCHEMA(e4e9bac98670b748);
CAPNP_DECLARE_SCHEMA(83a4bc5471363f17);
CAPNP_DECLARE_SCHEMA(8e4b3d1a3e2753dd);
CAPNP_DECLARE_SCHEMA(acf67532a7e7bad9);
CAPNP_DECLARE_SCHEMA(f3b834e851ea8af6);
CAPNP_DECLARE_SCHEMA(98d7e0ef61488783);
CAPNP_DECLARE_SCHEMA(a5a404caa61d4cd0);
CAPNP_DECLARE_SCHEMA(b0b29e51db0e26b1);
CAPNP_DECLARE_SCHEMA(9442ad5a1d2c8acb);
CAPNP_DECLARE_SCHEMA(c7e8df5096257034);
CAPNP_DECLARE_SCHEMA(b2442a9e0ba28fdf);
CAPNP_DECLARE_SCHEMA(a604ee63cf37819f);
CAPNP_DECLARE_SCHEMA(8eda54756c6070d6);
CAPNP_DECLARE_SCHEMA(f8e36b53ab093d4e);
CAPNP_DECLARE_SCHEMA(bf44b4c94c26ef79);
CAPNP_DECLARE_SCHEMA(a0e77035bdff0051);
CAPNP_DECLARE_SCHEMA(8f1e8cd56ceb74dc);
CAPNP_DECLARE_SCHEMA(dedbb6bf3810eab7);
CAPNP_DECLARE_SCHEMA(ddd699207eb8e23b);
CAPNP_DECLARE_SCHEMA(a9ed2e5a9fd53d19);
CAPNP_DECLARE_SCHEMA(c5e1efc325614957);
CAPNP_DECLARE_SCHEMA(870bf40110ce3035);
CAPNP_DECLARE_SCHEMA(b07a279515dc8ac5);
CAPNP_DECLARE_SCHEMA(a38e5efe41e53a15);
CAPNP_DECLARE_SCHEMA(ddc70bf9784133cf);
CAPNP_DECLARE_SCHEMA(931ba418da60f6e4);
CAPNP_DECLARE_SCHEMA(9a28970beccecdd0);
CAPNP_DECLARE_SCHEMA(fabc700c2ebe6378);
CAPNP_DECLARE_SCHEMA(a54ce1e9aa822f90);
CAPNP_DECLARE_SCHEMA(94fe60465c95182b);
CAPNP_DECLARE_SCHEMA(def4e5fa6999c5dc);
CAPNP_DECLARE_SCHEMA(fe7c8fbb769d8e58);
CAPNP_DECLARE_SCHEMA(f839fb1374d003c9);
CAPNP_DECLARE_SCHEMA(f8c5e5ef1edf83be);
CAPNP_DECLARE_SCHEMA(e59935f160ac7578);
CAPNP_DECLARE_SCHEMA(feffc025fce317e3);
CAPNP_DECLARE_SCHEMA(ef4e146185af67ce);
CAPNP_DECLARE_SCHEMA(c07526f7e2e533b9);
CAPNP_DECLARE_SCHEMA(a6224536593d5b92);
CAPNP_DECLARE_SCHEMA(a1cc32d87f3edeb1);
CAPNP_DECLARE_SCHEMA(8a3eba1758c0916e);
CAPNP_DECLARE_SCHEMA(99160a25fa50fbf1);
CAPNP_DECLARE_SCHEMA(9c7e066f845a6c56);
CAPNP_DECLARE_SCHEMA(ead024a301a092a1);
CAPNP_DECLARE_SCHEMA(c3490d75420a1fe8);
CAPNP_DECLARE_SCHEMA(d8493f0e175d61f2);
CAPNP_DECLARE_SCHEMA(e6955d8ef1023671);
CAPNP_DECLARE_SCHEMA(805df436f55dd07a);
CAPNP_DECLARE_SCHEMA(860e7512dc3925b0);
CAPNP_DECLARE_SCHEMA(fb92899aeb0ee74f);
CAPNP_DECLARE_SCHEMA(8467348247305cf7);
CAPNP_DECLARE_SCHEMA(c07d8dcd80a69c0c);
CAPNP_DECLARE_SCHEMA(9352e4e41f173917);
CAPNP_DECLARE_SCHEMA(ff9bdcd05085d786);
CAPNP_DECLARE_SCHEMA(ee94bed3615ee745);
CAPNP_DECLARE_SCHEMA(b0c6163faf291965);
CAPNP_DECLARE_SCHEMA(d8ac2acc3ece6556);
CAPNP_DECLARE_SCHEMA(e5d4904814ccbf29);
CAPNP_DECLARE_SCHEMA(945d9f634a6a29da);
CAPNP_DECLARE_SCHEMA(8749aac3375c5c71);
CAPNP_DECLARE_SCHEMA(869a1b7ab34b42c9);
CAPNP_DECLARE_SCHEMA(ecd19398fd88ab5c);
CAPNP_DECLARE_SCHEMA(949449ad7c11fa5c);
CAPNP_DECLARE_SCHEMA(dd2b66a791a279f0);
CAPNP_DECLARE_SCHEMA(c7263e8f88844abc);
CAPNP_DECLARE_SCHEMA(9ae342d394247cfc);
CAPNP_DECLARE_SCHEMA(ca3a89cdeb6bd6b7);
CAPNP_DECLARE_SCHEMA(eeb5843598307592);
CAPNP_DECLARE_SCHEMA(9cf5a8313c5db036);
CAPNP_DECLARE_SCHEMA(c0253868ac12e7d8);
CAPNP_DECLARE_SCHEMA(a4a08763833c7757);
CAPNP_DECLARE_SCHEMA(de82773089c0aeab);
CAPNP_DECLARE_SCHEMA(99817360625e8ca3);
CAPNP_DECLARE_SCHEMA(b70872e07eaa992f);
CAPNP_DECLARE_SCHEMA(ea72cc77253798cd);
CAPNP_DECLARE_SCHEMA(8ec30e2451f1cffe);
CAPNP_DECLARE_SCHEMA(c71cf776034a3e67);
CAPNP_DECLARE_SCHEMA(ceba982cb629f6c2);
CAPNP_DECLARE_SCHEMA(e02d3bbe1010e342);
CAPNP_DECLARE_SCHEMA(aeb2ad168e2f5697);
CAPNP_DECLARE_SCHEMA(ef428f2f67c4d439);
enum class Tag_ef428f2f67c4d439: uint16_t {
  TEST_INTERFACE,
  TEST_EXTENDS,
  TEST_PIPELINE,
  TEST_TAIL_CALLEE,
  TEST_TAIL_CALLER,
  TEST_MORE_STUFF,
};
CAPNP_DECLARE_ENUM(Tag, ef428f2f67c4d439);
CAPNP_DECLARE_SCHEMA(9e5c574772b1d462);
CAPNP_DECLARE_SCHEMA(ea2fb7dca9cdbdea);
CAPNP_DECLARE_SCHEMA(a805157b98b65469);
CAPNP_DECLARE_SCHEMA(f4c58a8ebcd0f600);
CAPNP_DECLARE_SCHEMA(d1fd8e9caf2a5d58);
CAPNP_DECLARE_SCHEMA(f610d1deb4c9e84a);
enum class RenamedEnum_f610d1deb4c9e84a: uint16_t {
  FOO,
  BAR,
  QUX,
};
CAPNP_DECLARE_ENUM(RenamedEnum, f610d1deb4c9e84a);
CAPNP_DECLARE_SCHEMA(be406b6341d52284);
CAPNP_DECLARE_SCHEMA(f6cb3f9c7a4322e0);
enum class RenamedDeeplyNestedEnum_f6cb3f9c7a4322e0: uint16_t {
  QUUX,
  CORGE,
  GARPLY,
};
CAPNP_DECLARE_ENUM(RenamedDeeplyNestedEnum, f6cb3f9c7a4322e0);
CAPNP_DECLARE_SCHEMA(89d9d1626b34017c);
CAPNP_DECLARE_SCHEMA(c3594bce5b24b722);
CAPNP_DECLARE_SCHEMA(d112a69d31ed918b);
CAPNP_DECLARE_SCHEMA(c12efc3b075adfe9);
CAPNP_DECLARE_SCHEMA(dcc3cdb4b28f6c86);

}  // namespace schemas
}  // namespace capnp

namespace capnproto_test {
namespace capnp {
namespace test {

typedef ::capnp::schemas::TestEnum_9c8e9318b29d9cd3 TestEnum;

struct TestAllTypes {
  TestAllTypes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0a8f314b80b63fd, 6, 20)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestDefaults {
  TestDefaults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb3f9ebe98c73cb6, 6, 20)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestAnyPointer {
  TestAnyPointer() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3da5a2ccd28c0d8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestAnyOthers {
  TestAnyOthers() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f49850f63c2bfa59, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestOutOfOrder {
  TestOutOfOrder() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9d5f8efe770022b, 0, 9)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnion {
  TestUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Union0;
  struct Union1;
  struct Union2;
  struct Union3;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f47697362233ce52, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnion::Union0 {
  Union0() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    U0F0S0,
    U0F0S1,
    U0F0S8,
    U0F0S16,
    U0F0S32,
    U0F0S64,
    U0F0SP,
    U0F1S0,
    U0F1S1,
    U0F1S8,
    U0F1S16,
    U0F1S32,
    U0F1S64,
    U0F1SP,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc76a82eecb7a718, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnion::Union1 {
  Union1() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    U1F0S0,
    U1F0S1,
    U1F1S1,
    U1F0S8,
    U1F1S8,
    U1F0S16,
    U1F1S16,
    U1F0S32,
    U1F1S32,
    U1F0S64,
    U1F1S64,
    U1F0SP,
    U1F1SP,
    U1F2S0,
    U1F2S1,
    U1F2S8,
    U1F2S16,
    U1F2S32,
    U1F2S64,
    U1F2SP,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee0a6b99b7dc7ab2, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnion::Union2 {
  Union2() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    U2F0S1,
    U2F0S8,
    U2F0S16,
    U2F0S32,
    U2F0S64,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(afc5fd419f0d66d4, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnion::Union3 {
  Union3() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    U3F0S1,
    U3F0S8,
    U3F0S16,
    U3F0S32,
    U3F0S64,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a2fb022ec7f30053, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnnamedUnion {
  TestUnnamedUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FOO,
    BAR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e2e784c915329b6, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnionInUnion {
  TestUnionInUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Outer;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89a9494f1b900f22, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnionInUnion::Outer {
  Outer() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    INNER,
    BAZ,
  };
  struct Inner;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d005f6c63707670c, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnionInUnion::Outer::Inner {
  Inner() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FOO,
    BAR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff9ce111c6f8e5db, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestGroups {
  TestGroups() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Groups;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc841556134c3103, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestGroups::Groups {
  Groups() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FOO,
    BAZ,
    BAR,
  };
  struct Foo;
  struct Baz;
  struct Bar;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e22ae74ff9113268, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestGroups::Groups::Foo {
  Foo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5fcba89c0c1196f, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestGroups::Groups::Baz {
  Baz() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0fa30304066a4b3, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestGroups::Groups::Bar {
  Bar() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b727c0d0091a001d, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterleavedGroups {
  TestInterleavedGroups() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Group1;
  struct Group2;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f77ed6f7454eec40, 6, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterleavedGroups::Group1 {
  Group1() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUX,
    CORGE,
    FRED,
  };
  struct Corge;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7485a3516c7d3c8, 6, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterleavedGroups::Group1::Corge {
  Corge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db0afd413f4a313a, 6, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterleavedGroups::Group2 {
  Group2() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUX,
    CORGE,
    FRED,
  };
  struct Corge;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc85a335569990e9, 6, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterleavedGroups::Group2::Corge {
  Corge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a017f0366827ee37, 6, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUnionDefaults {
  TestUnionDefaults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94f7e0b103b4b718, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestNestedTypes {
  TestNestedTypes() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::NestedEnum_b651d2fba42056d4 NestedEnum;

  struct NestedStruct;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9f2b5941a343bcd, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestNestedTypes::NestedStruct {
  NestedStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::NestedEnum_cfa0d546993a3df3 NestedEnum;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82cd03a53b29d76b, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestUsing {
  TestUsing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e78aac389e77b065, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists {
  TestLists() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Struct0;
  struct Struct1;
  struct Struct8;
  struct Struct16;
  struct Struct32;
  struct Struct64;
  struct StructP;
  struct Struct0c;
  struct Struct1c;
  struct Struct8c;
  struct Struct16c;
  struct Struct32c;
  struct Struct64c;
  struct StructPc;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e41885c94393277e, 0, 10)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct0 {
  Struct0() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8412c03b75b2cfee, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct1 {
  Struct1() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0fe5870b141ad69, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct8 {
  Struct8() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6411a353090145b, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct16 {
  Struct16() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8abf7a82928986c, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct32 {
  Struct32() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad7beedc4ed30742, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct64 {
  Struct64() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef9a34f2ff7cc646, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::StructP {
  StructP() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6abf1b0329e6227, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct0c {
  Struct0c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(943a234ca336b16a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct1c {
  Struct1c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8991bc0e74a594cd, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct8c {
  Struct8c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed267416528c7a24, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct16c {
  Struct16c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9978837b037d58e6, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct32c {
  Struct32c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed5fa940f54a7904, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::Struct64c {
  Struct64c() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc743778f2597c7d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLists::StructPc {
  StructPc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2e364a40182013d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestFieldZeroIsBit {
  TestFieldZeroIsBit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92fc29a80f3ddd5c, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestListDefaults {
  TestListDefaults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a851ad32cbc2ffea, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLateUnion {
  TestLateUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct TheUnion;
  struct AnotherUnion;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a76e3c9bb7fd56d3, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLateUnion::TheUnion {
  TheUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUX,
    CORGE,
    GRAULT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(807280a2901aa079, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestLateUnion::AnotherUnion {
  AnotherUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUX,
    CORGE,
    GRAULT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1973984dee98e3a, 3, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestOldVersion {
  TestOldVersion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95b30dd14e01dda8, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestNewVersion {
  TestNewVersion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ed75a7469f04ce3, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestOldUnionVersion {
  TestOldUnionVersion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    A,
    B,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd5fe16e5170c492, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestNewUnionVersion {
  TestNewUnionVersion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    A,
    B,
  };
  struct A;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7e4c513a975492b, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestNewUnionVersion::A {
  A() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    A0,
    A1,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86232c1de4513e84, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestStructUnion {
  TestStructUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct SomeStruct;
  struct Un;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(faf781ef89a00e39, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestStructUnion::SomeStruct {
  SomeStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9daec9823f171085, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestStructUnion::Un {
  Un() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    STRUCT,
    OBJECT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(992edc677bef5a3c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPrintInlineStructs {
  TestPrintInlineStructs() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct InlineStruct;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dec497819d097c3c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPrintInlineStructs::InlineStruct {
  InlineStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e4936003708dac2, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestWholeFloatDefault {
  TestWholeFloatDefault() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  static KJ_CONSTEXPR(const) float CONSTANT CAPNP_NON_INT_CONSTEXPR_DECL_INIT(456.0f);
  static KJ_CONSTEXPR(const) float BIG_CONSTANT CAPNP_NON_INT_CONSTEXPR_DECL_INIT(4e30f);

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(91afd4a864dbb030, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo = ::capnp::AnyPointer, typename Bar = ::capnp::AnyPointer>
struct TestGenerics {
  TestGenerics() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UV,
    UG,
  };
  struct Inner;
  template <typename Baz = ::capnp::AnyPointer>
  struct Inner2;
  template <typename Qux = ::capnp::AnyPointer>
  struct Interface;
  struct UseAliases;
  struct Ug;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d5b8cd8de9922eb, 1, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
struct TestGenerics<Foo, Bar>::Inner {
  Inner() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f6a841117e19ac73, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
template <typename Baz>
struct TestGenerics<Foo, Bar>::Inner2 {
  Inner2() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  template <typename Qux = ::capnp::AnyPointer>
  struct DeepNest;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9ab42b118d6d435, 0, 4)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Baz>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
struct TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest {
  DeepNest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  template <typename Quux = ::capnp::AnyPointer>
  struct DeepNestInterface;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6a0829c762b06f3, 0, 4)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Baz, Qux>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
struct TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface {
  DeepNestInterface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallParams;
  struct CallResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8839ed86c9794287)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Baz, Qux, Quux>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
struct TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b84eecc799437049, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Baz, Qux, Quux>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
struct TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults {
  CallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e080f0fc54614f6f, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Baz, Qux, Quux>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
template <typename Qux>
struct TestGenerics<Foo, Bar>::Interface {
  Interface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c9e749e8dd54da5c)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Qux>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Foo, typename Bar>
template <typename Qux>
struct TestGenerics<Foo, Bar>::Interface<Qux>::CallResults {
  CallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5b46224e33581ad, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar, Qux>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
struct TestGenerics<Foo, Bar>::UseAliases {
  UseAliases() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e656edfb45ba6cf, 0, 6)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo, typename Bar>
struct TestGenerics<Foo, Bar>::Ug {
  Ug() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b46a779beaf3384e, 1, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo = ::capnp::AnyPointer, typename Bar = ::capnp::AnyPointer>
struct TestGenericsWrapper {
  TestGenericsWrapper() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9b2b1f52dde845d, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct TestGenericsWrapper2 {
  TestGenericsWrapper2() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f28f83667a557a04, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestImplicitMethodParams {
  TestImplicitMethodParams() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  template <typename T = ::capnp::AnyPointer, typename U = ::capnp::AnyPointer>
  struct CallParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8b9717a3f8d85a9a)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

template <typename T, typename U>
struct TestImplicitMethodParams::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f83f8caf54bdc486, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T, U>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V = ::capnp::AnyPointer>
struct TestImplicitMethodParamsInGeneric {
  TestImplicitMethodParamsInGeneric() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  template <typename T = ::capnp::AnyPointer, typename U = ::capnp::AnyPointer>
  struct CallParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(df9ccdeb81a704c9)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
template <typename T, typename U>
struct TestImplicitMethodParamsInGeneric<V>::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9aab8e25c808d71e, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V, T, U>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Foo = ::capnp::AnyPointer, typename Bar = ::capnp::AnyPointer>
struct TestGenericsUnion {
  TestGenericsUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FOO,
    BAR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a54870440e919063, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Foo, Bar>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct TestUseGenerics {
  TestUseGenerics() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9427b2a71030338f, 0, 20)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestEmptyStruct {
  TestEmptyStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5598844441096dc, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestConstants {
  TestConstants() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  static KJ_CONSTEXPR(const)  ::capnp::Void VOID_CONST CAPNP_NON_INT_CONSTEXPR_DECL_INIT( ::capnp::VOID);
  static constexpr bool BOOL_CONST = true;
  static constexpr  ::int8_t INT8_CONST = -123;
  static constexpr  ::int16_t INT16_CONST = -12345;
  static constexpr  ::int32_t INT32_CONST = -12345678;
  static constexpr  ::int64_t INT64_CONST = -123456789012345ll;
  static constexpr  ::uint8_t UINT8_CONST = 234u;
  static constexpr  ::uint16_t UINT16_CONST = 45678u;
  static constexpr  ::uint32_t UINT32_CONST = 3456789012u;
  static constexpr  ::uint64_t UINT64_CONST = 12345678901234567890llu;
  static KJ_CONSTEXPR(const) float FLOAT32_CONST CAPNP_NON_INT_CONSTEXPR_DECL_INIT(1234.5f);
  static KJ_CONSTEXPR(const) double FLOAT64_CONST CAPNP_NON_INT_CONSTEXPR_DECL_INIT(-1.23e47);
  static const ::capnp::_::ConstText<3> TEXT_CONST;
  static const ::capnp::_::ConstData<3> DATA_CONST;
  static const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestAllTypes> STRUCT_CONST;
  static constexpr  ::capnproto_test::capnp::test::TestEnum ENUM_CONST =  ::capnproto_test::capnp::test::TestEnum::CORGE;
  static const ::capnp::_::ConstList< ::capnp::Void> VOID_LIST_CONST;
  static const ::capnp::_::ConstList<bool> BOOL_LIST_CONST;
  static const ::capnp::_::ConstList< ::int8_t> INT8_LIST_CONST;
  static const ::capnp::_::ConstList< ::int16_t> INT16_LIST_CONST;
  static const ::capnp::_::ConstList< ::int32_t> INT32_LIST_CONST;
  static const ::capnp::_::ConstList< ::int64_t> INT64_LIST_CONST;
  static const ::capnp::_::ConstList< ::uint8_t> UINT8_LIST_CONST;
  static const ::capnp::_::ConstList< ::uint16_t> UINT16_LIST_CONST;
  static const ::capnp::_::ConstList< ::uint32_t> UINT32_LIST_CONST;
  static const ::capnp::_::ConstList< ::uint64_t> UINT64_LIST_CONST;
  static const ::capnp::_::ConstList<float> FLOAT32_LIST_CONST;
  static const ::capnp::_::ConstList<double> FLOAT64_LIST_CONST;
  static const ::capnp::_::ConstList< ::capnp::Text> TEXT_LIST_CONST;
  static const ::capnp::_::ConstList< ::capnp::Data> DATA_LIST_CONST;
  static const ::capnp::_::ConstList< ::capnproto_test::capnp::test::TestAllTypes> STRUCT_LIST_CONST;
  static const ::capnp::_::ConstList< ::capnproto_test::capnp::test::TestEnum> ENUM_LIST_CONST;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abed745cd8c92095, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

static constexpr  ::uint32_t GLOBAL_INT = 12345u;
extern const ::capnp::_::ConstText<6> GLOBAL_TEXT;
extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestAllTypes> GLOBAL_STRUCT;
extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestPrintInlineStructs> GLOBAL_PRINTABLE_STRUCT;
extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestAllTypes> DERIVED_CONSTANT;
extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>> GENERIC_CONSTANT;
extern const ::capnp::_::ConstData<831> EMBEDDED_DATA;
extern const ::capnp::_::ConstText<4235> EMBEDDED_TEXT;
extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestAllTypes> EMBEDDED_STRUCT;
extern const ::capnp::_::ConstText<10> NON_ASCII_TEXT;
struct TestAnyPointerConstants {
  TestAnyPointerConstants() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddc280dbee9c99b3, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

extern const ::capnp::_::ConstStruct< ::capnproto_test::capnp::test::TestAnyPointerConstants> ANY_POINTER_CONSTANTS;
struct TestInterface {
  TestInterface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct FooParams;
  struct FooResults;
  struct BarParams;
  struct BarResults;
  struct BazParams;
  struct BazResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(88eb12a0e0af92b2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestInterface::FooParams {
  FooParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b874edc0d559b391, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterface::FooResults {
  FooResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b04fcaddab714ba4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterface::BarParams {
  BarParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d044893357b42568, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterface::BarResults {
  BarResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9bf141df4247d52f, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterface::BazParams {
  BazParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9ac8abb2a91cfbc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestInterface::BazResults {
  BazResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b99d14f2f375b2d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestExtends {
  TestExtends() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct QuxParams;
  struct QuxResults;
  struct CorgeResults;
  struct GraultParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e4e9bac98670b748)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestExtends::QuxParams {
  QuxParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83a4bc5471363f17, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestExtends::QuxResults {
  QuxResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e4b3d1a3e2753dd, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestExtends::CorgeResults {
  CorgeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(acf67532a7e7bad9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestExtends::GraultParams {
  GraultParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3b834e851ea8af6, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestExtends2 {
  TestExtends2() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE


  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(98d7e0ef61488783)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestPipeline {
  TestPipeline() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Box;
  struct AnyBox;
  struct GetCapParams;
  struct GetCapResults;
  struct TestPointersParams;
  struct TestPointersResults;
  struct GetAnyCapParams;
  struct GetAnyCapResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a5a404caa61d4cd0)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestPipeline::Box {
  Box() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0b29e51db0e26b1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::AnyBox {
  AnyBox() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9442ad5a1d2c8acb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::GetCapParams {
  GetCapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7e8df5096257034, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::GetCapResults {
  GetCapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2442a9e0ba28fdf, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::TestPointersParams {
  TestPointersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a604ee63cf37819f, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::TestPointersResults {
  TestPointersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8eda54756c6070d6, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::GetAnyCapParams {
  GetAnyCapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8e36b53ab093d4e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestPipeline::GetAnyCapResults {
  GetAnyCapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf44b4c94c26ef79, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestCallOrder {
  TestCallOrder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetCallSequenceParams;
  struct GetCallSequenceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a0e77035bdff0051)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestCallOrder::GetCallSequenceParams {
  GetCallSequenceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f1e8cd56ceb74dc, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestCallOrder::GetCallSequenceResults {
  GetCallSequenceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dedbb6bf3810eab7, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestTailCallee {
  TestTailCallee() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct TailResult;
  struct FooParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ddd699207eb8e23b)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestTailCallee::TailResult {
  TailResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9ed2e5a9fd53d19, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestTailCallee::FooParams {
  FooParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5e1efc325614957, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestTailCaller {
  TestTailCaller() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct FooParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(870bf40110ce3035)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestTailCaller::FooParams {
  FooParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b07a279515dc8ac5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestHandle {
  TestHandle() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE


  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a38e5efe41e53a15)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestMoreStuff {
  TestMoreStuff() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallFooParams;
  struct CallFooResults;
  struct CallFooWhenResolvedParams;
  struct CallFooWhenResolvedResults;
  struct NeverReturnParams;
  struct NeverReturnResults;
  struct HoldParams;
  struct HoldResults;
  struct CallHeldParams;
  struct CallHeldResults;
  struct GetHeldParams;
  struct GetHeldResults;
  struct EchoParams;
  struct EchoResults;
  struct ExpectCancelParams;
  struct ExpectCancelResults;
  struct MethodWithDefaultsParams;
  struct MethodWithDefaultsResults;
  struct GetHandleParams;
  struct GetHandleResults;
  struct GetNullParams;
  struct GetNullResults;
  struct GetEnormousStringParams;
  struct GetEnormousStringResults;
  struct MethodWithNullDefaultParams;
  struct MethodWithNullDefaultResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ddc70bf9784133cf)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestMoreStuff::CallFooParams {
  CallFooParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(931ba418da60f6e4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::CallFooResults {
  CallFooResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a28970beccecdd0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::CallFooWhenResolvedParams {
  CallFooWhenResolvedParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fabc700c2ebe6378, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::CallFooWhenResolvedResults {
  CallFooWhenResolvedResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a54ce1e9aa822f90, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::NeverReturnParams {
  NeverReturnParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(94fe60465c95182b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::NeverReturnResults {
  NeverReturnResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(def4e5fa6999c5dc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::HoldParams {
  HoldParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe7c8fbb769d8e58, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::HoldResults {
  HoldResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f839fb1374d003c9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::CallHeldParams {
  CallHeldParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8c5e5ef1edf83be, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::CallHeldResults {
  CallHeldResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e59935f160ac7578, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetHeldParams {
  GetHeldParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(feffc025fce317e3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetHeldResults {
  GetHeldResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef4e146185af67ce, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::EchoParams {
  EchoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c07526f7e2e533b9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::EchoResults {
  EchoResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6224536593d5b92, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::ExpectCancelParams {
  ExpectCancelParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1cc32d87f3edeb1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::ExpectCancelResults {
  ExpectCancelResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a3eba1758c0916e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::MethodWithDefaultsParams {
  MethodWithDefaultsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99160a25fa50fbf1, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::MethodWithDefaultsResults {
  MethodWithDefaultsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c7e066f845a6c56, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetHandleParams {
  GetHandleParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ead024a301a092a1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetHandleResults {
  GetHandleResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3490d75420a1fe8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetNullParams {
  GetNullParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8493f0e175d61f2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetNullResults {
  GetNullResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6955d8ef1023671, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetEnormousStringParams {
  GetEnormousStringParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(805df436f55dd07a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::GetEnormousStringResults {
  GetEnormousStringResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(860e7512dc3925b0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::MethodWithNullDefaultParams {
  MethodWithNullDefaultParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb92899aeb0ee74f, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMoreStuff::MethodWithNullDefaultResults {
  MethodWithNullDefaultResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8467348247305cf7, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane {
  TestMembrane() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Thing;
  struct Result;
  struct MakeThingParams;
  struct MakeThingResults;
  struct CallPassThroughParams;
  struct CallInterceptParams;
  struct LoopbackParams;
  struct LoopbackResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c07d8dcd80a69c0c)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestMembrane::Thing {
  Thing() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct PassThroughParams;
  struct InterceptParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9352e4e41f173917)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestMembrane::Thing::PassThroughParams {
  PassThroughParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff9bdcd05085d786, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::Thing::InterceptParams {
  InterceptParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee94bed3615ee745, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::Result {
  Result() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0c6163faf291965, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::MakeThingParams {
  MakeThingParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8ac2acc3ece6556, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::MakeThingResults {
  MakeThingResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5d4904814ccbf29, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::CallPassThroughParams {
  CallPassThroughParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(945d9f634a6a29da, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::CallInterceptParams {
  CallInterceptParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8749aac3375c5c71, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::LoopbackParams {
  LoopbackParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(869a1b7ab34b42c9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestMembrane::LoopbackResults {
  LoopbackResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ecd19398fd88ab5c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestContainMembrane {
  TestContainMembrane() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(949449ad7c11fa5c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestTransferCap {
  TestTransferCap() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Element;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd2b66a791a279f0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestTransferCap::Element {
  Element() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c7263e8f88844abc, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods {
  TestKeywordMethods() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DeleteParams;
  struct DeleteResults;
  struct ClassParams;
  struct ClassResults;
  struct VoidParams;
  struct VoidResults;
  struct ReturnParams;
  struct ReturnResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9ae342d394247cfc)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TestKeywordMethods::DeleteParams {
  DeleteParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca3a89cdeb6bd6b7, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::DeleteResults {
  DeleteResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eeb5843598307592, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::ClassParams {
  ClassParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9cf5a8313c5db036, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::ClassResults {
  ClassResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0253868ac12e7d8, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::VoidParams {
  VoidParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4a08763833c7757, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::VoidResults {
  VoidResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de82773089c0aeab, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::ReturnParams {
  ReturnParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99817360625e8ca3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestKeywordMethods::ReturnResults {
  ReturnResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b70872e07eaa992f, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename VatId = ::capnp::AnyPointer>
struct TestAuthenticatedBootstrap {
  TestAuthenticatedBootstrap() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetCallerIdParams;
  struct GetCallerIdResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ea72cc77253798cd)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, VatId>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename VatId>
struct TestAuthenticatedBootstrap<VatId>::GetCallerIdParams {
  GetCallerIdParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ec30e2451f1cffe, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, VatId>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename VatId>
struct TestAuthenticatedBootstrap<VatId>::GetCallerIdResults {
  GetCallerIdResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c71cf776034a3e67, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, VatId>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct TestSturdyRef {
  TestSturdyRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ceba982cb629f6c2, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestSturdyRefHostId {
  TestSturdyRefHostId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e02d3bbe1010e342, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestSturdyRefObjectId {
  TestSturdyRefObjectId() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Tag_ef428f2f67c4d439 Tag;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aeb2ad168e2f5697, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestProvisionId {
  TestProvisionId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e5c574772b1d462, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestRecipientId {
  TestRecipientId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea2fb7dca9cdbdea, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestThirdPartyCapId {
  TestThirdPartyCapId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a805157b98b65469, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TestJoinResult {
  TestJoinResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f4c58a8ebcd0f600, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedStruct {
  RenamedStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    GOOD_FIELD_NAME,
    BAR,
  };
  typedef ::capnp::schemas::RenamedEnum_f610d1deb4c9e84a RenamedEnum;

  struct RenamedNestedStruct;
  struct RenamedUnion;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1fd8e9caf2a5d58, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedStruct::RenamedNestedStruct {
  RenamedNestedStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::RenamedDeeplyNestedEnum_f6cb3f9c7a4322e0 RenamedDeeplyNestedEnum;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be406b6341d52284, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedStruct::RenamedUnion {
  RenamedUnion() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    RENAMED_GROUP,
    QUX,
  };
  struct RenamedGroup;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89d9d1626b34017c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedStruct::RenamedUnion::RenamedGroup {
  RenamedGroup() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3594bce5b24b722, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedInterface {
  RenamedInterface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RenamedMethodParams;
  struct RenamedMethodResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d112a69d31ed918b)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct RenamedInterface::RenamedMethodParams {
  RenamedMethodParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c12efc3b075adfe9, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RenamedInterface::RenamedMethodResults {
  RenamedMethodResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dcc3cdb4b28f6c86, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class TestAllTypes::Reader {
public:
  typedef TestAllTypes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getVoidField() const;

  inline bool getBoolField() const;

  inline  ::int8_t getInt8Field() const;

  inline  ::int16_t getInt16Field() const;

  inline  ::int32_t getInt32Field() const;

  inline  ::int64_t getInt64Field() const;

  inline  ::uint8_t getUInt8Field() const;

  inline  ::uint16_t getUInt16Field() const;

  inline  ::uint32_t getUInt32Field() const;

  inline  ::uint64_t getUInt64Field() const;

  inline float getFloat32Field() const;

  inline double getFloat64Field() const;

  inline bool hasTextField() const;
  inline  ::capnp::Text::Reader getTextField() const;

  inline bool hasDataField() const;
  inline  ::capnp::Data::Reader getDataField() const;

  inline bool hasStructField() const;
  inline  ::capnproto_test::capnp::test::TestAllTypes::Reader getStructField() const;

  inline  ::capnproto_test::capnp::test::TestEnum getEnumField() const;

  inline  ::capnp::Void getInterfaceField() const;

  inline bool hasVoidList() const;
  inline  ::capnp::List< ::capnp::Void>::Reader getVoidList() const;

  inline bool hasBoolList() const;
  inline  ::capnp::List<bool>::Reader getBoolList() const;

  inline bool hasInt8List() const;
  inline  ::capnp::List< ::int8_t>::Reader getInt8List() const;

  inline bool hasInt16List() const;
  inline  ::capnp::List< ::int16_t>::Reader getInt16List() const;

  inline bool hasInt32List() const;
  inline  ::capnp::List< ::int32_t>::Reader getInt32List() const;

  inline bool hasInt64List() const;
  inline  ::capnp::List< ::int64_t>::Reader getInt64List() const;

  inline bool hasUInt8List() const;
  inline  ::capnp::List< ::uint8_t>::Reader getUInt8List() const;

  inline bool hasUInt16List() const;
  inline  ::capnp::List< ::uint16_t>::Reader getUInt16List() const;

  inline bool hasUInt32List() const;
  inline  ::capnp::List< ::uint32_t>::Reader getUInt32List() const;

  inline bool hasUInt64List() const;
  inline  ::capnp::List< ::uint64_t>::Reader getUInt64List() const;

  inline bool hasFloat32List() const;
  inline  ::capnp::List<float>::Reader getFloat32List() const;

  inline bool hasFloat64List() const;
  inline  ::capnp::List<double>::Reader getFloat64List() const;

  inline bool hasTextList() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getTextList() const;

  inline bool hasDataList() const;
  inline  ::capnp::List< ::capnp::Data>::Reader getDataList() const;

  inline bool hasStructList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader getStructList() const;

  inline bool hasEnumList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader getEnumList() const;

  inline bool hasInterfaceList() const;
  inline  ::capnp::List< ::capnp::Void>::Reader getInterfaceList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestAllTypes::Builder {
public:
  typedef TestAllTypes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getVoidField();
  inline void setVoidField( ::capnp::Void value = ::capnp::VOID);

  inline bool getBoolField();
  inline void setBoolField(bool value);

  inline  ::int8_t getInt8Field();
  inline void setInt8Field( ::int8_t value);

  inline  ::int16_t getInt16Field();
  inline void setInt16Field( ::int16_t value);

  inline  ::int32_t getInt32Field();
  inline void setInt32Field( ::int32_t value);

  inline  ::int64_t getInt64Field();
  inline void setInt64Field( ::int64_t value);

  inline  ::uint8_t getUInt8Field();
  inline void setUInt8Field( ::uint8_t value);

  inline  ::uint16_t getUInt16Field();
  inline void setUInt16Field( ::uint16_t value);

  inline  ::uint32_t getUInt32Field();
  inline void setUInt32Field( ::uint32_t value);

  inline  ::uint64_t getUInt64Field();
  inline void setUInt64Field( ::uint64_t value);

  inline float getFloat32Field();
  inline void setFloat32Field(float value);

  inline double getFloat64Field();
  inline void setFloat64Field(double value);

  inline bool hasTextField();
  inline  ::capnp::Text::Builder getTextField();
  inline void setTextField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTextField(unsigned int size);
  inline void adoptTextField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTextField();

  inline bool hasDataField();
  inline  ::capnp::Data::Builder getDataField();
  inline void setDataField( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initDataField(unsigned int size);
  inline void adoptDataField(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownDataField();

  inline bool hasStructField();
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder getStructField();
  inline void setStructField( ::capnproto_test::capnp::test::TestAllTypes::Reader value);
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder initStructField();
  inline void adoptStructField(::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> disownStructField();

  inline  ::capnproto_test::capnp::test::TestEnum getEnumField();
  inline void setEnumField( ::capnproto_test::capnp::test::TestEnum value);

  inline  ::capnp::Void getInterfaceField();
  inline void setInterfaceField( ::capnp::Void value = ::capnp::VOID);

  inline bool hasVoidList();
  inline  ::capnp::List< ::capnp::Void>::Builder getVoidList();
  inline void setVoidList( ::capnp::List< ::capnp::Void>::Reader value);
  inline void setVoidList(::kj::ArrayPtr<const  ::capnp::Void> value);
  inline  ::capnp::List< ::capnp::Void>::Builder initVoidList(unsigned int size);
  inline void adoptVoidList(::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> disownVoidList();

  inline bool hasBoolList();
  inline  ::capnp::List<bool>::Builder getBoolList();
  inline void setBoolList( ::capnp::List<bool>::Reader value);
  inline void setBoolList(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool>::Builder initBoolList(unsigned int size);
  inline void adoptBoolList(::capnp::Orphan< ::capnp::List<bool>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool>> disownBoolList();

  inline bool hasInt8List();
  inline  ::capnp::List< ::int8_t>::Builder getInt8List();
  inline void setInt8List( ::capnp::List< ::int8_t>::Reader value);
  inline void setInt8List(::kj::ArrayPtr<const  ::int8_t> value);
  inline  ::capnp::List< ::int8_t>::Builder initInt8List(unsigned int size);
  inline void adoptInt8List(::capnp::Orphan< ::capnp::List< ::int8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int8_t>> disownInt8List();

  inline bool hasInt16List();
  inline  ::capnp::List< ::int16_t>::Builder getInt16List();
  inline void setInt16List( ::capnp::List< ::int16_t>::Reader value);
  inline void setInt16List(::kj::ArrayPtr<const  ::int16_t> value);
  inline  ::capnp::List< ::int16_t>::Builder initInt16List(unsigned int size);
  inline void adoptInt16List(::capnp::Orphan< ::capnp::List< ::int16_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int16_t>> disownInt16List();

  inline bool hasInt32List();
  inline  ::capnp::List< ::int32_t>::Builder getInt32List();
  inline void setInt32List( ::capnp::List< ::int32_t>::Reader value);
  inline void setInt32List(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initInt32List(unsigned int size);
  inline void adoptInt32List(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownInt32List();

  inline bool hasInt64List();
  inline  ::capnp::List< ::int64_t>::Builder getInt64List();
  inline void setInt64List( ::capnp::List< ::int64_t>::Reader value);
  inline void setInt64List(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t>::Builder initInt64List(unsigned int size);
  inline void adoptInt64List(::capnp::Orphan< ::capnp::List< ::int64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t>> disownInt64List();

  inline bool hasUInt8List();
  inline  ::capnp::List< ::uint8_t>::Builder getUInt8List();
  inline void setUInt8List( ::capnp::List< ::uint8_t>::Reader value);
  inline void setUInt8List(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t>::Builder initUInt8List(unsigned int size);
  inline void adoptUInt8List(::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> disownUInt8List();

  inline bool hasUInt16List();
  inline  ::capnp::List< ::uint16_t>::Builder getUInt16List();
  inline void setUInt16List( ::capnp::List< ::uint16_t>::Reader value);
  inline void setUInt16List(::kj::ArrayPtr<const  ::uint16_t> value);
  inline  ::capnp::List< ::uint16_t>::Builder initUInt16List(unsigned int size);
  inline void adoptUInt16List(::capnp::Orphan< ::capnp::List< ::uint16_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint16_t>> disownUInt16List();

  inline bool hasUInt32List();
  inline  ::capnp::List< ::uint32_t>::Builder getUInt32List();
  inline void setUInt32List( ::capnp::List< ::uint32_t>::Reader value);
  inline void setUInt32List(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initUInt32List(unsigned int size);
  inline void adoptUInt32List(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownUInt32List();

  inline bool hasUInt64List();
  inline  ::capnp::List< ::uint64_t>::Builder getUInt64List();
  inline void setUInt64List( ::capnp::List< ::uint64_t>::Reader value);
  inline void setUInt64List(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t>::Builder initUInt64List(unsigned int size);
  inline void adoptUInt64List(::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> disownUInt64List();

  inline bool hasFloat32List();
  inline  ::capnp::List<float>::Builder getFloat32List();
  inline void setFloat32List( ::capnp::List<float>::Reader value);
  inline void setFloat32List(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float>::Builder initFloat32List(unsigned int size);
  inline void adoptFloat32List(::capnp::Orphan< ::capnp::List<float>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float>> disownFloat32List();

  inline bool hasFloat64List();
  inline  ::capnp::List<double>::Builder getFloat64List();
  inline void setFloat64List( ::capnp::List<double>::Reader value);
  inline void setFloat64List(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double>::Builder initFloat64List(unsigned int size);
  inline void adoptFloat64List(::capnp::Orphan< ::capnp::List<double>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double>> disownFloat64List();

  inline bool hasTextList();
  inline  ::capnp::List< ::capnp::Text>::Builder getTextList();
  inline void setTextList( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setTextList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initTextList(unsigned int size);
  inline void adoptTextList(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownTextList();

  inline bool hasDataList();
  inline  ::capnp::List< ::capnp::Data>::Builder getDataList();
  inline void setDataList( ::capnp::List< ::capnp::Data>::Reader value);
  inline void setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data>::Builder initDataList(unsigned int size);
  inline void adoptDataList(::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> disownDataList();

  inline bool hasStructList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder getStructList();
  inline void setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder initStructList(unsigned int size);
  inline void adoptStructList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>> disownStructList();

  inline bool hasEnumList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder getEnumList();
  inline void setEnumList( ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader value);
  inline void setEnumList(::kj::ArrayPtr<const  ::capnproto_test::capnp::test::TestEnum> value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder initEnumList(unsigned int size);
  inline void adoptEnumList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>> disownEnumList();

  inline bool hasInterfaceList();
  inline  ::capnp::List< ::capnp::Void>::Builder getInterfaceList();
  inline void setInterfaceList( ::capnp::List< ::capnp::Void>::Reader value);
  inline void setInterfaceList(::kj::ArrayPtr<const  ::capnp::Void> value);
  inline  ::capnp::List< ::capnp::Void>::Builder initInterfaceList(unsigned int size);
  inline void adoptInterfaceList(::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> disownInterfaceList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestAllTypes::Pipeline {
public:
  typedef TestAllTypes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline getStructField();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestDefaults::Reader {
public:
  typedef TestDefaults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getVoidField() const;

  inline bool getBoolField() const;

  inline  ::int8_t getInt8Field() const;

  inline  ::int16_t getInt16Field() const;

  inline  ::int32_t getInt32Field() const;

  inline  ::int64_t getInt64Field() const;

  inline  ::uint8_t getUInt8Field() const;

  inline  ::uint16_t getUInt16Field() const;

  inline  ::uint32_t getUInt32Field() const;

  inline  ::uint64_t getUInt64Field() const;

  inline float getFloat32Field() const;

  inline double getFloat64Field() const;

  inline bool hasTextField() const;
  inline  ::capnp::Text::Reader getTextField() const;

  inline bool hasDataField() const;
  inline  ::capnp::Data::Reader getDataField() const;

  inline bool hasStructField() const;
  inline  ::capnproto_test::capnp::test::TestAllTypes::Reader getStructField() const;

  inline  ::capnproto_test::capnp::test::TestEnum getEnumField() const;

  inline  ::capnp::Void getInterfaceField() const;

  inline bool hasVoidList() const;
  inline  ::capnp::List< ::capnp::Void>::Reader getVoidList() const;

  inline bool hasBoolList() const;
  inline  ::capnp::List<bool>::Reader getBoolList() const;

  inline bool hasInt8List() const;
  inline  ::capnp::List< ::int8_t>::Reader getInt8List() const;

  inline bool hasInt16List() const;
  inline  ::capnp::List< ::int16_t>::Reader getInt16List() const;

  inline bool hasInt32List() const;
  inline  ::capnp::List< ::int32_t>::Reader getInt32List() const;

  inline bool hasInt64List() const;
  inline  ::capnp::List< ::int64_t>::Reader getInt64List() const;

  inline bool hasUInt8List() const;
  inline  ::capnp::List< ::uint8_t>::Reader getUInt8List() const;

  inline bool hasUInt16List() const;
  inline  ::capnp::List< ::uint16_t>::Reader getUInt16List() const;

  inline bool hasUInt32List() const;
  inline  ::capnp::List< ::uint32_t>::Reader getUInt32List() const;

  inline bool hasUInt64List() const;
  inline  ::capnp::List< ::uint64_t>::Reader getUInt64List() const;

  inline bool hasFloat32List() const;
  inline  ::capnp::List<float>::Reader getFloat32List() const;

  inline bool hasFloat64List() const;
  inline  ::capnp::List<double>::Reader getFloat64List() const;

  inline bool hasTextList() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getTextList() const;

  inline bool hasDataList() const;
  inline  ::capnp::List< ::capnp::Data>::Reader getDataList() const;

  inline bool hasStructList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader getStructList() const;

  inline bool hasEnumList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader getEnumList() const;

  inline bool hasInterfaceList() const;
  inline  ::capnp::List< ::capnp::Void>::Reader getInterfaceList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestDefaults::Builder {
public:
  typedef TestDefaults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getVoidField();
  inline void setVoidField( ::capnp::Void value = ::capnp::VOID);

  inline bool getBoolField();
  inline void setBoolField(bool value);

  inline  ::int8_t getInt8Field();
  inline void setInt8Field( ::int8_t value);

  inline  ::int16_t getInt16Field();
  inline void setInt16Field( ::int16_t value);

  inline  ::int32_t getInt32Field();
  inline void setInt32Field( ::int32_t value);

  inline  ::int64_t getInt64Field();
  inline void setInt64Field( ::int64_t value);

  inline  ::uint8_t getUInt8Field();
  inline void setUInt8Field( ::uint8_t value);

  inline  ::uint16_t getUInt16Field();
  inline void setUInt16Field( ::uint16_t value);

  inline  ::uint32_t getUInt32Field();
  inline void setUInt32Field( ::uint32_t value);

  inline  ::uint64_t getUInt64Field();
  inline void setUInt64Field( ::uint64_t value);

  inline float getFloat32Field();
  inline void setFloat32Field(float value);

  inline double getFloat64Field();
  inline void setFloat64Field(double value);

  inline bool hasTextField();
  inline  ::capnp::Text::Builder getTextField();
  inline void setTextField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTextField(unsigned int size);
  inline void adoptTextField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTextField();

  inline bool hasDataField();
  inline  ::capnp::Data::Builder getDataField();
  inline void setDataField( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initDataField(unsigned int size);
  inline void adoptDataField(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownDataField();

  inline bool hasStructField();
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder getStructField();
  inline void setStructField( ::capnproto_test::capnp::test::TestAllTypes::Reader value);
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder initStructField();
  inline void adoptStructField(::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> disownStructField();

  inline  ::capnproto_test::capnp::test::TestEnum getEnumField();
  inline void setEnumField( ::capnproto_test::capnp::test::TestEnum value);

  inline  ::capnp::Void getInterfaceField();
  inline void setInterfaceField( ::capnp::Void value = ::capnp::VOID);

  inline bool hasVoidList();
  inline  ::capnp::List< ::capnp::Void>::Builder getVoidList();
  inline void setVoidList( ::capnp::List< ::capnp::Void>::Reader value);
  inline void setVoidList(::kj::ArrayPtr<const  ::capnp::Void> value);
  inline  ::capnp::List< ::capnp::Void>::Builder initVoidList(unsigned int size);
  inline void adoptVoidList(::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> disownVoidList();

  inline bool hasBoolList();
  inline  ::capnp::List<bool>::Builder getBoolList();
  inline void setBoolList( ::capnp::List<bool>::Reader value);
  inline void setBoolList(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool>::Builder initBoolList(unsigned int size);
  inline void adoptBoolList(::capnp::Orphan< ::capnp::List<bool>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool>> disownBoolList();

  inline bool hasInt8List();
  inline  ::capnp::List< ::int8_t>::Builder getInt8List();
  inline void setInt8List( ::capnp::List< ::int8_t>::Reader value);
  inline void setInt8List(::kj::ArrayPtr<const  ::int8_t> value);
  inline  ::capnp::List< ::int8_t>::Builder initInt8List(unsigned int size);
  inline void adoptInt8List(::capnp::Orphan< ::capnp::List< ::int8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int8_t>> disownInt8List();

  inline bool hasInt16List();
  inline  ::capnp::List< ::int16_t>::Builder getInt16List();
  inline void setInt16List( ::capnp::List< ::int16_t>::Reader value);
  inline void setInt16List(::kj::ArrayPtr<const  ::int16_t> value);
  inline  ::capnp::List< ::int16_t>::Builder initInt16List(unsigned int size);
  inline void adoptInt16List(::capnp::Orphan< ::capnp::List< ::int16_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int16_t>> disownInt16List();

  inline bool hasInt32List();
  inline  ::capnp::List< ::int32_t>::Builder getInt32List();
  inline void setInt32List( ::capnp::List< ::int32_t>::Reader value);
  inline void setInt32List(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initInt32List(unsigned int size);
  inline void adoptInt32List(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownInt32List();

  inline bool hasInt64List();
  inline  ::capnp::List< ::int64_t>::Builder getInt64List();
  inline void setInt64List( ::capnp::List< ::int64_t>::Reader value);
  inline void setInt64List(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t>::Builder initInt64List(unsigned int size);
  inline void adoptInt64List(::capnp::Orphan< ::capnp::List< ::int64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t>> disownInt64List();

  inline bool hasUInt8List();
  inline  ::capnp::List< ::uint8_t>::Builder getUInt8List();
  inline void setUInt8List( ::capnp::List< ::uint8_t>::Reader value);
  inline void setUInt8List(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t>::Builder initUInt8List(unsigned int size);
  inline void adoptUInt8List(::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> disownUInt8List();

  inline bool hasUInt16List();
  inline  ::capnp::List< ::uint16_t>::Builder getUInt16List();
  inline void setUInt16List( ::capnp::List< ::uint16_t>::Reader value);
  inline void setUInt16List(::kj::ArrayPtr<const  ::uint16_t> value);
  inline  ::capnp::List< ::uint16_t>::Builder initUInt16List(unsigned int size);
  inline void adoptUInt16List(::capnp::Orphan< ::capnp::List< ::uint16_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint16_t>> disownUInt16List();

  inline bool hasUInt32List();
  inline  ::capnp::List< ::uint32_t>::Builder getUInt32List();
  inline void setUInt32List( ::capnp::List< ::uint32_t>::Reader value);
  inline void setUInt32List(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initUInt32List(unsigned int size);
  inline void adoptUInt32List(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownUInt32List();

  inline bool hasUInt64List();
  inline  ::capnp::List< ::uint64_t>::Builder getUInt64List();
  inline void setUInt64List( ::capnp::List< ::uint64_t>::Reader value);
  inline void setUInt64List(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t>::Builder initUInt64List(unsigned int size);
  inline void adoptUInt64List(::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> disownUInt64List();

  inline bool hasFloat32List();
  inline  ::capnp::List<float>::Builder getFloat32List();
  inline void setFloat32List( ::capnp::List<float>::Reader value);
  inline void setFloat32List(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float>::Builder initFloat32List(unsigned int size);
  inline void adoptFloat32List(::capnp::Orphan< ::capnp::List<float>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float>> disownFloat32List();

  inline bool hasFloat64List();
  inline  ::capnp::List<double>::Builder getFloat64List();
  inline void setFloat64List( ::capnp::List<double>::Reader value);
  inline void setFloat64List(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double>::Builder initFloat64List(unsigned int size);
  inline void adoptFloat64List(::capnp::Orphan< ::capnp::List<double>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double>> disownFloat64List();

  inline bool hasTextList();
  inline  ::capnp::List< ::capnp::Text>::Builder getTextList();
  inline void setTextList( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setTextList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initTextList(unsigned int size);
  inline void adoptTextList(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownTextList();

  inline bool hasDataList();
  inline  ::capnp::List< ::capnp::Data>::Builder getDataList();
  inline void setDataList( ::capnp::List< ::capnp::Data>::Reader value);
  inline void setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data>::Builder initDataList(unsigned int size);
  inline void adoptDataList(::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> disownDataList();

  inline bool hasStructList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder getStructList();
  inline void setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder initStructList(unsigned int size);
  inline void adoptStructList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>> disownStructList();

  inline bool hasEnumList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder getEnumList();
  inline void setEnumList( ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader value);
  inline void setEnumList(::kj::ArrayPtr<const  ::capnproto_test::capnp::test::TestEnum> value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder initEnumList(unsigned int size);
  inline void adoptEnumList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>> disownEnumList();

  inline bool hasInterfaceList();
  inline  ::capnp::List< ::capnp::Void>::Builder getInterfaceList();
  inline void setInterfaceList( ::capnp::List< ::capnp::Void>::Reader value);
  inline void setInterfaceList(::kj::ArrayPtr<const  ::capnp::Void> value);
  inline  ::capnp::List< ::capnp::Void>::Builder initInterfaceList(unsigned int size);
  inline void adoptInterfaceList(::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> disownInterfaceList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestDefaults::Pipeline {
public:
  typedef TestDefaults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline getStructField();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestAnyPointer::Reader {
public:
  typedef TestAnyPointer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAnyPointerField() const;
  inline ::capnp::AnyPointer::Reader getAnyPointerField() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestAnyPointer::Builder {
public:
  typedef TestAnyPointer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAnyPointerField();
  inline ::capnp::AnyPointer::Builder getAnyPointerField();
  inline ::capnp::AnyPointer::Builder initAnyPointerField();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestAnyPointer::Pipeline {
public:
  typedef TestAnyPointer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestAnyOthers::Reader {
public:
  typedef TestAnyOthers Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAnyStructField() const;
  inline  ::capnp::AnyStruct::Reader getAnyStructField() const;

  inline bool hasAnyListField() const;
  inline  ::capnp::AnyList::Reader getAnyListField() const;

  inline bool hasCapabilityField() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCapabilityField() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestAnyOthers::Builder {
public:
  typedef TestAnyOthers Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAnyStructField();
  inline  ::capnp::AnyStruct::Builder getAnyStructField();
  inline void setAnyStructField( ::capnp::AnyStruct::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyStructFieldAs();
  inline void adoptAnyStructField(::capnp::Orphan< ::capnp::AnyStruct>&& value);
  inline ::capnp::Orphan< ::capnp::AnyStruct> disownAnyStructField();

  inline bool hasAnyListField();
  inline  ::capnp::AnyList::Builder getAnyListField();
  inline void setAnyListField( ::capnp::AnyList::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyListFieldAs(unsigned int size);
  inline void adoptAnyListField(::capnp::Orphan< ::capnp::AnyList>&& value);
  inline ::capnp::Orphan< ::capnp::AnyList> disownAnyListField();

  inline bool hasCapabilityField();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCapabilityField();
  inline void setCapabilityField( ::capnp::Capability::Client&& value);
  inline void setCapabilityField( ::capnp::Capability::Client& value);
  inline void adoptCapabilityField(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownCapabilityField();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestAnyOthers::Pipeline {
public:
  typedef TestAnyOthers Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::AnyStruct::Pipeline getAnyStructField();
  inline  ::capnp::Capability::Client getCapabilityField();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestOutOfOrder::Reader {
public:
  typedef TestOutOfOrder Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasQux() const;
  inline  ::capnp::Text::Reader getQux() const;

  inline bool hasGrault() const;
  inline  ::capnp::Text::Reader getGrault() const;

  inline bool hasBar() const;
  inline  ::capnp::Text::Reader getBar() const;

  inline bool hasFoo() const;
  inline  ::capnp::Text::Reader getFoo() const;

  inline bool hasCorge() const;
  inline  ::capnp::Text::Reader getCorge() const;

  inline bool hasWaldo() const;
  inline  ::capnp::Text::Reader getWaldo() const;

  inline bool hasQuux() const;
  inline  ::capnp::Text::Reader getQuux() const;

  inline bool hasGarply() const;
  inline  ::capnp::Text::Reader getGarply() const;

  inline bool hasBaz() const;
  inline  ::capnp::Text::Reader getBaz() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestOutOfOrder::Builder {
public:
  typedef TestOutOfOrder Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasQux();
  inline  ::capnp::Text::Builder getQux();
  inline void setQux( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initQux(unsigned int size);
  inline void adoptQux(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownQux();

  inline bool hasGrault();
  inline  ::capnp::Text::Builder getGrault();
  inline void setGrault( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGrault(unsigned int size);
  inline void adoptGrault(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGrault();

  inline bool hasBar();
  inline  ::capnp::Text::Builder getBar();
  inline void setBar( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownBar();

  inline bool hasFoo();
  inline  ::capnp::Text::Builder getFoo();
  inline void setFoo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFoo();

  inline bool hasCorge();
  inline  ::capnp::Text::Builder getCorge();
  inline void setCorge( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCorge(unsigned int size);
  inline void adoptCorge(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCorge();

  inline bool hasWaldo();
  inline  ::capnp::Text::Builder getWaldo();
  inline void setWaldo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initWaldo(unsigned int size);
  inline void adoptWaldo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownWaldo();

  inline bool hasQuux();
  inline  ::capnp::Text::Builder getQuux();
  inline void setQuux( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initQuux(unsigned int size);
  inline void adoptQuux(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownQuux();

  inline bool hasGarply();
  inline  ::capnp::Text::Builder getGarply();
  inline void setGarply( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGarply(unsigned int size);
  inline void adoptGarply(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGarply();

  inline bool hasBaz();
  inline  ::capnp::Text::Builder getBaz();
  inline void setBaz( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initBaz(unsigned int size);
  inline void adoptBaz(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownBaz();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestOutOfOrder::Pipeline {
public:
  typedef TestOutOfOrder Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnion::Reader {
public:
  typedef TestUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Union0::Reader getUnion0() const;

  inline typename Union1::Reader getUnion1() const;

  inline typename Union2::Reader getUnion2() const;

  inline typename Union3::Reader getUnion3() const;

  inline bool getBit0() const;

  inline bool getBit2() const;

  inline bool getBit3() const;

  inline bool getBit4() const;

  inline bool getBit5() const;

  inline bool getBit6() const;

  inline bool getBit7() const;

  inline  ::uint8_t getByte0() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnion::Builder {
public:
  typedef TestUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Union0::Builder getUnion0();
  inline typename Union0::Builder initUnion0();

  inline typename Union1::Builder getUnion1();
  inline typename Union1::Builder initUnion1();

  inline typename Union2::Builder getUnion2();
  inline typename Union2::Builder initUnion2();

  inline typename Union3::Builder getUnion3();
  inline typename Union3::Builder initUnion3();

  inline bool getBit0();
  inline void setBit0(bool value);

  inline bool getBit2();
  inline void setBit2(bool value);

  inline bool getBit3();
  inline void setBit3(bool value);

  inline bool getBit4();
  inline void setBit4(bool value);

  inline bool getBit5();
  inline void setBit5(bool value);

  inline bool getBit6();
  inline void setBit6(bool value);

  inline bool getBit7();
  inline void setBit7(bool value);

  inline  ::uint8_t getByte0();
  inline void setByte0( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnion::Pipeline {
public:
  typedef TestUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Union0::Pipeline getUnion0();
  inline typename Union1::Pipeline getUnion1();
  inline typename Union2::Pipeline getUnion2();
  inline typename Union3::Pipeline getUnion3();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnion::Union0::Reader {
public:
  typedef Union0 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isU0f0s0() const;
  inline  ::capnp::Void getU0f0s0() const;

  inline bool isU0f0s1() const;
  inline bool getU0f0s1() const;

  inline bool isU0f0s8() const;
  inline  ::int8_t getU0f0s8() const;

  inline bool isU0f0s16() const;
  inline  ::int16_t getU0f0s16() const;

  inline bool isU0f0s32() const;
  inline  ::int32_t getU0f0s32() const;

  inline bool isU0f0s64() const;
  inline  ::int64_t getU0f0s64() const;

  inline bool isU0f0sp() const;
  inline bool hasU0f0sp() const;
  inline  ::capnp::Text::Reader getU0f0sp() const;

  inline bool isU0f1s0() const;
  inline  ::capnp::Void getU0f1s0() const;

  inline bool isU0f1s1() const;
  inline bool getU0f1s1() const;

  inline bool isU0f1s8() const;
  inline  ::int8_t getU0f1s8() const;

  inline bool isU0f1s16() const;
  inline  ::int16_t getU0f1s16() const;

  inline bool isU0f1s32() const;
  inline  ::int32_t getU0f1s32() const;

  inline bool isU0f1s64() const;
  inline  ::int64_t getU0f1s64() const;

  inline bool isU0f1sp() const;
  inline bool hasU0f1sp() const;
  inline  ::capnp::Text::Reader getU0f1sp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnion::Union0::Builder {
public:
  typedef Union0 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isU0f0s0();
  inline  ::capnp::Void getU0f0s0();
  inline void setU0f0s0( ::capnp::Void value = ::capnp::VOID);

  inline bool isU0f0s1();
  inline bool getU0f0s1();
  inline void setU0f0s1(bool value);

  inline bool isU0f0s8();
  inline  ::int8_t getU0f0s8();
  inline void setU0f0s8( ::int8_t value);

  inline bool isU0f0s16();
  inline  ::int16_t getU0f0s16();
  inline void setU0f0s16( ::int16_t value);

  inline bool isU0f0s32();
  inline  ::int32_t getU0f0s32();
  inline void setU0f0s32( ::int32_t value);

  inline bool isU0f0s64();
  inline  ::int64_t getU0f0s64();
  inline void setU0f0s64( ::int64_t value);

  inline bool isU0f0sp();
  inline bool hasU0f0sp();
  inline  ::capnp::Text::Builder getU0f0sp();
  inline void setU0f0sp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initU0f0sp(unsigned int size);
  inline void adoptU0f0sp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownU0f0sp();

  inline bool isU0f1s0();
  inline  ::capnp::Void getU0f1s0();
  inline void setU0f1s0( ::capnp::Void value = ::capnp::VOID);

  inline bool isU0f1s1();
  inline bool getU0f1s1();
  inline void setU0f1s1(bool value);

  inline bool isU0f1s8();
  inline  ::int8_t getU0f1s8();
  inline void setU0f1s8( ::int8_t value);

  inline bool isU0f1s16();
  inline  ::int16_t getU0f1s16();
  inline void setU0f1s16( ::int16_t value);

  inline bool isU0f1s32();
  inline  ::int32_t getU0f1s32();
  inline void setU0f1s32( ::int32_t value);

  inline bool isU0f1s64();
  inline  ::int64_t getU0f1s64();
  inline void setU0f1s64( ::int64_t value);

  inline bool isU0f1sp();
  inline bool hasU0f1sp();
  inline  ::capnp::Text::Builder getU0f1sp();
  inline void setU0f1sp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initU0f1sp(unsigned int size);
  inline void adoptU0f1sp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownU0f1sp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnion::Union0::Pipeline {
public:
  typedef Union0 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnion::Union1::Reader {
public:
  typedef Union1 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isU1f0s0() const;
  inline  ::capnp::Void getU1f0s0() const;

  inline bool isU1f0s1() const;
  inline bool getU1f0s1() const;

  inline bool isU1f1s1() const;
  inline bool getU1f1s1() const;

  inline bool isU1f0s8() const;
  inline  ::int8_t getU1f0s8() const;

  inline bool isU1f1s8() const;
  inline  ::int8_t getU1f1s8() const;

  inline bool isU1f0s16() const;
  inline  ::int16_t getU1f0s16() const;

  inline bool isU1f1s16() const;
  inline  ::int16_t getU1f1s16() const;

  inline bool isU1f0s32() const;
  inline  ::int32_t getU1f0s32() const;

  inline bool isU1f1s32() const;
  inline  ::int32_t getU1f1s32() const;

  inline bool isU1f0s64() const;
  inline  ::int64_t getU1f0s64() const;

  inline bool isU1f1s64() const;
  inline  ::int64_t getU1f1s64() const;

  inline bool isU1f0sp() const;
  inline bool hasU1f0sp() const;
  inline  ::capnp::Text::Reader getU1f0sp() const;

  inline bool isU1f1sp() const;
  inline bool hasU1f1sp() const;
  inline  ::capnp::Text::Reader getU1f1sp() const;

  inline bool isU1f2s0() const;
  inline  ::capnp::Void getU1f2s0() const;

  inline bool isU1f2s1() const;
  inline bool getU1f2s1() const;

  inline bool isU1f2s8() const;
  inline  ::int8_t getU1f2s8() const;

  inline bool isU1f2s16() const;
  inline  ::int16_t getU1f2s16() const;

  inline bool isU1f2s32() const;
  inline  ::int32_t getU1f2s32() const;

  inline bool isU1f2s64() const;
  inline  ::int64_t getU1f2s64() const;

  inline bool isU1f2sp() const;
  inline bool hasU1f2sp() const;
  inline  ::capnp::Text::Reader getU1f2sp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnion::Union1::Builder {
public:
  typedef Union1 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isU1f0s0();
  inline  ::capnp::Void getU1f0s0();
  inline void setU1f0s0( ::capnp::Void value = ::capnp::VOID);

  inline bool isU1f0s1();
  inline bool getU1f0s1();
  inline void setU1f0s1(bool value);

  inline bool isU1f1s1();
  inline bool getU1f1s1();
  inline void setU1f1s1(bool value);

  inline bool isU1f0s8();
  inline  ::int8_t getU1f0s8();
  inline void setU1f0s8( ::int8_t value);

  inline bool isU1f1s8();
  inline  ::int8_t getU1f1s8();
  inline void setU1f1s8( ::int8_t value);

  inline bool isU1f0s16();
  inline  ::int16_t getU1f0s16();
  inline void setU1f0s16( ::int16_t value);

  inline bool isU1f1s16();
  inline  ::int16_t getU1f1s16();
  inline void setU1f1s16( ::int16_t value);

  inline bool isU1f0s32();
  inline  ::int32_t getU1f0s32();
  inline void setU1f0s32( ::int32_t value);

  inline bool isU1f1s32();
  inline  ::int32_t getU1f1s32();
  inline void setU1f1s32( ::int32_t value);

  inline bool isU1f0s64();
  inline  ::int64_t getU1f0s64();
  inline void setU1f0s64( ::int64_t value);

  inline bool isU1f1s64();
  inline  ::int64_t getU1f1s64();
  inline void setU1f1s64( ::int64_t value);

  inline bool isU1f0sp();
  inline bool hasU1f0sp();
  inline  ::capnp::Text::Builder getU1f0sp();
  inline void setU1f0sp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initU1f0sp(unsigned int size);
  inline void adoptU1f0sp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownU1f0sp();

  inline bool isU1f1sp();
  inline bool hasU1f1sp();
  inline  ::capnp::Text::Builder getU1f1sp();
  inline void setU1f1sp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initU1f1sp(unsigned int size);
  inline void adoptU1f1sp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownU1f1sp();

  inline bool isU1f2s0();
  inline  ::capnp::Void getU1f2s0();
  inline void setU1f2s0( ::capnp::Void value = ::capnp::VOID);

  inline bool isU1f2s1();
  inline bool getU1f2s1();
  inline void setU1f2s1(bool value);

  inline bool isU1f2s8();
  inline  ::int8_t getU1f2s8();
  inline void setU1f2s8( ::int8_t value);

  inline bool isU1f2s16();
  inline  ::int16_t getU1f2s16();
  inline void setU1f2s16( ::int16_t value);

  inline bool isU1f2s32();
  inline  ::int32_t getU1f2s32();
  inline void setU1f2s32( ::int32_t value);

  inline bool isU1f2s64();
  inline  ::int64_t getU1f2s64();
  inline void setU1f2s64( ::int64_t value);

  inline bool isU1f2sp();
  inline bool hasU1f2sp();
  inline  ::capnp::Text::Builder getU1f2sp();
  inline void setU1f2sp( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initU1f2sp(unsigned int size);
  inline void adoptU1f2sp(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownU1f2sp();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnion::Union1::Pipeline {
public:
  typedef Union1 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnion::Union2::Reader {
public:
  typedef Union2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isU2f0s1() const;
  inline bool getU2f0s1() const;

  inline bool isU2f0s8() const;
  inline  ::int8_t getU2f0s8() const;

  inline bool isU2f0s16() const;
  inline  ::int16_t getU2f0s16() const;

  inline bool isU2f0s32() const;
  inline  ::int32_t getU2f0s32() const;

  inline bool isU2f0s64() const;
  inline  ::int64_t getU2f0s64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnion::Union2::Builder {
public:
  typedef Union2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isU2f0s1();
  inline bool getU2f0s1();
  inline void setU2f0s1(bool value);

  inline bool isU2f0s8();
  inline  ::int8_t getU2f0s8();
  inline void setU2f0s8( ::int8_t value);

  inline bool isU2f0s16();
  inline  ::int16_t getU2f0s16();
  inline void setU2f0s16( ::int16_t value);

  inline bool isU2f0s32();
  inline  ::int32_t getU2f0s32();
  inline void setU2f0s32( ::int32_t value);

  inline bool isU2f0s64();
  inline  ::int64_t getU2f0s64();
  inline void setU2f0s64( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnion::Union2::Pipeline {
public:
  typedef Union2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnion::Union3::Reader {
public:
  typedef Union3 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isU3f0s1() const;
  inline bool getU3f0s1() const;

  inline bool isU3f0s8() const;
  inline  ::int8_t getU3f0s8() const;

  inline bool isU3f0s16() const;
  inline  ::int16_t getU3f0s16() const;

  inline bool isU3f0s32() const;
  inline  ::int32_t getU3f0s32() const;

  inline bool isU3f0s64() const;
  inline  ::int64_t getU3f0s64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnion::Union3::Builder {
public:
  typedef Union3 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isU3f0s1();
  inline bool getU3f0s1();
  inline void setU3f0s1(bool value);

  inline bool isU3f0s8();
  inline  ::int8_t getU3f0s8();
  inline void setU3f0s8( ::int8_t value);

  inline bool isU3f0s16();
  inline  ::int16_t getU3f0s16();
  inline void setU3f0s16( ::int16_t value);

  inline bool isU3f0s32();
  inline  ::int32_t getU3f0s32();
  inline void setU3f0s32( ::int32_t value);

  inline bool isU3f0s64();
  inline  ::int64_t getU3f0s64();
  inline void setU3f0s64( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnion::Union3::Pipeline {
public:
  typedef Union3 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnnamedUnion::Reader {
public:
  typedef TestUnnamedUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasBefore() const;
  inline  ::capnp::Text::Reader getBefore() const;

  inline bool isFoo() const;
  inline  ::uint16_t getFoo() const;

  inline  ::uint16_t getMiddle() const;

  inline bool isBar() const;
  inline  ::uint32_t getBar() const;

  inline bool hasAfter() const;
  inline  ::capnp::Text::Reader getAfter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnnamedUnion::Builder {
public:
  typedef TestUnnamedUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasBefore();
  inline  ::capnp::Text::Builder getBefore();
  inline void setBefore( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initBefore(unsigned int size);
  inline void adoptBefore(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownBefore();

  inline bool isFoo();
  inline  ::uint16_t getFoo();
  inline void setFoo( ::uint16_t value);

  inline  ::uint16_t getMiddle();
  inline void setMiddle( ::uint16_t value);

  inline bool isBar();
  inline  ::uint32_t getBar();
  inline void setBar( ::uint32_t value);

  inline bool hasAfter();
  inline  ::capnp::Text::Builder getAfter();
  inline void setAfter( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAfter(unsigned int size);
  inline void adoptAfter(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAfter();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnnamedUnion::Pipeline {
public:
  typedef TestUnnamedUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnionInUnion::Reader {
public:
  typedef TestUnionInUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Outer::Reader getOuter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnionInUnion::Builder {
public:
  typedef TestUnionInUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Outer::Builder getOuter();
  inline typename Outer::Builder initOuter();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnionInUnion::Pipeline {
public:
  typedef TestUnionInUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Outer::Pipeline getOuter();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnionInUnion::Outer::Reader {
public:
  typedef Outer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isInner() const;
  inline typename Inner::Reader getInner() const;

  inline bool isBaz() const;
  inline  ::int32_t getBaz() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnionInUnion::Outer::Builder {
public:
  typedef Outer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isInner();
  inline typename Inner::Builder getInner();
  inline typename Inner::Builder initInner();

  inline bool isBaz();
  inline  ::int32_t getBaz();
  inline void setBaz( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnionInUnion::Outer::Pipeline {
public:
  typedef Outer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnionInUnion::Outer::Inner::Reader {
public:
  typedef Inner Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isFoo() const;
  inline  ::int32_t getFoo() const;

  inline bool isBar() const;
  inline  ::int32_t getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnionInUnion::Outer::Inner::Builder {
public:
  typedef Inner Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isFoo();
  inline  ::int32_t getFoo();
  inline void setFoo( ::int32_t value);

  inline bool isBar();
  inline  ::int32_t getBar();
  inline void setBar( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnionInUnion::Outer::Inner::Pipeline {
public:
  typedef Inner Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGroups::Reader {
public:
  typedef TestGroups Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Groups::Reader getGroups() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGroups::Builder {
public:
  typedef TestGroups Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Groups::Builder getGroups();
  inline typename Groups::Builder initGroups();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGroups::Pipeline {
public:
  typedef TestGroups Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Groups::Pipeline getGroups();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGroups::Groups::Reader {
public:
  typedef Groups Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isFoo() const;
  inline typename Foo::Reader getFoo() const;

  inline bool isBaz() const;
  inline typename Baz::Reader getBaz() const;

  inline bool isBar() const;
  inline typename Bar::Reader getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGroups::Groups::Builder {
public:
  typedef Groups Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isFoo();
  inline typename Foo::Builder getFoo();
  inline typename Foo::Builder initFoo();

  inline bool isBaz();
  inline typename Baz::Builder getBaz();
  inline typename Baz::Builder initBaz();

  inline bool isBar();
  inline typename Bar::Builder getBar();
  inline typename Bar::Builder initBar();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGroups::Groups::Pipeline {
public:
  typedef Groups Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGroups::Groups::Foo::Reader {
public:
  typedef Foo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge() const;

  inline  ::int64_t getGrault() const;

  inline bool hasGarply() const;
  inline  ::capnp::Text::Reader getGarply() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGroups::Groups::Foo::Builder {
public:
  typedef Foo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge();
  inline void setCorge( ::int32_t value);

  inline  ::int64_t getGrault();
  inline void setGrault( ::int64_t value);

  inline bool hasGarply();
  inline  ::capnp::Text::Builder getGarply();
  inline void setGarply( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGarply(unsigned int size);
  inline void adoptGarply(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGarply();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGroups::Groups::Foo::Pipeline {
public:
  typedef Foo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGroups::Groups::Baz::Reader {
public:
  typedef Baz Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge() const;

  inline bool hasGrault() const;
  inline  ::capnp::Text::Reader getGrault() const;

  inline bool hasGarply() const;
  inline  ::capnp::Text::Reader getGarply() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGroups::Groups::Baz::Builder {
public:
  typedef Baz Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge();
  inline void setCorge( ::int32_t value);

  inline bool hasGrault();
  inline  ::capnp::Text::Builder getGrault();
  inline void setGrault( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGrault(unsigned int size);
  inline void adoptGrault(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGrault();

  inline bool hasGarply();
  inline  ::capnp::Text::Builder getGarply();
  inline void setGarply( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGarply(unsigned int size);
  inline void adoptGarply(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGarply();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGroups::Groups::Baz::Pipeline {
public:
  typedef Baz Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGroups::Groups::Bar::Reader {
public:
  typedef Bar Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge() const;

  inline bool hasGrault() const;
  inline  ::capnp::Text::Reader getGrault() const;

  inline  ::int64_t getGarply() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGroups::Groups::Bar::Builder {
public:
  typedef Bar Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getCorge();
  inline void setCorge( ::int32_t value);

  inline bool hasGrault();
  inline  ::capnp::Text::Builder getGrault();
  inline void setGrault( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGrault(unsigned int size);
  inline void adoptGrault(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGrault();

  inline  ::int64_t getGarply();
  inline void setGarply( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGroups::Groups::Bar::Pipeline {
public:
  typedef Bar Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterleavedGroups::Reader {
public:
  typedef TestInterleavedGroups Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Group1::Reader getGroup1() const;

  inline typename Group2::Reader getGroup2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterleavedGroups::Builder {
public:
  typedef TestInterleavedGroups Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Group1::Builder getGroup1();
  inline typename Group1::Builder initGroup1();

  inline typename Group2::Builder getGroup2();
  inline typename Group2::Builder initGroup2();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterleavedGroups::Pipeline {
public:
  typedef TestInterleavedGroups Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Group1::Pipeline getGroup1();
  inline typename Group2::Pipeline getGroup2();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterleavedGroups::Group1::Reader {
public:
  typedef Group1 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getFoo() const;

  inline  ::uint64_t getBar() const;

  inline bool isQux() const;
  inline  ::uint16_t getQux() const;

  inline bool isCorge() const;
  inline typename Corge::Reader getCorge() const;

  inline bool hasWaldo() const;
  inline  ::capnp::Text::Reader getWaldo() const;

  inline bool isFred() const;
  inline bool hasFred() const;
  inline  ::capnp::Text::Reader getFred() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterleavedGroups::Group1::Builder {
public:
  typedef Group1 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getFoo();
  inline void setFoo( ::uint32_t value);

  inline  ::uint64_t getBar();
  inline void setBar( ::uint64_t value);

  inline bool isQux();
  inline  ::uint16_t getQux();
  inline void setQux( ::uint16_t value);

  inline bool isCorge();
  inline typename Corge::Builder getCorge();
  inline typename Corge::Builder initCorge();

  inline bool hasWaldo();
  inline  ::capnp::Text::Builder getWaldo();
  inline void setWaldo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initWaldo(unsigned int size);
  inline void adoptWaldo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownWaldo();

  inline bool isFred();
  inline bool hasFred();
  inline  ::capnp::Text::Builder getFred();
  inline void setFred( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFred(unsigned int size);
  inline void adoptFred(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFred();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterleavedGroups::Group1::Pipeline {
public:
  typedef Group1 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterleavedGroups::Group1::Corge::Reader {
public:
  typedef Corge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrault() const;

  inline  ::uint16_t getGarply() const;

  inline bool hasPlugh() const;
  inline  ::capnp::Text::Reader getPlugh() const;

  inline bool hasXyzzy() const;
  inline  ::capnp::Text::Reader getXyzzy() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterleavedGroups::Group1::Corge::Builder {
public:
  typedef Corge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrault();
  inline void setGrault( ::uint64_t value);

  inline  ::uint16_t getGarply();
  inline void setGarply( ::uint16_t value);

  inline bool hasPlugh();
  inline  ::capnp::Text::Builder getPlugh();
  inline void setPlugh( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPlugh(unsigned int size);
  inline void adoptPlugh(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPlugh();

  inline bool hasXyzzy();
  inline  ::capnp::Text::Builder getXyzzy();
  inline void setXyzzy( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initXyzzy(unsigned int size);
  inline void adoptXyzzy(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownXyzzy();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterleavedGroups::Group1::Corge::Pipeline {
public:
  typedef Corge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterleavedGroups::Group2::Reader {
public:
  typedef Group2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getFoo() const;

  inline  ::uint64_t getBar() const;

  inline bool isQux() const;
  inline  ::uint16_t getQux() const;

  inline bool isCorge() const;
  inline typename Corge::Reader getCorge() const;

  inline bool hasWaldo() const;
  inline  ::capnp::Text::Reader getWaldo() const;

  inline bool isFred() const;
  inline bool hasFred() const;
  inline  ::capnp::Text::Reader getFred() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterleavedGroups::Group2::Builder {
public:
  typedef Group2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getFoo();
  inline void setFoo( ::uint32_t value);

  inline  ::uint64_t getBar();
  inline void setBar( ::uint64_t value);

  inline bool isQux();
  inline  ::uint16_t getQux();
  inline void setQux( ::uint16_t value);

  inline bool isCorge();
  inline typename Corge::Builder getCorge();
  inline typename Corge::Builder initCorge();

  inline bool hasWaldo();
  inline  ::capnp::Text::Builder getWaldo();
  inline void setWaldo( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initWaldo(unsigned int size);
  inline void adoptWaldo(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownWaldo();

  inline bool isFred();
  inline bool hasFred();
  inline  ::capnp::Text::Builder getFred();
  inline void setFred( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFred(unsigned int size);
  inline void adoptFred(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFred();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterleavedGroups::Group2::Pipeline {
public:
  typedef Group2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterleavedGroups::Group2::Corge::Reader {
public:
  typedef Corge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrault() const;

  inline  ::uint16_t getGarply() const;

  inline bool hasPlugh() const;
  inline  ::capnp::Text::Reader getPlugh() const;

  inline bool hasXyzzy() const;
  inline  ::capnp::Text::Reader getXyzzy() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterleavedGroups::Group2::Corge::Builder {
public:
  typedef Corge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrault();
  inline void setGrault( ::uint64_t value);

  inline  ::uint16_t getGarply();
  inline void setGarply( ::uint16_t value);

  inline bool hasPlugh();
  inline  ::capnp::Text::Builder getPlugh();
  inline void setPlugh( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPlugh(unsigned int size);
  inline void adoptPlugh(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPlugh();

  inline bool hasXyzzy();
  inline  ::capnp::Text::Builder getXyzzy();
  inline void setXyzzy( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initXyzzy(unsigned int size);
  inline void adoptXyzzy(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownXyzzy();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterleavedGroups::Group2::Corge::Pipeline {
public:
  typedef Corge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUnionDefaults::Reader {
public:
  typedef TestUnionDefaults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS16s8s64s8Set() const;
  inline  ::capnproto_test::capnp::test::TestUnion::Reader getS16s8s64s8Set() const;

  inline bool hasS0sps1s32Set() const;
  inline  ::capnproto_test::capnp::test::TestUnion::Reader getS0sps1s32Set() const;

  inline bool hasUnnamed1() const;
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Reader getUnnamed1() const;

  inline bool hasUnnamed2() const;
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Reader getUnnamed2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUnionDefaults::Builder {
public:
  typedef TestUnionDefaults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS16s8s64s8Set();
  inline  ::capnproto_test::capnp::test::TestUnion::Builder getS16s8s64s8Set();
  inline void setS16s8s64s8Set( ::capnproto_test::capnp::test::TestUnion::Reader value);
  inline  ::capnproto_test::capnp::test::TestUnion::Builder initS16s8s64s8Set();
  inline void adoptS16s8s64s8Set(::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion> disownS16s8s64s8Set();

  inline bool hasS0sps1s32Set();
  inline  ::capnproto_test::capnp::test::TestUnion::Builder getS0sps1s32Set();
  inline void setS0sps1s32Set( ::capnproto_test::capnp::test::TestUnion::Reader value);
  inline  ::capnproto_test::capnp::test::TestUnion::Builder initS0sps1s32Set();
  inline void adoptS0sps1s32Set(::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion> disownS0sps1s32Set();

  inline bool hasUnnamed1();
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder getUnnamed1();
  inline void setUnnamed1( ::capnproto_test::capnp::test::TestUnnamedUnion::Reader value);
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder initUnnamed1();
  inline void adoptUnnamed1(::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion> disownUnnamed1();

  inline bool hasUnnamed2();
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder getUnnamed2();
  inline void setUnnamed2( ::capnproto_test::capnp::test::TestUnnamedUnion::Reader value);
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder initUnnamed2();
  inline void adoptUnnamed2(::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion> disownUnnamed2();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUnionDefaults::Pipeline {
public:
  typedef TestUnionDefaults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestUnion::Pipeline getS16s8s64s8Set();
  inline  ::capnproto_test::capnp::test::TestUnion::Pipeline getS0sps1s32Set();
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline getUnnamed1();
  inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline getUnnamed2();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestNestedTypes::Reader {
public:
  typedef TestNestedTypes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNestedStruct() const;
  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Reader getNestedStruct() const;

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum() const;

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestNestedTypes::Builder {
public:
  typedef TestNestedTypes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNestedStruct();
  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Builder getNestedStruct();
  inline void setNestedStruct( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Reader value);
  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Builder initNestedStruct();
  inline void adoptNestedStruct(::capnp::Orphan< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct> disownNestedStruct();

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum();
  inline void setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value);

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum();
  inline void setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestNestedTypes::Pipeline {
public:
  typedef TestNestedTypes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Pipeline getNestedStruct();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestNestedTypes::NestedStruct::Reader {
public:
  typedef NestedStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum() const;

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestNestedTypes::NestedStruct::Builder {
public:
  typedef NestedStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum();
  inline void setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value);

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum();
  inline void setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestNestedTypes::NestedStruct::Pipeline {
public:
  typedef NestedStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUsing::Reader {
public:
  typedef TestUsing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum() const;

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUsing::Builder {
public:
  typedef TestUsing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum getInnerNestedEnum();
  inline void setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value);

  inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum getOuterNestedEnum();
  inline void setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUsing::Pipeline {
public:
  typedef TestUsing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Reader {
public:
  typedef TestLists Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasList0() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Reader getList0() const;

  inline bool hasList1() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Reader getList1() const;

  inline bool hasList8() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Reader getList8() const;

  inline bool hasList16() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Reader getList16() const;

  inline bool hasList32() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Reader getList32() const;

  inline bool hasList64() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Reader getList64() const;

  inline bool hasListP() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Reader getListP() const;

  inline bool hasInt32ListList() const;
  inline  ::capnp::List< ::capnp::List< ::int32_t>>::Reader getInt32ListList() const;

  inline bool hasTextListList() const;
  inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Reader getTextListList() const;

  inline bool hasStructListList() const;
  inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Reader getStructListList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Builder {
public:
  typedef TestLists Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasList0();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Builder getList0();
  inline void setList0( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Builder initList0(unsigned int size);
  inline void adoptList0(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>> disownList0();

  inline bool hasList1();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Builder getList1();
  inline void setList1( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Builder initList1(unsigned int size);
  inline void adoptList1(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>> disownList1();

  inline bool hasList8();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Builder getList8();
  inline void setList8( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Builder initList8(unsigned int size);
  inline void adoptList8(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>> disownList8();

  inline bool hasList16();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Builder getList16();
  inline void setList16( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Builder initList16(unsigned int size);
  inline void adoptList16(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>> disownList16();

  inline bool hasList32();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Builder getList32();
  inline void setList32( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Builder initList32(unsigned int size);
  inline void adoptList32(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>> disownList32();

  inline bool hasList64();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Builder getList64();
  inline void setList64( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Builder initList64(unsigned int size);
  inline void adoptList64(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>> disownList64();

  inline bool hasListP();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Builder getListP();
  inline void setListP( ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Builder initListP(unsigned int size);
  inline void adoptListP(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>> disownListP();

  inline bool hasInt32ListList();
  inline  ::capnp::List< ::capnp::List< ::int32_t>>::Builder getInt32ListList();
  inline void setInt32ListList( ::capnp::List< ::capnp::List< ::int32_t>>::Reader value);
  inline void setInt32ListList(::kj::ArrayPtr<const  ::capnp::List< ::int32_t>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::int32_t>>::Builder initInt32ListList(unsigned int size);
  inline void adoptInt32ListList(::capnp::Orphan< ::capnp::List< ::capnp::List< ::int32_t>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::int32_t>>> disownInt32ListList();

  inline bool hasTextListList();
  inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Builder getTextListList();
  inline void setTextListList( ::capnp::List< ::capnp::List< ::capnp::Text>>::Reader value);
  inline void setTextListList(::kj::ArrayPtr<const  ::capnp::List< ::capnp::Text>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Builder initTextListList(unsigned int size);
  inline void adoptTextListList(::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnp::Text>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnp::Text>>> disownTextListList();

  inline bool hasStructListList();
  inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Builder getStructListList();
  inline void setStructListList( ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Reader value);
  inline void setStructListList(::kj::ArrayPtr<const  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Builder initStructListList(unsigned int size);
  inline void adoptStructListList(::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>> disownStructListList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Pipeline {
public:
  typedef TestLists Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct0::Reader {
public:
  typedef Struct0 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct0::Builder {
public:
  typedef Struct0 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getF();
  inline void setF( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct0::Pipeline {
public:
  typedef Struct0 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct1::Reader {
public:
  typedef Struct1 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct1::Builder {
public:
  typedef Struct1 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getF();
  inline void setF(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct1::Pipeline {
public:
  typedef Struct1 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct8::Reader {
public:
  typedef Struct8 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct8::Builder {
public:
  typedef Struct8 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getF();
  inline void setF( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct8::Pipeline {
public:
  typedef Struct8 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct16::Reader {
public:
  typedef Struct16 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct16::Builder {
public:
  typedef Struct16 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getF();
  inline void setF( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct16::Pipeline {
public:
  typedef Struct16 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct32::Reader {
public:
  typedef Struct32 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct32::Builder {
public:
  typedef Struct32 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getF();
  inline void setF( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct32::Pipeline {
public:
  typedef Struct32 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct64::Reader {
public:
  typedef Struct64 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct64::Builder {
public:
  typedef Struct64 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getF();
  inline void setF( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct64::Pipeline {
public:
  typedef Struct64 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::StructP::Reader {
public:
  typedef StructP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasF() const;
  inline  ::capnp::Text::Reader getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::StructP::Builder {
public:
  typedef StructP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasF();
  inline  ::capnp::Text::Builder getF();
  inline void setF( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initF(unsigned int size);
  inline void adoptF(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownF();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::StructP::Pipeline {
public:
  typedef StructP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct0c::Reader {
public:
  typedef Struct0c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct0c::Builder {
public:
  typedef Struct0c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getF();
  inline void setF( ::capnp::Void value = ::capnp::VOID);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct0c::Pipeline {
public:
  typedef Struct0c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct1c::Reader {
public:
  typedef Struct1c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct1c::Builder {
public:
  typedef Struct1c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getF();
  inline void setF(bool value);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct1c::Pipeline {
public:
  typedef Struct1c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct8c::Reader {
public:
  typedef Struct8c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct8c::Builder {
public:
  typedef Struct8c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getF();
  inline void setF( ::uint8_t value);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct8c::Pipeline {
public:
  typedef Struct8c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct16c::Reader {
public:
  typedef Struct16c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct16c::Builder {
public:
  typedef Struct16c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getF();
  inline void setF( ::uint16_t value);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct16c::Pipeline {
public:
  typedef Struct16c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct32c::Reader {
public:
  typedef Struct32c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct32c::Builder {
public:
  typedef Struct32c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getF();
  inline void setF( ::uint32_t value);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct32c::Pipeline {
public:
  typedef Struct32c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::Struct64c::Reader {
public:
  typedef Struct64c Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getF() const;

  inline bool hasPad() const;
  inline  ::capnp::Text::Reader getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::Struct64c::Builder {
public:
  typedef Struct64c Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getF();
  inline void setF( ::uint64_t value);

  inline bool hasPad();
  inline  ::capnp::Text::Builder getPad();
  inline void setPad( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPad(unsigned int size);
  inline void adoptPad(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPad();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::Struct64c::Pipeline {
public:
  typedef Struct64c Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLists::StructPc::Reader {
public:
  typedef StructPc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasF() const;
  inline  ::capnp::Text::Reader getF() const;

  inline  ::uint64_t getPad() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLists::StructPc::Builder {
public:
  typedef StructPc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasF();
  inline  ::capnp::Text::Builder getF();
  inline void setF( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initF(unsigned int size);
  inline void adoptF(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownF();

  inline  ::uint64_t getPad();
  inline void setPad( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLists::StructPc::Pipeline {
public:
  typedef StructPc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestFieldZeroIsBit::Reader {
public:
  typedef TestFieldZeroIsBit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getBit() const;

  inline bool getSecondBit() const;

  inline  ::uint8_t getThirdField() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestFieldZeroIsBit::Builder {
public:
  typedef TestFieldZeroIsBit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getBit();
  inline void setBit(bool value);

  inline bool getSecondBit();
  inline void setSecondBit(bool value);

  inline  ::uint8_t getThirdField();
  inline void setThirdField( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestFieldZeroIsBit::Pipeline {
public:
  typedef TestFieldZeroIsBit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestListDefaults::Reader {
public:
  typedef TestListDefaults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLists() const;
  inline  ::capnproto_test::capnp::test::TestLists::Reader getLists() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestListDefaults::Builder {
public:
  typedef TestListDefaults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLists();
  inline  ::capnproto_test::capnp::test::TestLists::Builder getLists();
  inline void setLists( ::capnproto_test::capnp::test::TestLists::Reader value);
  inline  ::capnproto_test::capnp::test::TestLists::Builder initLists();
  inline void adoptLists(::capnp::Orphan< ::capnproto_test::capnp::test::TestLists>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestLists> disownLists();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestListDefaults::Pipeline {
public:
  typedef TestListDefaults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestLists::Pipeline getLists();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLateUnion::Reader {
public:
  typedef TestLateUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getFoo() const;

  inline bool hasBar() const;
  inline  ::capnp::Text::Reader getBar() const;

  inline  ::int16_t getBaz() const;

  inline typename TheUnion::Reader getTheUnion() const;

  inline typename AnotherUnion::Reader getAnotherUnion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLateUnion::Builder {
public:
  typedef TestLateUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getFoo();
  inline void setFoo( ::int32_t value);

  inline bool hasBar();
  inline  ::capnp::Text::Builder getBar();
  inline void setBar( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownBar();

  inline  ::int16_t getBaz();
  inline void setBaz( ::int16_t value);

  inline typename TheUnion::Builder getTheUnion();
  inline typename TheUnion::Builder initTheUnion();

  inline typename AnotherUnion::Builder getAnotherUnion();
  inline typename AnotherUnion::Builder initAnotherUnion();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLateUnion::Pipeline {
public:
  typedef TestLateUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename TheUnion::Pipeline getTheUnion();
  inline typename AnotherUnion::Pipeline getAnotherUnion();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLateUnion::TheUnion::Reader {
public:
  typedef TheUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isQux() const;
  inline bool hasQux() const;
  inline  ::capnp::Text::Reader getQux() const;

  inline bool isCorge() const;
  inline bool hasCorge() const;
  inline  ::capnp::List< ::int32_t>::Reader getCorge() const;

  inline bool isGrault() const;
  inline float getGrault() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLateUnion::TheUnion::Builder {
public:
  typedef TheUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isQux();
  inline bool hasQux();
  inline  ::capnp::Text::Builder getQux();
  inline void setQux( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initQux(unsigned int size);
  inline void adoptQux(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownQux();

  inline bool isCorge();
  inline bool hasCorge();
  inline  ::capnp::List< ::int32_t>::Builder getCorge();
  inline void setCorge( ::capnp::List< ::int32_t>::Reader value);
  inline void setCorge(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initCorge(unsigned int size);
  inline void adoptCorge(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownCorge();

  inline bool isGrault();
  inline float getGrault();
  inline void setGrault(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLateUnion::TheUnion::Pipeline {
public:
  typedef TheUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestLateUnion::AnotherUnion::Reader {
public:
  typedef AnotherUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isQux() const;
  inline bool hasQux() const;
  inline  ::capnp::Text::Reader getQux() const;

  inline bool isCorge() const;
  inline bool hasCorge() const;
  inline  ::capnp::List< ::int32_t>::Reader getCorge() const;

  inline bool isGrault() const;
  inline float getGrault() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestLateUnion::AnotherUnion::Builder {
public:
  typedef AnotherUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isQux();
  inline bool hasQux();
  inline  ::capnp::Text::Builder getQux();
  inline void setQux( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initQux(unsigned int size);
  inline void adoptQux(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownQux();

  inline bool isCorge();
  inline bool hasCorge();
  inline  ::capnp::List< ::int32_t>::Builder getCorge();
  inline void setCorge( ::capnp::List< ::int32_t>::Reader value);
  inline void setCorge(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t>::Builder initCorge(unsigned int size);
  inline void adoptCorge(::capnp::Orphan< ::capnp::List< ::int32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t>> disownCorge();

  inline bool isGrault();
  inline float getGrault();
  inline void setGrault(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestLateUnion::AnotherUnion::Pipeline {
public:
  typedef AnotherUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestOldVersion::Reader {
public:
  typedef TestOldVersion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getOld1() const;

  inline bool hasOld2() const;
  inline  ::capnp::Text::Reader getOld2() const;

  inline bool hasOld3() const;
  inline  ::capnproto_test::capnp::test::TestOldVersion::Reader getOld3() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestOldVersion::Builder {
public:
  typedef TestOldVersion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getOld1();
  inline void setOld1( ::int64_t value);

  inline bool hasOld2();
  inline  ::capnp::Text::Builder getOld2();
  inline void setOld2( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOld2(unsigned int size);
  inline void adoptOld2(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOld2();

  inline bool hasOld3();
  inline  ::capnproto_test::capnp::test::TestOldVersion::Builder getOld3();
  inline void setOld3( ::capnproto_test::capnp::test::TestOldVersion::Reader value);
  inline  ::capnproto_test::capnp::test::TestOldVersion::Builder initOld3();
  inline void adoptOld3(::capnp::Orphan< ::capnproto_test::capnp::test::TestOldVersion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestOldVersion> disownOld3();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestOldVersion::Pipeline {
public:
  typedef TestOldVersion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestOldVersion::Pipeline getOld3();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestNewVersion::Reader {
public:
  typedef TestNewVersion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getOld1() const;

  inline bool hasOld2() const;
  inline  ::capnp::Text::Reader getOld2() const;

  inline bool hasOld3() const;
  inline  ::capnproto_test::capnp::test::TestNewVersion::Reader getOld3() const;

  inline  ::int64_t getNew1() const;

  inline bool hasNew2() const;
  inline  ::capnp::Text::Reader getNew2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestNewVersion::Builder {
public:
  typedef TestNewVersion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getOld1();
  inline void setOld1( ::int64_t value);

  inline bool hasOld2();
  inline  ::capnp::Text::Builder getOld2();
  inline void setOld2( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOld2(unsigned int size);
  inline void adoptOld2(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOld2();

  inline bool hasOld3();
  inline  ::capnproto_test::capnp::test::TestNewVersion::Builder getOld3();
  inline void setOld3( ::capnproto_test::capnp::test::TestNewVersion::Reader value);
  inline  ::capnproto_test::capnp::test::TestNewVersion::Builder initOld3();
  inline void adoptOld3(::capnp::Orphan< ::capnproto_test::capnp::test::TestNewVersion>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestNewVersion> disownOld3();

  inline  ::int64_t getNew1();
  inline void setNew1( ::int64_t value);

  inline bool hasNew2();
  inline  ::capnp::Text::Builder getNew2();
  inline void setNew2( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initNew2(unsigned int size);
  inline void adoptNew2(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownNew2();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestNewVersion::Pipeline {
public:
  typedef TestNewVersion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestNewVersion::Pipeline getOld3();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestOldUnionVersion::Reader {
public:
  typedef TestOldUnionVersion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isA() const;
  inline  ::capnp::Void getA() const;

  inline bool isB() const;
  inline  ::uint64_t getB() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestOldUnionVersion::Builder {
public:
  typedef TestOldUnionVersion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isA();
  inline  ::capnp::Void getA();
  inline void setA( ::capnp::Void value = ::capnp::VOID);

  inline bool isB();
  inline  ::uint64_t getB();
  inline void setB( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestOldUnionVersion::Pipeline {
public:
  typedef TestOldUnionVersion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestNewUnionVersion::Reader {
public:
  typedef TestNewUnionVersion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isA() const;
  inline typename A::Reader getA() const;

  inline bool isB() const;
  inline  ::uint64_t getB() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestNewUnionVersion::Builder {
public:
  typedef TestNewUnionVersion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isA();
  inline typename A::Builder getA();
  inline typename A::Builder initA();

  inline bool isB();
  inline  ::uint64_t getB();
  inline void setB( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestNewUnionVersion::Pipeline {
public:
  typedef TestNewUnionVersion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestNewUnionVersion::A::Reader {
public:
  typedef A Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isA0() const;
  inline  ::capnp::Void getA0() const;

  inline bool isA1() const;
  inline  ::uint64_t getA1() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestNewUnionVersion::A::Builder {
public:
  typedef A Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isA0();
  inline  ::capnp::Void getA0();
  inline void setA0( ::capnp::Void value = ::capnp::VOID);

  inline bool isA1();
  inline  ::uint64_t getA1();
  inline void setA1( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestNewUnionVersion::A::Pipeline {
public:
  typedef A Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestStructUnion::Reader {
public:
  typedef TestStructUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Un::Reader getUn() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestStructUnion::Builder {
public:
  typedef TestStructUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Un::Builder getUn();
  inline typename Un::Builder initUn();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestStructUnion::Pipeline {
public:
  typedef TestStructUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Un::Pipeline getUn();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestStructUnion::SomeStruct::Reader {
public:
  typedef SomeStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSomeText() const;
  inline  ::capnp::Text::Reader getSomeText() const;

  inline bool hasMoreText() const;
  inline  ::capnp::Text::Reader getMoreText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestStructUnion::SomeStruct::Builder {
public:
  typedef SomeStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSomeText();
  inline  ::capnp::Text::Builder getSomeText();
  inline void setSomeText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSomeText(unsigned int size);
  inline void adoptSomeText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSomeText();

  inline bool hasMoreText();
  inline  ::capnp::Text::Builder getMoreText();
  inline void setMoreText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initMoreText(unsigned int size);
  inline void adoptMoreText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownMoreText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestStructUnion::SomeStruct::Pipeline {
public:
  typedef SomeStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestStructUnion::Un::Reader {
public:
  typedef Un Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isStruct() const;
  inline bool hasStruct() const;
  inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Reader getStruct() const;

  inline bool isObject() const;
  inline bool hasObject() const;
  inline  ::capnproto_test::capnp::test::TestAnyPointer::Reader getObject() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestStructUnion::Un::Builder {
public:
  typedef Un Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isStruct();
  inline bool hasStruct();
  inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Builder getStruct();
  inline void setStruct( ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Reader value);
  inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Builder initStruct();
  inline void adoptStruct(::capnp::Orphan< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct> disownStruct();

  inline bool isObject();
  inline bool hasObject();
  inline  ::capnproto_test::capnp::test::TestAnyPointer::Builder getObject();
  inline void setObject( ::capnproto_test::capnp::test::TestAnyPointer::Reader value);
  inline  ::capnproto_test::capnp::test::TestAnyPointer::Builder initObject();
  inline void adoptObject(::capnp::Orphan< ::capnproto_test::capnp::test::TestAnyPointer>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAnyPointer> disownObject();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestStructUnion::Un::Pipeline {
public:
  typedef Un Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPrintInlineStructs::Reader {
public:
  typedef TestPrintInlineStructs Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSomeText() const;
  inline  ::capnp::Text::Reader getSomeText() const;

  inline bool hasStructList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Reader getStructList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPrintInlineStructs::Builder {
public:
  typedef TestPrintInlineStructs Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSomeText();
  inline  ::capnp::Text::Builder getSomeText();
  inline void setSomeText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSomeText(unsigned int size);
  inline void adoptSomeText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSomeText();

  inline bool hasStructList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Builder getStructList();
  inline void setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Builder initStructList(unsigned int size);
  inline void adoptStructList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>> disownStructList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPrintInlineStructs::Pipeline {
public:
  typedef TestPrintInlineStructs Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPrintInlineStructs::InlineStruct::Reader {
public:
  typedef InlineStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getInt32Field() const;

  inline bool hasTextField() const;
  inline  ::capnp::Text::Reader getTextField() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPrintInlineStructs::InlineStruct::Builder {
public:
  typedef InlineStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getInt32Field();
  inline void setInt32Field( ::int32_t value);

  inline bool hasTextField();
  inline  ::capnp::Text::Builder getTextField();
  inline void setTextField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTextField(unsigned int size);
  inline void adoptTextField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTextField();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPrintInlineStructs::InlineStruct::Pipeline {
public:
  typedef InlineStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestWholeFloatDefault::Reader {
public:
  typedef TestWholeFloatDefault Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getField() const;

  inline float getBigField() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestWholeFloatDefault::Builder {
public:
  typedef TestWholeFloatDefault Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getField();
  inline void setField(float value);

  inline float getBigField();
  inline void setBigField(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestWholeFloatDefault::Pipeline {
public:
  typedef TestWholeFloatDefault Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Reader {
public:
  typedef TestGenerics Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Reader asGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Reader(_reader);
  }

  inline Which which() const;
  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<Foo> getFoo() const;

  inline bool hasRev() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Reader getRev() const;

  inline bool isUv() const;
  inline  ::capnp::Void getUv() const;

  inline bool isUg() const;
  inline typename Ug::Reader getUg() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Builder {
public:
  typedef TestGenerics Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Builder asGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Builder(_builder);
  }

  inline Which which();
  inline bool hasFoo();
  inline  ::capnp::BuilderFor<Foo> getFoo();
  inline void setFoo( ::capnp::ReaderFor<Foo> value);
  inline  ::capnp::BuilderFor<Foo> initFoo();
  inline  ::capnp::BuilderFor<Foo> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<Foo>&& value);
  inline ::capnp::Orphan<Foo> disownFoo();

  inline bool hasRev();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Builder getRev();
  inline void setRev(typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Builder initRev();
  inline void adoptRev(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>> disownRev();

  inline bool isUv();
  inline  ::capnp::Void getUv();
  inline void setUv( ::capnp::Void value = ::capnp::VOID);

  inline bool isUg();
  inline typename Ug::Builder getUg();
  inline typename Ug::Builder initUg();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Pipeline {
public:
  typedef TestGenerics Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Foo> getFoo();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Pipeline getRev();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Inner::Reader {
public:
  typedef Inner Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Inner::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Inner::Reader(_reader);
  }

  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<Foo> getFoo() const;

  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<Bar> getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Inner::Builder {
public:
  typedef Inner Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Inner::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Inner::Builder(_builder);
  }

  inline bool hasFoo();
  inline  ::capnp::BuilderFor<Foo> getFoo();
  inline void setFoo( ::capnp::ReaderFor<Foo> value);
  inline  ::capnp::BuilderFor<Foo> initFoo();
  inline  ::capnp::BuilderFor<Foo> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<Foo>&& value);
  inline ::capnp::Orphan<Foo> disownFoo();

  inline bool hasBar();
  inline  ::capnp::BuilderFor<Bar> getBar();
  inline void setBar( ::capnp::ReaderFor<Bar> value);
  inline  ::capnp::BuilderFor<Bar> initBar();
  inline  ::capnp::BuilderFor<Bar> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<Bar>&& value);
  inline ::capnp::Orphan<Bar> disownBar();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Inner::Pipeline {
public:
  typedef Inner Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Foo> getFoo();
  inline  ::capnp::PipelineFor<Bar> getBar();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Baz>
class TestGenerics<Foo, Bar>::Inner2<Baz>::Reader {
public:
  typedef Inner2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::Reader asGeneric() {
    return typename Inner2<Baz2>::Reader(_reader);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader(_reader);
  }

  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<Bar> getBar() const;

  inline bool hasBaz() const;
  inline  ::capnp::ReaderFor<Baz> getBaz() const;

  inline bool hasInnerBound() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader getInnerBound() const;

  inline bool hasInnerUnbound() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Reader getInnerUnbound() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
template <typename Baz>
class TestGenerics<Foo, Bar>::Inner2<Baz>::Builder {
public:
  typedef Inner2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::Builder asGeneric() {
    return typename Inner2<Baz2>::Builder(_builder);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder(_builder);
  }

  inline bool hasBar();
  inline  ::capnp::BuilderFor<Bar> getBar();
  inline void setBar( ::capnp::ReaderFor<Bar> value);
  inline  ::capnp::BuilderFor<Bar> initBar();
  inline  ::capnp::BuilderFor<Bar> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<Bar>&& value);
  inline ::capnp::Orphan<Bar> disownBar();

  inline bool hasBaz();
  inline  ::capnp::BuilderFor<Baz> getBaz();
  inline void setBaz( ::capnp::ReaderFor<Baz> value);
  inline  ::capnp::BuilderFor<Baz> initBaz();
  inline  ::capnp::BuilderFor<Baz> initBaz(unsigned int size);
  inline void adoptBaz(::capnp::Orphan<Baz>&& value);
  inline ::capnp::Orphan<Baz> disownBaz();

  inline bool hasInnerBound();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder getInnerBound();
  inline void setInnerBound(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder initInnerBound();
  inline void adoptInnerBound(::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>&& value);
  inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner> disownInnerBound();

  inline bool hasInnerUnbound();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Builder getInnerUnbound();
  inline void setInnerUnbound( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Builder initInnerUnbound();
  inline void adoptInnerUnbound(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner> disownInnerUnbound();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
class TestGenerics<Foo, Bar>::Inner2<Baz>::Pipeline {
public:
  typedef Inner2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Bar> getBar();
  inline  ::capnp::PipelineFor<Baz> getBaz();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline getInnerBound();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Pipeline getInnerUnbound();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader {
public:
  typedef DeepNest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::Reader asGeneric() {
    return typename DeepNest<Qux2>::Reader(_reader);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Reader asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Reader(_reader);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader(_reader);
  }

  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<Foo> getFoo() const;

  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<Bar> getBar() const;

  inline bool hasBaz() const;
  inline  ::capnp::ReaderFor<Baz> getBaz() const;

  inline bool hasQux() const;
  inline  ::capnp::ReaderFor<Qux> getQux() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder {
public:
  typedef DeepNest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::Builder asGeneric() {
    return typename DeepNest<Qux2>::Builder(_builder);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Builder asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Builder(_builder);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder(_builder);
  }

  inline bool hasFoo();
  inline  ::capnp::BuilderFor<Foo> getFoo();
  inline void setFoo( ::capnp::ReaderFor<Foo> value);
  inline  ::capnp::BuilderFor<Foo> initFoo();
  inline  ::capnp::BuilderFor<Foo> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<Foo>&& value);
  inline ::capnp::Orphan<Foo> disownFoo();

  inline bool hasBar();
  inline  ::capnp::BuilderFor<Bar> getBar();
  inline void setBar( ::capnp::ReaderFor<Bar> value);
  inline  ::capnp::BuilderFor<Bar> initBar();
  inline  ::capnp::BuilderFor<Bar> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<Bar>&& value);
  inline ::capnp::Orphan<Bar> disownBar();

  inline bool hasBaz();
  inline  ::capnp::BuilderFor<Baz> getBaz();
  inline void setBaz( ::capnp::ReaderFor<Baz> value);
  inline  ::capnp::BuilderFor<Baz> initBaz();
  inline  ::capnp::BuilderFor<Baz> initBaz(unsigned int size);
  inline void adoptBaz(::capnp::Orphan<Baz>&& value);
  inline ::capnp::Orphan<Baz> disownBaz();

  inline bool hasQux();
  inline  ::capnp::BuilderFor<Qux> getQux();
  inline void setQux( ::capnp::ReaderFor<Qux> value);
  inline  ::capnp::BuilderFor<Qux> initQux();
  inline  ::capnp::BuilderFor<Qux> initQux(unsigned int size);
  inline void adoptQux(::capnp::Orphan<Qux>&& value);
  inline ::capnp::Orphan<Qux> disownQux();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Pipeline {
public:
  typedef DeepNest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Foo> getFoo();
  inline  ::capnp::PipelineFor<Bar> getBar();
  inline  ::capnp::PipelineFor<Baz> getBaz();
  inline  ::capnp::PipelineFor<Qux> getQux();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef DeepNestInterface Calls;
  typedef DeepNestInterface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Quux2 = ::capnp::AnyPointer>
  typename DeepNestInterface<Quux2>::Client asGeneric() {
    return castAs<DeepNestInterface<Quux2>>();
  }

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Client asDeepNestGeneric() {
    return castAs<typename DeepNest<Qux2>::template DeepNestInterface<Quux>>();
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Client asInner2Generic() {
    return castAs<typename Inner2<Baz2>::template DeepNest<Qux>>();
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Client asTestGenericsGeneric() {
    return castAs<typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults>) callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef DeepNestInterface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams CallParams;
  typedef typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults CallResults;
  typedef ::capnp::CallContext<CallParams, CallResults> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Quux2 = ::capnp::AnyPointer>
  typename DeepNestInterface<Quux2>::CallParams::Reader asDeepNestInterfaceGeneric() {
    return typename DeepNestInterface<Quux2>::CallParams::Reader(_reader);
  }

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Reader asDeepNestGeneric() {
    return typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Reader(_reader);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Reader asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Reader(_reader);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Quux2 = ::capnp::AnyPointer>
  typename DeepNestInterface<Quux2>::CallParams::Builder asDeepNestInterfaceGeneric() {
    return typename DeepNestInterface<Quux2>::CallParams::Builder(_builder);
  }

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Builder asDeepNestGeneric() {
    return typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Builder(_builder);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Builder asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Builder(_builder);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::Reader {
public:
  typedef CallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Quux2 = ::capnp::AnyPointer>
  typename DeepNestInterface<Quux2>::CallResults::Reader asDeepNestInterfaceGeneric() {
    return typename DeepNestInterface<Quux2>::CallResults::Reader(_reader);
  }

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Reader asDeepNestGeneric() {
    return typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Reader(_reader);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Reader asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Reader(_reader);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::Builder {
public:
  typedef CallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Quux2 = ::capnp::AnyPointer>
  typename DeepNestInterface<Quux2>::CallResults::Builder asDeepNestInterfaceGeneric() {
    return typename DeepNestInterface<Quux2>::CallResults::Builder(_builder);
  }

  template <typename Qux2 = ::capnp::AnyPointer>
  typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Builder asDeepNestGeneric() {
    return typename DeepNest<Qux2>::template DeepNestInterface<Quux>::Builder(_builder);
  }

  template <typename Baz2 = ::capnp::AnyPointer>
  typename Inner2<Baz2>::template DeepNest<Qux>::Builder asInner2Generic() {
    return typename Inner2<Baz2>::template DeepNest<Qux>::Builder(_builder);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Inner2<Baz>::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
class TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::Pipeline {
public:
  typedef CallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
class TestGenerics<Foo, Bar>::Interface<Qux>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Interface Calls;
  typedef Interface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Qux2 = ::capnp::AnyPointer>
  typename Interface<Qux2>::Client asGeneric() {
    return castAs<Interface<Qux2>>();
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Interface<Qux>::Client asTestGenericsGeneric() {
    return castAs<typename TestGenerics<Foo2, Bar2>::template Interface<Qux>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults>) callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Foo, typename Bar>
template <typename Qux>
class TestGenerics<Foo, Bar>::Interface<Qux>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Interface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults CallResults;
  typedef ::capnp::CallContext<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>, CallResults> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Qux>
class TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Reader {
public:
  typedef CallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Qux2 = ::capnp::AnyPointer>
  typename Interface<Qux2>::CallResults::Reader asInterfaceGeneric() {
    return typename Interface<Qux2>::CallResults::Reader(_reader);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Interface<Qux>::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Interface<Qux>::Reader(_reader);
  }

  inline bool hasQux() const;
  inline  ::capnp::ReaderFor<Qux> getQux() const;

  inline bool hasGen() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader getGen() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
template <typename Qux>
class TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder {
public:
  typedef CallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Qux2 = ::capnp::AnyPointer>
  typename Interface<Qux2>::CallResults::Builder asInterfaceGeneric() {
    return typename Interface<Qux2>::CallResults::Builder(_builder);
  }

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::template Interface<Qux>::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::template Interface<Qux>::Builder(_builder);
  }

  inline bool hasQux();
  inline  ::capnp::BuilderFor<Qux> getQux();
  inline void setQux( ::capnp::ReaderFor<Qux> value);
  inline  ::capnp::BuilderFor<Qux> initQux();
  inline  ::capnp::BuilderFor<Qux> initQux(unsigned int size);
  inline void adoptQux(::capnp::Orphan<Qux>&& value);
  inline ::capnp::Orphan<Qux> disownQux();

  inline bool hasGen();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder getGen();
  inline void setGen( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder initGen();
  inline void adoptGen(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> disownGen();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
class TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Pipeline {
public:
  typedef CallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Qux> getQux();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline getGen();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::UseAliases::Reader {
public:
  typedef UseAliases Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::UseAliases::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::UseAliases::Reader(_reader);
  }

  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<Foo> getFoo() const;

  inline bool hasInner() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader getInner() const;

  inline bool hasInner2() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Reader getInner2() const;

  inline bool hasInner2Bind() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader getInner2Bind() const;

  inline bool hasInner2Text() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader getInner2Text() const;

  inline bool hasRevFoo() const;
  inline  ::capnp::ReaderFor<Bar> getRevFoo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::UseAliases::Builder {
public:
  typedef UseAliases Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::UseAliases::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::UseAliases::Builder(_builder);
  }

  inline bool hasFoo();
  inline  ::capnp::BuilderFor<Foo> getFoo();
  inline void setFoo( ::capnp::ReaderFor<Foo> value);
  inline  ::capnp::BuilderFor<Foo> initFoo();
  inline  ::capnp::BuilderFor<Foo> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<Foo>&& value);
  inline ::capnp::Orphan<Foo> disownFoo();

  inline bool hasInner();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder getInner();
  inline void setInner(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder initInner();
  inline void adoptInner(::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>&& value);
  inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner> disownInner();

  inline bool hasInner2();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Builder getInner2();
  inline void setInner2(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Builder initInner2();
  inline void adoptInner2(::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>> disownInner2();

  inline bool hasInner2Bind();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder getInner2Bind();
  inline void setInner2Bind(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder initInner2Bind();
  inline void adoptInner2Bind(::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>&& value);
  inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>> disownInner2Bind();

  inline bool hasInner2Text();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder getInner2Text();
  inline void setInner2Text(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder initInner2Text();
  inline void adoptInner2Text(::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>&& value);
  inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>> disownInner2Text();

  inline bool hasRevFoo();
  inline  ::capnp::BuilderFor<Bar> getRevFoo();
  inline void setRevFoo( ::capnp::ReaderFor<Bar> value);
  inline  ::capnp::BuilderFor<Bar> initRevFoo();
  inline  ::capnp::BuilderFor<Bar> initRevFoo(unsigned int size);
  inline void adoptRevFoo(::capnp::Orphan<Bar>&& value);
  inline ::capnp::Orphan<Bar> disownRevFoo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::UseAliases::Pipeline {
public:
  typedef UseAliases Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Foo> getFoo();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline getInner();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Pipeline getInner2();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline getInner2Bind();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline getInner2Text();
  inline  ::capnp::PipelineFor<Bar> getRevFoo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Ug::Reader {
public:
  typedef Ug Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Ug::Reader asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Ug::Reader(_reader);
  }

  inline  ::int32_t getUgfoo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Ug::Builder {
public:
  typedef Ug Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenerics<Foo2, Bar2>::Ug::Builder asTestGenericsGeneric() {
    return typename TestGenerics<Foo2, Bar2>::Ug::Builder(_builder);
  }

  inline  ::int32_t getUgfoo();
  inline void setUgfoo( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenerics<Foo, Bar>::Ug::Pipeline {
public:
  typedef Ug Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenericsWrapper<Foo, Bar>::Reader {
public:
  typedef TestGenericsWrapper Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenericsWrapper<Foo2, Bar2>::Reader asGeneric() {
    return typename TestGenericsWrapper<Foo2, Bar2>::Reader(_reader);
  }

  inline bool hasValue() const;
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenericsWrapper<Foo, Bar>::Builder {
public:
  typedef TestGenericsWrapper Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenericsWrapper<Foo2, Bar2>::Builder asGeneric() {
    return typename TestGenericsWrapper<Foo2, Bar2>::Builder(_builder);
  }

  inline bool hasValue();
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Builder getValue();
  inline void setValue(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Reader value);
  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenericsWrapper<Foo, Bar>::Pipeline {
public:
  typedef TestGenericsWrapper Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestGenericsWrapper2::Reader {
public:
  typedef TestGenericsWrapper2 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestGenericsWrapper2::Builder {
public:
  typedef TestGenericsWrapper2 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder getValue();
  inline void setValue( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestGenericsWrapper2::Pipeline {
public:
  typedef TestGenericsWrapper2 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestImplicitMethodParams::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestImplicitMethodParams Calls;
  typedef TestImplicitMethodParams Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T, typename U>
  ::capnp::Request< ::capnproto_test::capnp::test::TestImplicitMethodParams::CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>> callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestImplicitMethodParams::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestImplicitMethodParams Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestImplicitMethodParams::CallParams<> CallParams;
  typedef ::capnp::CallContext<CallParams,  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline  ::capnproto_test::capnp::test::TestImplicitMethodParams::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestImplicitMethodParams>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T, typename U>
class TestImplicitMethodParams::CallParams<T, U>::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer, typename U2 = ::capnp::AnyPointer>
  typename CallParams<T2, U2>::Reader asGeneric() {
    return typename CallParams<T2, U2>::Reader(_reader);
  }

  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<T> getFoo() const;

  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<U> getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T, typename U>
class TestImplicitMethodParams::CallParams<T, U>::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer, typename U2 = ::capnp::AnyPointer>
  typename CallParams<T2, U2>::Builder asGeneric() {
    return typename CallParams<T2, U2>::Builder(_builder);
  }

  inline bool hasFoo();
  inline  ::capnp::BuilderFor<T> getFoo();
  inline void setFoo( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initFoo();
  inline  ::capnp::BuilderFor<T> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownFoo();

  inline bool hasBar();
  inline  ::capnp::BuilderFor<U> getBar();
  inline void setBar( ::capnp::ReaderFor<U> value);
  inline  ::capnp::BuilderFor<U> initBar();
  inline  ::capnp::BuilderFor<U> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<U>&& value);
  inline ::capnp::Orphan<U> disownBar();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T, typename U>
class TestImplicitMethodParams::CallParams<T, U>::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<T> getFoo();
  inline  ::capnp::PipelineFor<U> getBar();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class TestImplicitMethodParamsInGeneric<V>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestImplicitMethodParamsInGeneric Calls;
  typedef TestImplicitMethodParamsInGeneric Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename TestImplicitMethodParamsInGeneric<V2>::Client asGeneric() {
    return castAs<TestImplicitMethodParamsInGeneric<V2>>();
  }

  template <typename T, typename U>
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>>) callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class TestImplicitMethodParamsInGeneric<V>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestImplicitMethodParamsInGeneric Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<> CallParams;
  typedef ::capnp::CallContext<CallParams,  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
template <typename T, typename U>
class TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer, typename U2 = ::capnp::AnyPointer>
  typename CallParams<T2, U2>::Reader asGeneric() {
    return typename CallParams<T2, U2>::Reader(_reader);
  }

  template <typename V2 = ::capnp::AnyPointer>
  typename TestImplicitMethodParamsInGeneric<V2>::template CallParams<T, U>::Reader asTestImplicitMethodParamsInGenericGeneric() {
    return typename TestImplicitMethodParamsInGeneric<V2>::template CallParams<T, U>::Reader(_reader);
  }

  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<T> getFoo() const;

  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<U> getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
template <typename T, typename U>
class TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer, typename U2 = ::capnp::AnyPointer>
  typename CallParams<T2, U2>::Builder asGeneric() {
    return typename CallParams<T2, U2>::Builder(_builder);
  }

  template <typename V2 = ::capnp::AnyPointer>
  typename TestImplicitMethodParamsInGeneric<V2>::template CallParams<T, U>::Builder asTestImplicitMethodParamsInGenericGeneric() {
    return typename TestImplicitMethodParamsInGeneric<V2>::template CallParams<T, U>::Builder(_builder);
  }

  inline bool hasFoo();
  inline  ::capnp::BuilderFor<T> getFoo();
  inline void setFoo( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initFoo();
  inline  ::capnp::BuilderFor<T> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownFoo();

  inline bool hasBar();
  inline  ::capnp::BuilderFor<U> getBar();
  inline void setBar( ::capnp::ReaderFor<U> value);
  inline  ::capnp::BuilderFor<U> initBar();
  inline  ::capnp::BuilderFor<U> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<U>&& value);
  inline ::capnp::Orphan<U> disownBar();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
template <typename T, typename U>
class TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<T> getFoo();
  inline  ::capnp::PipelineFor<U> getBar();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
class TestGenericsUnion<Foo, Bar>::Reader {
public:
  typedef TestGenericsUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenericsUnion<Foo2, Bar2>::Reader asGeneric() {
    return typename TestGenericsUnion<Foo2, Bar2>::Reader(_reader);
  }

  inline Which which() const;
  inline bool isFoo() const;
  inline bool hasFoo() const;
  inline  ::capnp::ReaderFor<Foo> getFoo() const;

  inline bool isBar() const;
  inline bool hasBar() const;
  inline  ::capnp::ReaderFor<Bar> getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Foo, typename Bar>
class TestGenericsUnion<Foo, Bar>::Builder {
public:
  typedef TestGenericsUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Foo2 = ::capnp::AnyPointer, typename Bar2 = ::capnp::AnyPointer>
  typename TestGenericsUnion<Foo2, Bar2>::Builder asGeneric() {
    return typename TestGenericsUnion<Foo2, Bar2>::Builder(_builder);
  }

  inline Which which();
  inline bool isFoo();
  inline bool hasFoo();
  inline  ::capnp::BuilderFor<Foo> getFoo();
  inline void setFoo( ::capnp::ReaderFor<Foo> value);
  inline  ::capnp::BuilderFor<Foo> initFoo();
  inline  ::capnp::BuilderFor<Foo> initFoo(unsigned int size);
  inline void adoptFoo(::capnp::Orphan<Foo>&& value);
  inline ::capnp::Orphan<Foo> disownFoo();

  inline bool isBar();
  inline bool hasBar();
  inline  ::capnp::BuilderFor<Bar> getBar();
  inline void setBar( ::capnp::ReaderFor<Bar> value);
  inline  ::capnp::BuilderFor<Bar> initBar();
  inline  ::capnp::BuilderFor<Bar> initBar(unsigned int size);
  inline void adoptBar(::capnp::Orphan<Bar>&& value);
  inline ::capnp::Orphan<Bar> disownBar();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Foo, typename Bar>
class TestGenericsUnion<Foo, Bar>::Pipeline {
public:
  typedef TestGenericsUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestUseGenerics::Reader {
public:
  typedef TestUseGenerics Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasic() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader getBasic() const;

  inline bool hasInner() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader getInner() const;

  inline bool hasInner2() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader getInner2() const;

  inline bool hasUnspecified() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Reader getUnspecified() const;

  inline bool hasUnspecifiedInner() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Reader getUnspecifiedInner() const;

  inline bool hasDefault() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Reader getDefault() const;

  inline bool hasDefaultInner() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Reader getDefaultInner() const;

  inline bool hasDefaultUser() const;
  inline  ::capnproto_test::capnp::test::TestUseGenerics::Reader getDefaultUser() const;

  inline bool hasWrapper() const;
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader getWrapper() const;

  inline bool hasDefaultWrapper() const;
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader getDefaultWrapper() const;

  inline bool hasDefaultWrapper2() const;
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Reader getDefaultWrapper2() const;

  inline bool hasAliasFoo() const;
  inline  ::capnproto_test::capnp::test::TestAllTypes::Reader getAliasFoo() const;

  inline bool hasAliasInner() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader getAliasInner() const;

  inline bool hasAliasInner2() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Reader getAliasInner2() const;

  inline bool hasAliasInner2Bind() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Reader getAliasInner2Bind() const;

  inline bool hasAliasInner2Text() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader getAliasInner2Text() const;

  inline bool hasAliasRev() const;
  inline  ::capnp::Text::Reader getAliasRev() const;

  inline bool hasUseAliases() const;
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Reader getUseAliases() const;

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Reader getCap() const;
#endif  // !CAPNP_LITE

  inline bool hasGenericCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client getGenericCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestUseGenerics::Builder {
public:
  typedef TestUseGenerics Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasic();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder getBasic();
  inline void setBasic( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder initBasic();
  inline void adoptBasic(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> disownBasic();

  inline bool hasInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder getInner();
  inline void setInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder initInner();
  inline void adoptInner(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner> disownInner();

  inline bool hasInner2();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder getInner2();
  inline void setInner2( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder initInner2();
  inline void adoptInner2(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>> disownInner2();

  inline bool hasUnspecified();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Builder getUnspecified();
  inline void setUnspecified( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Builder initUnspecified();
  inline void adoptUnspecified(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>> disownUnspecified();

  inline bool hasUnspecifiedInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Builder getUnspecifiedInner();
  inline void setUnspecifiedInner( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Builder initUnspecifiedInner();
  inline void adoptUnspecifiedInner(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>> disownUnspecifiedInner();

  inline bool hasDefault();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Builder getDefault();
  inline void setDefault( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Builder initDefault();
  inline void adoptDefault(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>> disownDefault();

  inline bool hasDefaultInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Builder getDefaultInner();
  inline void setDefaultInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Builder initDefaultInner();
  inline void adoptDefaultInner(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner> disownDefaultInner();

  inline bool hasDefaultUser();
  inline  ::capnproto_test::capnp::test::TestUseGenerics::Builder getDefaultUser();
  inline void setDefaultUser( ::capnproto_test::capnp::test::TestUseGenerics::Reader value);
  inline  ::capnproto_test::capnp::test::TestUseGenerics::Builder initDefaultUser();
  inline void adoptDefaultUser(::capnp::Orphan< ::capnproto_test::capnp::test::TestUseGenerics>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUseGenerics> disownDefaultUser();

  inline bool hasWrapper();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder getWrapper();
  inline void setWrapper( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder initWrapper();
  inline void adoptWrapper(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> disownWrapper();

  inline bool hasDefaultWrapper();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder getDefaultWrapper();
  inline void setDefaultWrapper( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder initDefaultWrapper();
  inline void adoptDefaultWrapper(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>> disownDefaultWrapper();

  inline bool hasDefaultWrapper2();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Builder getDefaultWrapper2();
  inline void setDefaultWrapper2( ::capnproto_test::capnp::test::TestGenericsWrapper2::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Builder initDefaultWrapper2();
  inline void adoptDefaultWrapper2(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper2>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper2> disownDefaultWrapper2();

  inline bool hasAliasFoo();
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder getAliasFoo();
  inline void setAliasFoo( ::capnproto_test::capnp::test::TestAllTypes::Reader value);
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder initAliasFoo();
  inline void adoptAliasFoo(::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> disownAliasFoo();

  inline bool hasAliasInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder getAliasInner();
  inline void setAliasInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder initAliasInner();
  inline void adoptAliasInner(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner> disownAliasInner();

  inline bool hasAliasInner2();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Builder getAliasInner2();
  inline void setAliasInner2( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Builder initAliasInner2();
  inline void adoptAliasInner2(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>> disownAliasInner2();

  inline bool hasAliasInner2Bind();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Builder getAliasInner2Bind();
  inline void setAliasInner2Bind( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Builder initAliasInner2Bind();
  inline void adoptAliasInner2Bind(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>> disownAliasInner2Bind();

  inline bool hasAliasInner2Text();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder getAliasInner2Text();
  inline void setAliasInner2Text( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder initAliasInner2Text();
  inline void adoptAliasInner2Text(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>> disownAliasInner2Text();

  inline bool hasAliasRev();
  inline  ::capnp::Text::Builder getAliasRev();
  inline void setAliasRev( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAliasRev(unsigned int size);
  inline void adoptAliasRev(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAliasRev();

  inline bool hasUseAliases();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Builder getUseAliases();
  inline void setUseAliases( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Builder initUseAliases();
  inline void adoptUseAliases(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases> disownUseAliases();

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Builder getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Reader value);
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Builder initCap();
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>> disownCap();
#endif  // !CAPNP_LITE

  inline bool hasGenericCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client getGenericCap();
  inline void setGenericCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client&& value);
  inline void setGenericCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client& value);
  inline void adoptGenericCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>> disownGenericCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestUseGenerics::Pipeline {
public:
  typedef TestUseGenerics Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline getBasic();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline getInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline getInner2();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Pipeline getUnspecified();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Pipeline getUnspecifiedInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Pipeline getDefault();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Pipeline getDefaultInner();
  inline  ::capnproto_test::capnp::test::TestUseGenerics::Pipeline getDefaultUser();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline getWrapper();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline getDefaultWrapper();
  inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Pipeline getDefaultWrapper2();
  inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline getAliasFoo();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline getAliasInner();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Pipeline getAliasInner2();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Pipeline getAliasInner2Bind();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline getAliasInner2Text();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Pipeline getUseAliases();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Pipeline getCap();
  inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client getGenericCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestEmptyStruct::Reader {
public:
  typedef TestEmptyStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestEmptyStruct::Builder {
public:
  typedef TestEmptyStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestEmptyStruct::Pipeline {
public:
  typedef TestEmptyStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestConstants::Reader {
public:
  typedef TestConstants Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestConstants::Builder {
public:
  typedef TestConstants Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestConstants::Pipeline {
public:
  typedef TestConstants Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestAnyPointerConstants::Reader {
public:
  typedef TestAnyPointerConstants Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAnyKindAsStruct() const;
  inline ::capnp::AnyPointer::Reader getAnyKindAsStruct() const;

  inline bool hasAnyStructAsStruct() const;
  inline  ::capnp::AnyStruct::Reader getAnyStructAsStruct() const;

  inline bool hasAnyKindAsList() const;
  inline ::capnp::AnyPointer::Reader getAnyKindAsList() const;

  inline bool hasAnyListAsList() const;
  inline  ::capnp::AnyList::Reader getAnyListAsList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestAnyPointerConstants::Builder {
public:
  typedef TestAnyPointerConstants Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAnyKindAsStruct();
  inline ::capnp::AnyPointer::Builder getAnyKindAsStruct();
  inline ::capnp::AnyPointer::Builder initAnyKindAsStruct();

  inline bool hasAnyStructAsStruct();
  inline  ::capnp::AnyStruct::Builder getAnyStructAsStruct();
  inline void setAnyStructAsStruct( ::capnp::AnyStruct::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyStructAsStructAs();
  inline void adoptAnyStructAsStruct(::capnp::Orphan< ::capnp::AnyStruct>&& value);
  inline ::capnp::Orphan< ::capnp::AnyStruct> disownAnyStructAsStruct();

  inline bool hasAnyKindAsList();
  inline ::capnp::AnyPointer::Builder getAnyKindAsList();
  inline ::capnp::AnyPointer::Builder initAnyKindAsList();

  inline bool hasAnyListAsList();
  inline  ::capnp::AnyList::Builder getAnyListAsList();
  inline void setAnyListAsList( ::capnp::AnyList::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyListAsListAs(unsigned int size);
  inline void adoptAnyListAsList(::capnp::Orphan< ::capnp::AnyList>&& value);
  inline ::capnp::Orphan< ::capnp::AnyList> disownAnyListAsList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestAnyPointerConstants::Pipeline {
public:
  typedef TestAnyPointerConstants Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::AnyStruct::Pipeline getAnyStructAsStruct();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestInterface::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestInterface Calls;
  typedef TestInterface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestInterface::FooParams,  ::capnproto_test::capnp::test::TestInterface::FooResults> fooRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestInterface::BarParams,  ::capnproto_test::capnp::test::TestInterface::BarResults> barRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestInterface::BazParams,  ::capnproto_test::capnp::test::TestInterface::BazResults> bazRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestInterface::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestInterface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestInterface::FooParams FooParams;
  typedef  ::capnproto_test::capnp::test::TestInterface::FooResults FooResults;
  typedef ::capnp::CallContext<FooParams, FooResults> FooContext;
  virtual ::kj::Promise<void> foo(FooContext context);
  typedef  ::capnproto_test::capnp::test::TestInterface::BarParams BarParams;
  typedef  ::capnproto_test::capnp::test::TestInterface::BarResults BarResults;
  typedef ::capnp::CallContext<BarParams, BarResults> BarContext;
  virtual ::kj::Promise<void> bar(BarContext context);
  typedef  ::capnproto_test::capnp::test::TestInterface::BazParams BazParams;
  typedef  ::capnproto_test::capnp::test::TestInterface::BazResults BazResults;
  typedef ::capnp::CallContext<BazParams, BazResults> BazContext;
  virtual ::kj::Promise<void> baz(BazContext context);

  inline  ::capnproto_test::capnp::test::TestInterface::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestInterface>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestInterface::FooParams::Reader {
public:
  typedef FooParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getI() const;

  inline bool getJ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::FooParams::Builder {
public:
  typedef FooParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getI();
  inline void setI( ::uint32_t value);

  inline bool getJ();
  inline void setJ(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::FooParams::Pipeline {
public:
  typedef FooParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterface::FooResults::Reader {
public:
  typedef FooResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasX() const;
  inline  ::capnp::Text::Reader getX() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::FooResults::Builder {
public:
  typedef FooResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasX();
  inline  ::capnp::Text::Builder getX();
  inline void setX( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initX(unsigned int size);
  inline void adoptX(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownX();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::FooResults::Pipeline {
public:
  typedef FooResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterface::BarParams::Reader {
public:
  typedef BarParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::BarParams::Builder {
public:
  typedef BarParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::BarParams::Pipeline {
public:
  typedef BarParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterface::BarResults::Reader {
public:
  typedef BarResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::BarResults::Builder {
public:
  typedef BarResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::BarResults::Pipeline {
public:
  typedef BarResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterface::BazParams::Reader {
public:
  typedef BazParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnproto_test::capnp::test::TestAllTypes::Reader getS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::BazParams::Builder {
public:
  typedef BazParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder getS();
  inline void setS( ::capnproto_test::capnp::test::TestAllTypes::Reader value);
  inline  ::capnproto_test::capnp::test::TestAllTypes::Builder initS();
  inline void adoptS(::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> disownS();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::BazParams::Pipeline {
public:
  typedef BazParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline getS();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestInterface::BazResults::Reader {
public:
  typedef BazResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestInterface::BazResults::Builder {
public:
  typedef BazResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestInterface::BazResults::Pipeline {
public:
  typedef BazResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestExtends::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::capnproto_test::capnp::test::TestInterface::Client {
public:
  typedef TestExtends Calls;
  typedef TestExtends Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestExtends::QuxParams,  ::capnproto_test::capnp::test::TestExtends::QuxResults> quxRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestExtends::CorgeResults> corgeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestExtends::GraultParams,  ::capnproto_test::capnp::test::TestAllTypes> graultRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestExtends::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::capnproto_test::capnp::test::TestInterface::Server {
public:
  typedef TestExtends Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestExtends::QuxParams QuxParams;
  typedef  ::capnproto_test::capnp::test::TestExtends::QuxResults QuxResults;
  typedef ::capnp::CallContext<QuxParams, QuxResults> QuxContext;
  virtual ::kj::Promise<void> qux(QuxContext context);
  typedef  ::capnproto_test::capnp::test::TestExtends::CorgeResults CorgeResults;
  typedef ::capnp::CallContext< ::capnproto_test::capnp::test::TestAllTypes, CorgeResults> CorgeContext;
  virtual ::kj::Promise<void> corge(CorgeContext context);
  typedef  ::capnproto_test::capnp::test::TestExtends::GraultParams GraultParams;
  typedef ::capnp::CallContext<GraultParams,  ::capnproto_test::capnp::test::TestAllTypes> GraultContext;
  virtual ::kj::Promise<void> grault(GraultContext context);

  inline  ::capnproto_test::capnp::test::TestExtends::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestExtends>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestExtends::QuxParams::Reader {
public:
  typedef QuxParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestExtends::QuxParams::Builder {
public:
  typedef QuxParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestExtends::QuxParams::Pipeline {
public:
  typedef QuxParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestExtends::QuxResults::Reader {
public:
  typedef QuxResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestExtends::QuxResults::Builder {
public:
  typedef QuxResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestExtends::QuxResults::Pipeline {
public:
  typedef QuxResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestExtends::CorgeResults::Reader {
public:
  typedef CorgeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestExtends::CorgeResults::Builder {
public:
  typedef CorgeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestExtends::CorgeResults::Pipeline {
public:
  typedef CorgeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestExtends::GraultParams::Reader {
public:
  typedef GraultParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestExtends::GraultParams::Builder {
public:
  typedef GraultParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestExtends::GraultParams::Pipeline {
public:
  typedef GraultParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestExtends2::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::capnproto_test::capnp::test::TestExtends::Client {
public:
  typedef TestExtends2 Calls;
  typedef TestExtends2 Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);


protected:
  Client() = default;
};

class TestExtends2::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::capnproto_test::capnp::test::TestExtends::Server {
public:
  typedef TestExtends2 Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:

  inline  ::capnproto_test::capnp::test::TestExtends2::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestExtends2>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestPipeline::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestPipeline Calls;
  typedef TestPipeline Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestPipeline::GetCapParams,  ::capnproto_test::capnp::test::TestPipeline::GetCapResults> getCapRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestPipeline::TestPointersParams,  ::capnproto_test::capnp::test::TestPipeline::TestPointersResults> testPointersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestPipeline::GetAnyCapParams,  ::capnproto_test::capnp::test::TestPipeline::GetAnyCapResults> getAnyCapRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestPipeline::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestPipeline Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestPipeline::GetCapParams GetCapParams;
  typedef  ::capnproto_test::capnp::test::TestPipeline::GetCapResults GetCapResults;
  typedef ::capnp::CallContext<GetCapParams, GetCapResults> GetCapContext;
  virtual ::kj::Promise<void> getCap(GetCapContext context);
  typedef  ::capnproto_test::capnp::test::TestPipeline::TestPointersParams TestPointersParams;
  typedef  ::capnproto_test::capnp::test::TestPipeline::TestPointersResults TestPointersResults;
  typedef ::capnp::CallContext<TestPointersParams, TestPointersResults> TestPointersContext;
  virtual ::kj::Promise<void> testPointers(TestPointersContext context);
  typedef  ::capnproto_test::capnp::test::TestPipeline::GetAnyCapParams GetAnyCapParams;
  typedef  ::capnproto_test::capnp::test::TestPipeline::GetAnyCapResults GetAnyCapResults;
  typedef ::capnp::CallContext<GetAnyCapParams, GetAnyCapResults> GetAnyCapContext;
  virtual ::kj::Promise<void> getAnyCap(GetAnyCapContext context);

  inline  ::capnproto_test::capnp::test::TestPipeline::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestPipeline>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestPipeline::Box::Reader {
public:
  typedef Box Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::Box::Builder {
public:
  typedef Box Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::Box::Pipeline {
public:
  typedef Box Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::AnyBox::Reader {
public:
  typedef AnyBox Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::AnyBox::Builder {
public:
  typedef AnyBox Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap();
  inline void setCap( ::capnp::Capability::Client&& value);
  inline void setCap( ::capnp::Capability::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::AnyBox::Pipeline {
public:
  typedef AnyBox Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::GetCapParams::Reader {
public:
  typedef GetCapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN() const;

  inline bool hasInCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getInCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::GetCapParams::Builder {
public:
  typedef GetCapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN();
  inline void setN( ::uint32_t value);

  inline bool hasInCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getInCap();
  inline void setInCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setInCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptInCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownInCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::GetCapParams::Pipeline {
public:
  typedef GetCapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getInCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::GetCapResults::Reader {
public:
  typedef GetCapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnp::Text::Reader getS() const;

  inline bool hasOutBox() const;
  inline  ::capnproto_test::capnp::test::TestPipeline::Box::Reader getOutBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::GetCapResults::Builder {
public:
  typedef GetCapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnp::Text::Builder getS();
  inline void setS( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initS(unsigned int size);
  inline void adoptS(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownS();

  inline bool hasOutBox();
  inline  ::capnproto_test::capnp::test::TestPipeline::Box::Builder getOutBox();
  inline void setOutBox( ::capnproto_test::capnp::test::TestPipeline::Box::Reader value);
  inline  ::capnproto_test::capnp::test::TestPipeline::Box::Builder initOutBox();
  inline void adoptOutBox(::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::Box>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::Box> disownOutBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::GetCapResults::Pipeline {
public:
  typedef GetCapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestPipeline::Box::Pipeline getOutBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::TestPointersParams::Reader {
public:
  typedef TestPointersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

  inline bool hasObj() const;
  inline ::capnp::AnyPointer::Reader getObj() const;

  inline bool hasList() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Reader getList() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::TestPointersParams::Builder {
public:
  typedef TestPointersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

  inline bool hasObj();
  inline ::capnp::AnyPointer::Builder getObj();
  inline ::capnp::AnyPointer::Builder initObj();

  inline bool hasList();
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Builder getList();
  inline void setList( ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Builder initList(unsigned int size);
  inline void adoptList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>> disownList();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::TestPointersParams::Pipeline {
public:
  typedef TestPointersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::TestPointersResults::Reader {
public:
  typedef TestPointersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::TestPointersResults::Builder {
public:
  typedef TestPointersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::TestPointersResults::Pipeline {
public:
  typedef TestPointersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::GetAnyCapParams::Reader {
public:
  typedef GetAnyCapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN() const;

  inline bool hasInCap() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getInCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::GetAnyCapParams::Builder {
public:
  typedef GetAnyCapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN();
  inline void setN( ::uint32_t value);

  inline bool hasInCap();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getInCap();
  inline void setInCap( ::capnp::Capability::Client&& value);
  inline void setInCap( ::capnp::Capability::Client& value);
  inline void adoptInCap(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownInCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::GetAnyCapParams::Pipeline {
public:
  typedef GetAnyCapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getInCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestPipeline::GetAnyCapResults::Reader {
public:
  typedef GetAnyCapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnp::Text::Reader getS() const;

  inline bool hasOutBox() const;
  inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Reader getOutBox() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestPipeline::GetAnyCapResults::Builder {
public:
  typedef GetAnyCapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnp::Text::Builder getS();
  inline void setS( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initS(unsigned int size);
  inline void adoptS(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownS();

  inline bool hasOutBox();
  inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Builder getOutBox();
  inline void setOutBox( ::capnproto_test::capnp::test::TestPipeline::AnyBox::Reader value);
  inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Builder initOutBox();
  inline void adoptOutBox(::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::AnyBox>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::AnyBox> disownOutBox();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestPipeline::GetAnyCapResults::Pipeline {
public:
  typedef GetAnyCapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Pipeline getOutBox();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestCallOrder::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestCallOrder Calls;
  typedef TestCallOrder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestCallOrder::GetCallSequenceParams,  ::capnproto_test::capnp::test::TestCallOrder::GetCallSequenceResults> getCallSequenceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestCallOrder::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestCallOrder Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestCallOrder::GetCallSequenceParams GetCallSequenceParams;
  typedef  ::capnproto_test::capnp::test::TestCallOrder::GetCallSequenceResults GetCallSequenceResults;
  typedef ::capnp::CallContext<GetCallSequenceParams, GetCallSequenceResults> GetCallSequenceContext;
  virtual ::kj::Promise<void> getCallSequence(GetCallSequenceContext context);

  inline  ::capnproto_test::capnp::test::TestCallOrder::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestCallOrder>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestCallOrder::GetCallSequenceParams::Reader {
public:
  typedef GetCallSequenceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getExpected() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestCallOrder::GetCallSequenceParams::Builder {
public:
  typedef GetCallSequenceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getExpected();
  inline void setExpected( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestCallOrder::GetCallSequenceParams::Pipeline {
public:
  typedef GetCallSequenceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestCallOrder::GetCallSequenceResults::Reader {
public:
  typedef GetCallSequenceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestCallOrder::GetCallSequenceResults::Builder {
public:
  typedef GetCallSequenceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getN();
  inline void setN( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestCallOrder::GetCallSequenceResults::Pipeline {
public:
  typedef GetCallSequenceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestTailCallee::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestTailCallee Calls;
  typedef TestTailCallee Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestTailCallee::FooParams,  ::capnproto_test::capnp::test::TestTailCallee::TailResult> fooRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestTailCallee::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestTailCallee Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestTailCallee::FooParams FooParams;
  typedef ::capnp::CallContext<FooParams,  ::capnproto_test::capnp::test::TestTailCallee::TailResult> FooContext;
  virtual ::kj::Promise<void> foo(FooContext context);

  inline  ::capnproto_test::capnp::test::TestTailCallee::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestTailCallee>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestTailCallee::TailResult::Reader {
public:
  typedef TailResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getI() const;

  inline bool hasT() const;
  inline  ::capnp::Text::Reader getT() const;

  inline bool hasC() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getC() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestTailCallee::TailResult::Builder {
public:
  typedef TailResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getI();
  inline void setI( ::uint32_t value);

  inline bool hasT();
  inline  ::capnp::Text::Builder getT();
  inline void setT( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initT(unsigned int size);
  inline void adoptT(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownT();

  inline bool hasC();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getC();
  inline void setC( ::capnproto_test::capnp::test::TestCallOrder::Client&& value);
  inline void setC( ::capnproto_test::capnp::test::TestCallOrder::Client& value);
  inline void adoptC(::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> disownC();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestTailCallee::TailResult::Pipeline {
public:
  typedef TailResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getC();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestTailCallee::FooParams::Reader {
public:
  typedef FooParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getI() const;

  inline bool hasT() const;
  inline  ::capnp::Text::Reader getT() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestTailCallee::FooParams::Builder {
public:
  typedef FooParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getI();
  inline void setI( ::int32_t value);

  inline bool hasT();
  inline  ::capnp::Text::Builder getT();
  inline void setT( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initT(unsigned int size);
  inline void adoptT(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownT();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestTailCallee::FooParams::Pipeline {
public:
  typedef FooParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestTailCaller::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestTailCaller Calls;
  typedef TestTailCaller Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestTailCaller::FooParams,  ::capnproto_test::capnp::test::TestTailCallee::TailResult> fooRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestTailCaller::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestTailCaller Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestTailCaller::FooParams FooParams;
  typedef ::capnp::CallContext<FooParams,  ::capnproto_test::capnp::test::TestTailCallee::TailResult> FooContext;
  virtual ::kj::Promise<void> foo(FooContext context);

  inline  ::capnproto_test::capnp::test::TestTailCaller::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestTailCaller>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestTailCaller::FooParams::Reader {
public:
  typedef FooParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getI() const;

  inline bool hasCallee() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestTailCallee::Client getCallee() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestTailCaller::FooParams::Builder {
public:
  typedef FooParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getI();
  inline void setI( ::int32_t value);

  inline bool hasCallee();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestTailCallee::Client getCallee();
  inline void setCallee( ::capnproto_test::capnp::test::TestTailCallee::Client&& value);
  inline void setCallee( ::capnproto_test::capnp::test::TestTailCallee::Client& value);
  inline void adoptCallee(::capnp::Orphan< ::capnproto_test::capnp::test::TestTailCallee>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestTailCallee> disownCallee();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestTailCaller::FooParams::Pipeline {
public:
  typedef FooParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestTailCallee::Client getCallee();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestHandle::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestHandle Calls;
  typedef TestHandle Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);


protected:
  Client() = default;
};

class TestHandle::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestHandle Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:

  inline  ::capnproto_test::capnp::test::TestHandle::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestHandle>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestMoreStuff::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::capnproto_test::capnp::test::TestCallOrder::Client {
public:
  typedef TestMoreStuff Calls;
  typedef TestMoreStuff Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::CallFooParams,  ::capnproto_test::capnp::test::TestMoreStuff::CallFooResults> callFooRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::CallFooWhenResolvedParams,  ::capnproto_test::capnp::test::TestMoreStuff::CallFooWhenResolvedResults> callFooWhenResolvedRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::NeverReturnParams,  ::capnproto_test::capnp::test::TestMoreStuff::NeverReturnResults> neverReturnRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::HoldParams,  ::capnproto_test::capnp::test::TestMoreStuff::HoldResults> holdRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::CallHeldParams,  ::capnproto_test::capnp::test::TestMoreStuff::CallHeldResults> callHeldRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::GetHeldParams,  ::capnproto_test::capnp::test::TestMoreStuff::GetHeldResults> getHeldRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::EchoParams,  ::capnproto_test::capnp::test::TestMoreStuff::EchoResults> echoRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::ExpectCancelParams,  ::capnproto_test::capnp::test::TestMoreStuff::ExpectCancelResults> expectCancelRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::MethodWithDefaultsParams,  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithDefaultsResults> methodWithDefaultsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::GetHandleParams,  ::capnproto_test::capnp::test::TestMoreStuff::GetHandleResults> getHandleRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::GetNullParams,  ::capnproto_test::capnp::test::TestMoreStuff::GetNullResults> getNullRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::GetEnormousStringParams,  ::capnproto_test::capnp::test::TestMoreStuff::GetEnormousStringResults> getEnormousStringRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMoreStuff::MethodWithNullDefaultParams,  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithNullDefaultResults> methodWithNullDefaultRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestMoreStuff::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::capnproto_test::capnp::test::TestCallOrder::Server {
public:
  typedef TestMoreStuff Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallFooParams CallFooParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallFooResults CallFooResults;
  typedef ::capnp::CallContext<CallFooParams, CallFooResults> CallFooContext;
  virtual ::kj::Promise<void> callFoo(CallFooContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallFooWhenResolvedParams CallFooWhenResolvedParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallFooWhenResolvedResults CallFooWhenResolvedResults;
  typedef ::capnp::CallContext<CallFooWhenResolvedParams, CallFooWhenResolvedResults> CallFooWhenResolvedContext;
  virtual ::kj::Promise<void> callFooWhenResolved(CallFooWhenResolvedContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::NeverReturnParams NeverReturnParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::NeverReturnResults NeverReturnResults;
  typedef ::capnp::CallContext<NeverReturnParams, NeverReturnResults> NeverReturnContext;
  virtual ::kj::Promise<void> neverReturn(NeverReturnContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::HoldParams HoldParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::HoldResults HoldResults;
  typedef ::capnp::CallContext<HoldParams, HoldResults> HoldContext;
  virtual ::kj::Promise<void> hold(HoldContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallHeldParams CallHeldParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::CallHeldResults CallHeldResults;
  typedef ::capnp::CallContext<CallHeldParams, CallHeldResults> CallHeldContext;
  virtual ::kj::Promise<void> callHeld(CallHeldContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetHeldParams GetHeldParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetHeldResults GetHeldResults;
  typedef ::capnp::CallContext<GetHeldParams, GetHeldResults> GetHeldContext;
  virtual ::kj::Promise<void> getHeld(GetHeldContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::EchoParams EchoParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::EchoResults EchoResults;
  typedef ::capnp::CallContext<EchoParams, EchoResults> EchoContext;
  virtual ::kj::Promise<void> echo(EchoContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::ExpectCancelParams ExpectCancelParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::ExpectCancelResults ExpectCancelResults;
  typedef ::capnp::CallContext<ExpectCancelParams, ExpectCancelResults> ExpectCancelContext;
  virtual ::kj::Promise<void> expectCancel(ExpectCancelContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithDefaultsParams MethodWithDefaultsParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithDefaultsResults MethodWithDefaultsResults;
  typedef ::capnp::CallContext<MethodWithDefaultsParams, MethodWithDefaultsResults> MethodWithDefaultsContext;
  virtual ::kj::Promise<void> methodWithDefaults(MethodWithDefaultsContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetHandleParams GetHandleParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetHandleResults GetHandleResults;
  typedef ::capnp::CallContext<GetHandleParams, GetHandleResults> GetHandleContext;
  virtual ::kj::Promise<void> getHandle(GetHandleContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetNullParams GetNullParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetNullResults GetNullResults;
  typedef ::capnp::CallContext<GetNullParams, GetNullResults> GetNullContext;
  virtual ::kj::Promise<void> getNull(GetNullContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetEnormousStringParams GetEnormousStringParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::GetEnormousStringResults GetEnormousStringResults;
  typedef ::capnp::CallContext<GetEnormousStringParams, GetEnormousStringResults> GetEnormousStringContext;
  virtual ::kj::Promise<void> getEnormousString(GetEnormousStringContext context);
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithNullDefaultParams MethodWithNullDefaultParams;
  typedef  ::capnproto_test::capnp::test::TestMoreStuff::MethodWithNullDefaultResults MethodWithNullDefaultResults;
  typedef ::capnp::CallContext<MethodWithNullDefaultParams, MethodWithNullDefaultResults> MethodWithNullDefaultContext;
  virtual ::kj::Promise<void> methodWithNullDefault(MethodWithNullDefaultContext context);

  inline  ::capnproto_test::capnp::test::TestMoreStuff::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestMoreStuff>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallFooParams::Reader {
public:
  typedef CallFooParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallFooParams::Builder {
public:
  typedef CallFooParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallFooParams::Pipeline {
public:
  typedef CallFooParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallFooResults::Reader {
public:
  typedef CallFooResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnp::Text::Reader getS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallFooResults::Builder {
public:
  typedef CallFooResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnp::Text::Builder getS();
  inline void setS( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initS(unsigned int size);
  inline void adoptS(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownS();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallFooResults::Pipeline {
public:
  typedef CallFooResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallFooWhenResolvedParams::Reader {
public:
  typedef CallFooWhenResolvedParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallFooWhenResolvedParams::Builder {
public:
  typedef CallFooWhenResolvedParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallFooWhenResolvedParams::Pipeline {
public:
  typedef CallFooWhenResolvedParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallFooWhenResolvedResults::Reader {
public:
  typedef CallFooWhenResolvedResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnp::Text::Reader getS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallFooWhenResolvedResults::Builder {
public:
  typedef CallFooWhenResolvedResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnp::Text::Builder getS();
  inline void setS( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initS(unsigned int size);
  inline void adoptS(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownS();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallFooWhenResolvedResults::Pipeline {
public:
  typedef CallFooWhenResolvedResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::NeverReturnParams::Reader {
public:
  typedef NeverReturnParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::NeverReturnParams::Builder {
public:
  typedef NeverReturnParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::NeverReturnParams::Pipeline {
public:
  typedef NeverReturnParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::NeverReturnResults::Reader {
public:
  typedef NeverReturnResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCapCopy() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCapCopy() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::NeverReturnResults::Builder {
public:
  typedef NeverReturnResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCapCopy();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCapCopy();
  inline void setCapCopy( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCapCopy( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCapCopy(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCapCopy();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::NeverReturnResults::Pipeline {
public:
  typedef NeverReturnResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCapCopy();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::HoldParams::Reader {
public:
  typedef HoldParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::HoldParams::Builder {
public:
  typedef HoldParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::HoldParams::Pipeline {
public:
  typedef HoldParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::HoldResults::Reader {
public:
  typedef HoldResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::HoldResults::Builder {
public:
  typedef HoldResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::HoldResults::Pipeline {
public:
  typedef HoldResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallHeldParams::Reader {
public:
  typedef CallHeldParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallHeldParams::Builder {
public:
  typedef CallHeldParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallHeldParams::Pipeline {
public:
  typedef CallHeldParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::CallHeldResults::Reader {
public:
  typedef CallHeldResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasS() const;
  inline  ::capnp::Text::Reader getS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::CallHeldResults::Builder {
public:
  typedef CallHeldResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasS();
  inline  ::capnp::Text::Builder getS();
  inline void setS( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initS(unsigned int size);
  inline void adoptS(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownS();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::CallHeldResults::Pipeline {
public:
  typedef CallHeldResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetHeldParams::Reader {
public:
  typedef GetHeldParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetHeldParams::Builder {
public:
  typedef GetHeldParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetHeldParams::Pipeline {
public:
  typedef GetHeldParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetHeldResults::Reader {
public:
  typedef GetHeldResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetHeldResults::Builder {
public:
  typedef GetHeldResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetHeldResults::Pipeline {
public:
  typedef GetHeldResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::EchoParams::Reader {
public:
  typedef EchoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::EchoParams::Builder {
public:
  typedef EchoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestCallOrder::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestCallOrder::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::EchoParams::Pipeline {
public:
  typedef EchoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::EchoResults::Reader {
public:
  typedef EchoResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::EchoResults::Builder {
public:
  typedef EchoResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestCallOrder::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestCallOrder::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::EchoResults::Pipeline {
public:
  typedef EchoResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestCallOrder::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::ExpectCancelParams::Reader {
public:
  typedef ExpectCancelParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::ExpectCancelParams::Builder {
public:
  typedef ExpectCancelParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::ExpectCancelParams::Pipeline {
public:
  typedef ExpectCancelParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::ExpectCancelResults::Reader {
public:
  typedef ExpectCancelResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::ExpectCancelResults::Builder {
public:
  typedef ExpectCancelResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::ExpectCancelResults::Pipeline {
public:
  typedef ExpectCancelResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::MethodWithDefaultsParams::Reader {
public:
  typedef MethodWithDefaultsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasA() const;
  inline  ::capnp::Text::Reader getA() const;

  inline  ::uint32_t getB() const;

  inline bool hasC() const;
  inline  ::capnp::Text::Reader getC() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::MethodWithDefaultsParams::Builder {
public:
  typedef MethodWithDefaultsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasA();
  inline  ::capnp::Text::Builder getA();
  inline void setA( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initA(unsigned int size);
  inline void adoptA(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownA();

  inline  ::uint32_t getB();
  inline void setB( ::uint32_t value);

  inline bool hasC();
  inline  ::capnp::Text::Builder getC();
  inline void setC( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initC(unsigned int size);
  inline void adoptC(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownC();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::MethodWithDefaultsParams::Pipeline {
public:
  typedef MethodWithDefaultsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::MethodWithDefaultsResults::Reader {
public:
  typedef MethodWithDefaultsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasD() const;
  inline  ::capnp::Text::Reader getD() const;

  inline bool hasE() const;
  inline  ::capnp::Text::Reader getE() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::MethodWithDefaultsResults::Builder {
public:
  typedef MethodWithDefaultsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasD();
  inline  ::capnp::Text::Builder getD();
  inline void setD( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initD(unsigned int size);
  inline void adoptD(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownD();

  inline bool hasE();
  inline  ::capnp::Text::Builder getE();
  inline void setE( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initE(unsigned int size);
  inline void adoptE(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownE();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::MethodWithDefaultsResults::Pipeline {
public:
  typedef MethodWithDefaultsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetHandleParams::Reader {
public:
  typedef GetHandleParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetHandleParams::Builder {
public:
  typedef GetHandleParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetHandleParams::Pipeline {
public:
  typedef GetHandleParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetHandleResults::Reader {
public:
  typedef GetHandleResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHandle() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestHandle::Client getHandle() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetHandleResults::Builder {
public:
  typedef GetHandleResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHandle();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestHandle::Client getHandle();
  inline void setHandle( ::capnproto_test::capnp::test::TestHandle::Client&& value);
  inline void setHandle( ::capnproto_test::capnp::test::TestHandle::Client& value);
  inline void adoptHandle(::capnp::Orphan< ::capnproto_test::capnp::test::TestHandle>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestHandle> disownHandle();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetHandleResults::Pipeline {
public:
  typedef GetHandleResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestHandle::Client getHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetNullParams::Reader {
public:
  typedef GetNullParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetNullParams::Builder {
public:
  typedef GetNullParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetNullParams::Pipeline {
public:
  typedef GetNullParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetNullResults::Reader {
public:
  typedef GetNullResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNullCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMoreStuff::Client getNullCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetNullResults::Builder {
public:
  typedef GetNullResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNullCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMoreStuff::Client getNullCap();
  inline void setNullCap( ::capnproto_test::capnp::test::TestMoreStuff::Client&& value);
  inline void setNullCap( ::capnproto_test::capnp::test::TestMoreStuff::Client& value);
  inline void adoptNullCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestMoreStuff>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMoreStuff> disownNullCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetNullResults::Pipeline {
public:
  typedef GetNullResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMoreStuff::Client getNullCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetEnormousStringParams::Reader {
public:
  typedef GetEnormousStringParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetEnormousStringParams::Builder {
public:
  typedef GetEnormousStringParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetEnormousStringParams::Pipeline {
public:
  typedef GetEnormousStringParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::GetEnormousStringResults::Reader {
public:
  typedef GetEnormousStringResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStr() const;
  inline  ::capnp::Text::Reader getStr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::GetEnormousStringResults::Builder {
public:
  typedef GetEnormousStringResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStr();
  inline  ::capnp::Text::Builder getStr();
  inline void setStr( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStr(unsigned int size);
  inline void adoptStr(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::GetEnormousStringResults::Pipeline {
public:
  typedef GetEnormousStringResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::MethodWithNullDefaultParams::Reader {
public:
  typedef MethodWithNullDefaultParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasA() const;
  inline  ::capnp::Text::Reader getA() const;

  inline bool hasB() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getB() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::MethodWithNullDefaultParams::Builder {
public:
  typedef MethodWithNullDefaultParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasA();
  inline  ::capnp::Text::Builder getA();
  inline void setA( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initA(unsigned int size);
  inline void adoptA(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownA();

  inline bool hasB();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getB();
  inline void setB( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setB( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptB(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownB();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::MethodWithNullDefaultParams::Pipeline {
public:
  typedef MethodWithNullDefaultParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getB();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMoreStuff::MethodWithNullDefaultResults::Reader {
public:
  typedef MethodWithNullDefaultResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMoreStuff::MethodWithNullDefaultResults::Builder {
public:
  typedef MethodWithNullDefaultResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMoreStuff::MethodWithNullDefaultResults::Pipeline {
public:
  typedef MethodWithNullDefaultResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestMembrane::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestMembrane Calls;
  typedef TestMembrane Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::MakeThingParams,  ::capnproto_test::capnp::test::TestMembrane::MakeThingResults> makeThingRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::CallPassThroughParams,  ::capnproto_test::capnp::test::TestMembrane::Result> callPassThroughRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::CallInterceptParams,  ::capnproto_test::capnp::test::TestMembrane::Result> callInterceptRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::LoopbackParams,  ::capnproto_test::capnp::test::TestMembrane::LoopbackResults> loopbackRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestMembrane::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestMembrane Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestMembrane::MakeThingParams MakeThingParams;
  typedef  ::capnproto_test::capnp::test::TestMembrane::MakeThingResults MakeThingResults;
  typedef ::capnp::CallContext<MakeThingParams, MakeThingResults> MakeThingContext;
  virtual ::kj::Promise<void> makeThing(MakeThingContext context);
  typedef  ::capnproto_test::capnp::test::TestMembrane::CallPassThroughParams CallPassThroughParams;
  typedef ::capnp::CallContext<CallPassThroughParams,  ::capnproto_test::capnp::test::TestMembrane::Result> CallPassThroughContext;
  virtual ::kj::Promise<void> callPassThrough(CallPassThroughContext context);
  typedef  ::capnproto_test::capnp::test::TestMembrane::CallInterceptParams CallInterceptParams;
  typedef ::capnp::CallContext<CallInterceptParams,  ::capnproto_test::capnp::test::TestMembrane::Result> CallInterceptContext;
  virtual ::kj::Promise<void> callIntercept(CallInterceptContext context);
  typedef  ::capnproto_test::capnp::test::TestMembrane::LoopbackParams LoopbackParams;
  typedef  ::capnproto_test::capnp::test::TestMembrane::LoopbackResults LoopbackResults;
  typedef ::capnp::CallContext<LoopbackParams, LoopbackResults> LoopbackContext;
  virtual ::kj::Promise<void> loopback(LoopbackContext context);

  inline  ::capnproto_test::capnp::test::TestMembrane::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestMembrane>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestMembrane::Thing::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Thing Calls;
  typedef Thing Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::Thing::PassThroughParams,  ::capnproto_test::capnp::test::TestMembrane::Result> passThroughRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestMembrane::Thing::InterceptParams,  ::capnproto_test::capnp::test::TestMembrane::Result> interceptRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestMembrane::Thing::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Thing Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestMembrane::Thing::PassThroughParams PassThroughParams;
  typedef ::capnp::CallContext<PassThroughParams,  ::capnproto_test::capnp::test::TestMembrane::Result> PassThroughContext;
  virtual ::kj::Promise<void> passThrough(PassThroughContext context);
  typedef  ::capnproto_test::capnp::test::TestMembrane::Thing::InterceptParams InterceptParams;
  typedef ::capnp::CallContext<InterceptParams,  ::capnproto_test::capnp::test::TestMembrane::Result> InterceptContext;
  virtual ::kj::Promise<void> intercept(InterceptContext context);

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestMembrane::Thing>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestMembrane::Thing::PassThroughParams::Reader {
public:
  typedef PassThroughParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::Thing::PassThroughParams::Builder {
public:
  typedef PassThroughParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::Thing::PassThroughParams::Pipeline {
public:
  typedef PassThroughParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::Thing::InterceptParams::Reader {
public:
  typedef InterceptParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::Thing::InterceptParams::Builder {
public:
  typedef InterceptParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::Thing::InterceptParams::Pipeline {
public:
  typedef InterceptParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::Result::Reader {
public:
  typedef Result Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::Result::Builder {
public:
  typedef Result Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::Result::Pipeline {
public:
  typedef Result Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::MakeThingParams::Reader {
public:
  typedef MakeThingParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::MakeThingParams::Builder {
public:
  typedef MakeThingParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::MakeThingParams::Pipeline {
public:
  typedef MakeThingParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::MakeThingResults::Reader {
public:
  typedef MakeThingResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasThing() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::MakeThingResults::Builder {
public:
  typedef MakeThingResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasThing();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptThing(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownThing();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::MakeThingResults::Pipeline {
public:
  typedef MakeThingResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::CallPassThroughParams::Reader {
public:
  typedef CallPassThroughParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasThing() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing() const;
#endif  // !CAPNP_LITE

  inline bool getTailCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::CallPassThroughParams::Builder {
public:
  typedef CallPassThroughParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasThing();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptThing(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownThing();
#endif  // !CAPNP_LITE

  inline bool getTailCall();
  inline void setTailCall(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::CallPassThroughParams::Pipeline {
public:
  typedef CallPassThroughParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::CallInterceptParams::Reader {
public:
  typedef CallInterceptParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasThing() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing() const;
#endif  // !CAPNP_LITE

  inline bool getTailCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::CallInterceptParams::Builder {
public:
  typedef CallInterceptParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasThing();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptThing(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownThing();
#endif  // !CAPNP_LITE

  inline bool getTailCall();
  inline void setTailCall(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::CallInterceptParams::Pipeline {
public:
  typedef CallInterceptParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::LoopbackParams::Reader {
public:
  typedef LoopbackParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasThing() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::LoopbackParams::Builder {
public:
  typedef LoopbackParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasThing();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptThing(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownThing();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::LoopbackParams::Pipeline {
public:
  typedef LoopbackParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestMembrane::LoopbackResults::Reader {
public:
  typedef LoopbackResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasThing() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestMembrane::LoopbackResults::Builder {
public:
  typedef LoopbackResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasThing();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptThing(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownThing();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestMembrane::LoopbackResults::Pipeline {
public:
  typedef LoopbackResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getThing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestContainMembrane::Reader {
public:
  typedef TestContainMembrane Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getCap() const;
#endif  // !CAPNP_LITE

  inline bool hasList() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Reader getList() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestContainMembrane::Builder {
public:
  typedef TestContainMembrane Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> disownCap();
#endif  // !CAPNP_LITE

  inline bool hasList();
#if !CAPNP_LITE
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Builder getList();
  inline void setList( ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Builder initList(unsigned int size);
  inline void adoptList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>> disownList();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestContainMembrane::Pipeline {
public:
  typedef TestContainMembrane Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestTransferCap::Reader {
public:
  typedef TestTransferCap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasList() const;
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Reader getList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestTransferCap::Builder {
public:
  typedef TestTransferCap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasList();
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Builder getList();
  inline void setList( ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Reader value);
  inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Builder initList(unsigned int size);
  inline void adoptList(::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>> disownList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestTransferCap::Pipeline {
public:
  typedef TestTransferCap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestTransferCap::Element::Reader {
public:
  typedef Element Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestTransferCap::Element::Builder {
public:
  typedef Element Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client&& value);
  inline void setCap( ::capnproto_test::capnp::test::TestInterface::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestTransferCap::Element::Pipeline {
public:
  typedef Element Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestInterface::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TestKeywordMethods::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestKeywordMethods Calls;
  typedef TestKeywordMethods Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::TestKeywordMethods::DeleteParams,  ::capnproto_test::capnp::test::TestKeywordMethods::DeleteResults> deleteRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestKeywordMethods::ClassParams,  ::capnproto_test::capnp::test::TestKeywordMethods::ClassResults> classRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestKeywordMethods::VoidParams,  ::capnproto_test::capnp::test::TestKeywordMethods::VoidResults> voidRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::capnproto_test::capnp::test::TestKeywordMethods::ReturnParams,  ::capnproto_test::capnp::test::TestKeywordMethods::ReturnResults> returnRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TestKeywordMethods::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestKeywordMethods Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::DeleteParams DeleteParams;
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::DeleteResults DeleteResults;
  typedef ::capnp::CallContext<DeleteParams, DeleteResults> DeleteContext;
  virtual ::kj::Promise<void> delete_(DeleteContext context);
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::ClassParams ClassParams;
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::ClassResults ClassResults;
  typedef ::capnp::CallContext<ClassParams, ClassResults> ClassContext;
  virtual ::kj::Promise<void> class_(ClassContext context);
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::VoidParams VoidParams;
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::VoidResults VoidResults;
  typedef ::capnp::CallContext<VoidParams, VoidResults> VoidContext;
  virtual ::kj::Promise<void> void_(VoidContext context);
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::ReturnParams ReturnParams;
  typedef  ::capnproto_test::capnp::test::TestKeywordMethods::ReturnResults ReturnResults;
  typedef ::capnp::CallContext<ReturnParams, ReturnResults> ReturnContext;
  virtual ::kj::Promise<void> return_(ReturnContext context);

  inline  ::capnproto_test::capnp::test::TestKeywordMethods::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestKeywordMethods>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::DeleteParams::Reader {
public:
  typedef DeleteParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::DeleteParams::Builder {
public:
  typedef DeleteParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::DeleteParams::Pipeline {
public:
  typedef DeleteParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::DeleteResults::Reader {
public:
  typedef DeleteResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::DeleteResults::Builder {
public:
  typedef DeleteResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::DeleteResults::Pipeline {
public:
  typedef DeleteResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::ClassParams::Reader {
public:
  typedef ClassParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::ClassParams::Builder {
public:
  typedef ClassParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::ClassParams::Pipeline {
public:
  typedef ClassParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::ClassResults::Reader {
public:
  typedef ClassResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::ClassResults::Builder {
public:
  typedef ClassResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::ClassResults::Pipeline {
public:
  typedef ClassResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::VoidParams::Reader {
public:
  typedef VoidParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::VoidParams::Builder {
public:
  typedef VoidParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::VoidParams::Pipeline {
public:
  typedef VoidParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::VoidResults::Reader {
public:
  typedef VoidResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::VoidResults::Builder {
public:
  typedef VoidResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::VoidResults::Pipeline {
public:
  typedef VoidResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::ReturnParams::Reader {
public:
  typedef ReturnParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::ReturnParams::Builder {
public:
  typedef ReturnParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::ReturnParams::Pipeline {
public:
  typedef ReturnParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestKeywordMethods::ReturnResults::Reader {
public:
  typedef ReturnResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestKeywordMethods::ReturnResults::Builder {
public:
  typedef ReturnResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestKeywordMethods::ReturnResults::Pipeline {
public:
  typedef ReturnResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TestAuthenticatedBootstrap Calls;
  typedef TestAuthenticatedBootstrap Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename VatId2 = ::capnp::AnyPointer>
  typename TestAuthenticatedBootstrap<VatId2>::Client asGeneric() {
    return castAs<TestAuthenticatedBootstrap<VatId2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams, typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults>) getCallerIdRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TestAuthenticatedBootstrap Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams GetCallerIdParams;
  typedef typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults GetCallerIdResults;
  typedef ::capnp::CallContext<GetCallerIdParams, GetCallerIdResults> GetCallerIdContext;
  virtual ::kj::Promise<void> getCallerId(GetCallerIdContext context);

  inline typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::Reader {
public:
  typedef GetCallerIdParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename VatId2 = ::capnp::AnyPointer>
  typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdParams::Reader asTestAuthenticatedBootstrapGeneric() {
    return typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::Builder {
public:
  typedef GetCallerIdParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename VatId2 = ::capnp::AnyPointer>
  typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdParams::Builder asTestAuthenticatedBootstrapGeneric() {
    return typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::Pipeline {
public:
  typedef GetCallerIdParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Reader {
public:
  typedef GetCallerIdResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename VatId2 = ::capnp::AnyPointer>
  typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdResults::Reader asTestAuthenticatedBootstrapGeneric() {
    return typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdResults::Reader(_reader);
  }

  inline bool hasCaller() const;
  inline  ::capnp::ReaderFor<VatId> getCaller() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder {
public:
  typedef GetCallerIdResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename VatId2 = ::capnp::AnyPointer>
  typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdResults::Builder asTestAuthenticatedBootstrapGeneric() {
    return typename TestAuthenticatedBootstrap<VatId2>::GetCallerIdResults::Builder(_builder);
  }

  inline bool hasCaller();
  inline  ::capnp::BuilderFor<VatId> getCaller();
  inline void setCaller( ::capnp::ReaderFor<VatId> value);
  inline  ::capnp::BuilderFor<VatId> initCaller();
  inline  ::capnp::BuilderFor<VatId> initCaller(unsigned int size);
  inline void adoptCaller(::capnp::Orphan<VatId>&& value);
  inline ::capnp::Orphan<VatId> disownCaller();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename VatId>
class TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Pipeline {
public:
  typedef GetCallerIdResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<VatId> getCaller();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestSturdyRef::Reader {
public:
  typedef TestSturdyRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHostId() const;
  inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Reader getHostId() const;

  inline bool hasObjectId() const;
  inline ::capnp::AnyPointer::Reader getObjectId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestSturdyRef::Builder {
public:
  typedef TestSturdyRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHostId();
  inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Builder getHostId();
  inline void setHostId( ::capnproto_test::capnp::test::TestSturdyRefHostId::Reader value);
  inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Builder initHostId();
  inline void adoptHostId(::capnp::Orphan< ::capnproto_test::capnp::test::TestSturdyRefHostId>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestSturdyRefHostId> disownHostId();

  inline bool hasObjectId();
  inline ::capnp::AnyPointer::Builder getObjectId();
  inline ::capnp::AnyPointer::Builder initObjectId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestSturdyRef::Pipeline {
public:
  typedef TestSturdyRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Pipeline getHostId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestSturdyRefHostId::Reader {
public:
  typedef TestSturdyRefHostId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHost() const;
  inline  ::capnp::Text::Reader getHost() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestSturdyRefHostId::Builder {
public:
  typedef TestSturdyRefHostId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHost();
  inline  ::capnp::Text::Builder getHost();
  inline void setHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHost(unsigned int size);
  inline void adoptHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHost();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestSturdyRefHostId::Pipeline {
public:
  typedef TestSturdyRefHostId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestSturdyRefObjectId::Reader {
public:
  typedef TestSturdyRefObjectId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag getTag() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestSturdyRefObjectId::Builder {
public:
  typedef TestSturdyRefObjectId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag getTag();
  inline void setTag( ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestSturdyRefObjectId::Pipeline {
public:
  typedef TestSturdyRefObjectId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestProvisionId::Reader {
public:
  typedef TestProvisionId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestProvisionId::Builder {
public:
  typedef TestProvisionId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestProvisionId::Pipeline {
public:
  typedef TestProvisionId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestRecipientId::Reader {
public:
  typedef TestRecipientId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestRecipientId::Builder {
public:
  typedef TestRecipientId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestRecipientId::Pipeline {
public:
  typedef TestRecipientId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestThirdPartyCapId::Reader {
public:
  typedef TestThirdPartyCapId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestThirdPartyCapId::Builder {
public:
  typedef TestThirdPartyCapId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestThirdPartyCapId::Pipeline {
public:
  typedef TestThirdPartyCapId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TestJoinResult::Reader {
public:
  typedef TestJoinResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TestJoinResult::Builder {
public:
  typedef TestJoinResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TestJoinResult::Pipeline {
public:
  typedef TestJoinResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RenamedStruct::Reader {
public:
  typedef RenamedStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isGoodFieldName() const;
  inline bool getGoodFieldName() const;

  inline bool isBar() const;
  inline  ::int8_t getBar() const;

  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum getAnotherGoodFieldName() const;

  inline typename RenamedUnion::Reader getRenamedUnion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedStruct::Builder {
public:
  typedef RenamedStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isGoodFieldName();
  inline bool getGoodFieldName();
  inline void setGoodFieldName(bool value);

  inline bool isBar();
  inline  ::int8_t getBar();
  inline void setBar( ::int8_t value);

  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum getAnotherGoodFieldName();
  inline void setAnotherGoodFieldName( ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum value);

  inline typename RenamedUnion::Builder getRenamedUnion();
  inline typename RenamedUnion::Builder initRenamedUnion();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedStruct::Pipeline {
public:
  typedef RenamedStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename RenamedUnion::Pipeline getRenamedUnion();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RenamedStruct::RenamedNestedStruct::Reader {
public:
  typedef RenamedNestedStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getGoodNestedFieldName() const;

  inline bool hasAnotherGoodNestedFieldName() const;
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader getAnotherGoodNestedFieldName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedStruct::RenamedNestedStruct::Builder {
public:
  typedef RenamedNestedStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getGoodNestedFieldName();
  inline void setGoodNestedFieldName(bool value);

  inline bool hasAnotherGoodNestedFieldName();
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder getAnotherGoodNestedFieldName();
  inline void setAnotherGoodNestedFieldName( ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader value);
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder initAnotherGoodNestedFieldName();
  inline void adoptAnotherGoodNestedFieldName(::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct> disownAnotherGoodNestedFieldName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedStruct::RenamedNestedStruct::Pipeline {
public:
  typedef RenamedNestedStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Pipeline getAnotherGoodNestedFieldName();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RenamedStruct::RenamedUnion::Reader {
public:
  typedef RenamedUnion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isRenamedGroup() const;
  inline typename RenamedGroup::Reader getRenamedGroup() const;

  inline bool isQux() const;
  inline bool hasQux() const;
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader getQux() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedStruct::RenamedUnion::Builder {
public:
  typedef RenamedUnion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isRenamedGroup();
  inline typename RenamedGroup::Builder getRenamedGroup();
  inline typename RenamedGroup::Builder initRenamedGroup();

  inline bool isQux();
  inline bool hasQux();
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder getQux();
  inline void setQux( ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader value);
  inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder initQux();
  inline void adoptQux(::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>&& value);
  inline ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct> disownQux();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedStruct::RenamedUnion::Pipeline {
public:
  typedef RenamedUnion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RenamedStruct::RenamedUnion::RenamedGroup::Reader {
public:
  typedef RenamedGroup Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getFoo() const;

  inline  ::capnp::Void getBar() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedStruct::RenamedUnion::RenamedGroup::Builder {
public:
  typedef RenamedGroup Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getFoo();
  inline void setFoo( ::capnp::Void value = ::capnp::VOID);

  inline  ::capnp::Void getBar();
  inline void setBar( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedStruct::RenamedUnion::RenamedGroup::Pipeline {
public:
  typedef RenamedGroup Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class RenamedInterface::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef RenamedInterface Calls;
  typedef RenamedInterface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::capnproto_test::capnp::test::RenamedInterface::RenamedMethodParams,  ::capnproto_test::capnp::test::RenamedInterface::RenamedMethodResults> renamedMethodRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class RenamedInterface::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef RenamedInterface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::capnproto_test::capnp::test::RenamedInterface::RenamedMethodParams RenamedMethodParams;
  typedef  ::capnproto_test::capnp::test::RenamedInterface::RenamedMethodResults RenamedMethodResults;
  typedef ::capnp::CallContext<RenamedMethodParams, RenamedMethodResults> RenamedMethodContext;
  virtual ::kj::Promise<void> renamedMethod(RenamedMethodContext context);

  inline  ::capnproto_test::capnp::test::RenamedInterface::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::capnproto_test::capnp::test::RenamedInterface>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class RenamedInterface::RenamedMethodParams::Reader {
public:
  typedef RenamedMethodParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRenamedParam() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedInterface::RenamedMethodParams::Builder {
public:
  typedef RenamedMethodParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getRenamedParam();
  inline void setRenamedParam( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedInterface::RenamedMethodParams::Pipeline {
public:
  typedef RenamedMethodParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RenamedInterface::RenamedMethodResults::Reader {
public:
  typedef RenamedMethodResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RenamedInterface::RenamedMethodResults::Builder {
public:
  typedef RenamedMethodResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RenamedInterface::RenamedMethodResults::Pipeline {
public:
  typedef RenamedMethodResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::capnp::Void TestAllTypes::Reader::getVoidField() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestAllTypes::Builder::getVoidField() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setVoidField( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestAllTypes::Reader::getBoolField() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestAllTypes::Builder::getBoolField() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setBoolField(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t TestAllTypes::Reader::getInt8Field() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestAllTypes::Builder::getInt8Field() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setInt8Field( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t TestAllTypes::Reader::getInt16Field() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestAllTypes::Builder::getInt16Field() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setInt16Field( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t TestAllTypes::Reader::getInt32Field() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestAllTypes::Builder::getInt32Field() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setInt32Field( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t TestAllTypes::Reader::getInt64Field() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestAllTypes::Builder::getInt64Field() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setInt64Field( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TestAllTypes::Reader::getUInt8Field() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TestAllTypes::Builder::getUInt8Field() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setUInt8Field( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TestAllTypes::Reader::getUInt16Field() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestAllTypes::Builder::getUInt16Field() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setUInt16Field( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TestAllTypes::Reader::getUInt32Field() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestAllTypes::Builder::getUInt32Field() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setUInt32Field( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TestAllTypes::Reader::getUInt64Field() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestAllTypes::Builder::getUInt64Field() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setUInt64Field( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float TestAllTypes::Reader::getFloat32Field() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float TestAllTypes::Builder::getFloat32Field() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setFloat32Field(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline double TestAllTypes::Reader::getFloat64Field() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline double TestAllTypes::Builder::getFloat64Field() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setFloat64Field(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool TestAllTypes::Reader::hasTextField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasTextField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestAllTypes::Reader::getTextField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestAllTypes::Builder::getTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setTextField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestAllTypes::Builder::initTextField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptTextField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestAllTypes::Builder::disownTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasDataField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasDataField() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader TestAllTypes::Reader::getDataField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder TestAllTypes::Builder::getDataField() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setDataField( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder TestAllTypes::Builder::initDataField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptDataField(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> TestAllTypes::Builder::disownDataField() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasStructField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasStructField() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Reader TestAllTypes::Reader::getStructField() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestAllTypes::Builder::getStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline TestAllTypes::Pipeline::getStructField() {
  return  ::capnproto_test::capnp::test::TestAllTypes::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TestAllTypes::Builder::setStructField( ::capnproto_test::capnp::test::TestAllTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestAllTypes::Builder::initStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::adoptStructField(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> TestAllTypes::Builder::disownStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestEnum TestAllTypes::Reader::getEnumField() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline  ::capnproto_test::capnp::test::TestEnum TestAllTypes::Builder::getEnumField() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setEnumField( ::capnproto_test::capnp::test::TestEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void TestAllTypes::Reader::getInterfaceField() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestAllTypes::Builder::getInterfaceField() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestAllTypes::Builder::setInterfaceField( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestAllTypes::Reader::hasVoidList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasVoidList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Void>::Reader TestAllTypes::Reader::getVoidList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Void>::Builder TestAllTypes::Builder::getVoidList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setVoidList( ::capnp::List< ::capnp::Void>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setVoidList(::kj::ArrayPtr<const  ::capnp::Void> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Void>::Builder TestAllTypes::Builder::initVoidList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptVoidList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> TestAllTypes::Builder::disownVoidList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasBoolList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasBoolList() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool>::Reader TestAllTypes::Reader::getBoolList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List<bool>::Builder TestAllTypes::Builder::getBoolList() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setBoolList( ::capnp::List<bool>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setBoolList(::kj::ArrayPtr<const bool> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool>::Builder TestAllTypes::Builder::initBoolList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptBoolList(
    ::capnp::Orphan< ::capnp::List<bool>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool>> TestAllTypes::Builder::disownBoolList() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasInt8List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasInt8List() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int8_t>::Reader TestAllTypes::Reader::getInt8List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int8_t>::Builder TestAllTypes::Builder::getInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setInt8List( ::capnp::List< ::int8_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setInt8List(::kj::ArrayPtr<const  ::int8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int8_t>::Builder TestAllTypes::Builder::initInt8List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptInt8List(
    ::capnp::Orphan< ::capnp::List< ::int8_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int8_t>> TestAllTypes::Builder::disownInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasInt16List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasInt16List() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int16_t>::Reader TestAllTypes::Reader::getInt16List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int16_t>::Builder TestAllTypes::Builder::getInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setInt16List( ::capnp::List< ::int16_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setInt16List(::kj::ArrayPtr<const  ::int16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int16_t>::Builder TestAllTypes::Builder::initInt16List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptInt16List(
    ::capnp::Orphan< ::capnp::List< ::int16_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int16_t>> TestAllTypes::Builder::disownInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasInt32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasInt32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader TestAllTypes::Reader::getInt32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder TestAllTypes::Builder::getInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setInt32List( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setInt32List(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder TestAllTypes::Builder::initInt32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptInt32List(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> TestAllTypes::Builder::disownInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasInt64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasInt64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t>::Reader TestAllTypes::Reader::getInt64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t>::Builder TestAllTypes::Builder::getInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setInt64List( ::capnp::List< ::int64_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setInt64List(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t>::Builder TestAllTypes::Builder::initInt64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptInt64List(
    ::capnp::Orphan< ::capnp::List< ::int64_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t>> TestAllTypes::Builder::disownInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasUInt8List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasUInt8List() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t>::Reader TestAllTypes::Reader::getUInt8List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t>::Builder TestAllTypes::Builder::getUInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setUInt8List( ::capnp::List< ::uint8_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setUInt8List(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t>::Builder TestAllTypes::Builder::initUInt8List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptUInt8List(
    ::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> TestAllTypes::Builder::disownUInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasUInt16List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasUInt16List() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint16_t>::Reader TestAllTypes::Reader::getUInt16List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint16_t>::Builder TestAllTypes::Builder::getUInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setUInt16List( ::capnp::List< ::uint16_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setUInt16List(::kj::ArrayPtr<const  ::uint16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint16_t>::Builder TestAllTypes::Builder::initUInt16List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptUInt16List(
    ::capnp::Orphan< ::capnp::List< ::uint16_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint16_t>> TestAllTypes::Builder::disownUInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasUInt32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasUInt32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader TestAllTypes::Reader::getUInt32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder TestAllTypes::Builder::getUInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setUInt32List( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setUInt32List(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder TestAllTypes::Builder::initUInt32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptUInt32List(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> TestAllTypes::Builder::disownUInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasUInt64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasUInt64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t>::Reader TestAllTypes::Reader::getUInt64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t>::Builder TestAllTypes::Builder::getUInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setUInt64List( ::capnp::List< ::uint64_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setUInt64List(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t>::Builder TestAllTypes::Builder::initUInt64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptUInt64List(
    ::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> TestAllTypes::Builder::disownUInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasFloat32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasFloat32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float>::Reader TestAllTypes::Reader::getFloat32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float>::Builder TestAllTypes::Builder::getFloat32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setFloat32List( ::capnp::List<float>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setFloat32List(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float>::Builder TestAllTypes::Builder::initFloat32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptFloat32List(
    ::capnp::Orphan< ::capnp::List<float>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float>> TestAllTypes::Builder::disownFloat32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasFloat64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasFloat64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double>::Reader TestAllTypes::Reader::getFloat64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double>::Builder TestAllTypes::Builder::getFloat64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setFloat64List( ::capnp::List<double>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setFloat64List(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double>::Builder TestAllTypes::Builder::initFloat64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::init(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptFloat64List(
    ::capnp::Orphan< ::capnp::List<double>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::adopt(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double>> TestAllTypes::Builder::disownFloat64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::disown(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasTextList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasTextList() {
  return !_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader TestAllTypes::Reader::getTextList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text>::Builder TestAllTypes::Builder::getTextList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setTextList( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setTextList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder TestAllTypes::Builder::initTextList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptTextList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> TestAllTypes::Builder::disownTextList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasDataList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasDataList() {
  return !_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data>::Reader TestAllTypes::Reader::getDataList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data>::Builder TestAllTypes::Builder::getDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setDataList( ::capnp::List< ::capnp::Data>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data>::Builder TestAllTypes::Builder::initDataList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::init(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptDataList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::adopt(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> TestAllTypes::Builder::disownDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::disown(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasStructList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasStructList() {
  return !_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader TestAllTypes::Reader::getStructList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::get(_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder TestAllTypes::Builder::getStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::get(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::set(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder TestAllTypes::Builder::initStructList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::init(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptStructList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::adopt(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>> TestAllTypes::Builder::disownStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::disown(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasEnumList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasEnumList() {
  return !_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader TestAllTypes::Reader::getEnumList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::get(_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder TestAllTypes::Builder::getEnumList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::get(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setEnumList( ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setEnumList(::kj::ArrayPtr<const  ::capnproto_test::capnp::test::TestEnum> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder TestAllTypes::Builder::initEnumList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::init(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptEnumList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::adopt(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>> TestAllTypes::Builder::disownEnumList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::disown(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}

inline bool TestAllTypes::Reader::hasInterfaceList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline bool TestAllTypes::Builder::hasInterfaceList() {
  return !_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Void>::Reader TestAllTypes::Reader::getInterfaceList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Void>::Builder TestAllTypes::Builder::getInterfaceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline void TestAllTypes::Builder::setInterfaceList( ::capnp::List< ::capnp::Void>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), value);
}
inline void TestAllTypes::Builder::setInterfaceList(::kj::ArrayPtr<const  ::capnp::Void> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Void>::Builder TestAllTypes::Builder::initInterfaceList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::init(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), size);
}
inline void TestAllTypes::Builder::adoptInterfaceList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::adopt(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> TestAllTypes::Builder::disownInterfaceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::disown(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}

inline  ::capnp::Void TestDefaults::Reader::getVoidField() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestDefaults::Builder::getVoidField() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestDefaults::Builder::setVoidField( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestDefaults::Reader::getBoolField() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

inline bool TestDefaults::Builder::getBoolField() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
inline void TestDefaults::Builder::setBoolField(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

inline  ::int8_t TestDefaults::Reader::getInt8Field() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -123);
}

inline  ::int8_t TestDefaults::Builder::getInt8Field() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -123);
}
inline void TestDefaults::Builder::setInt8Field( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, -123);
}

inline  ::int16_t TestDefaults::Reader::getInt16Field() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -12345);
}

inline  ::int16_t TestDefaults::Builder::getInt16Field() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -12345);
}
inline void TestDefaults::Builder::setInt16Field( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, -12345);
}

inline  ::int32_t TestDefaults::Reader::getInt32Field() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -12345678);
}

inline  ::int32_t TestDefaults::Builder::getInt32Field() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -12345678);
}
inline void TestDefaults::Builder::setInt32Field( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, -12345678);
}

inline  ::int64_t TestDefaults::Reader::getInt64Field() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -123456789012345ll);
}

inline  ::int64_t TestDefaults::Builder::getInt64Field() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, -123456789012345ll);
}
inline void TestDefaults::Builder::setInt64Field( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, -123456789012345ll);
}

inline  ::uint8_t TestDefaults::Reader::getUInt8Field() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 234u);
}

inline  ::uint8_t TestDefaults::Builder::getUInt8Field() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 234u);
}
inline void TestDefaults::Builder::setUInt8Field( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value, 234u);
}

inline  ::uint16_t TestDefaults::Reader::getUInt16Field() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, 45678u);
}

inline  ::uint16_t TestDefaults::Builder::getUInt16Field() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, 45678u);
}
inline void TestDefaults::Builder::setUInt16Field( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value, 45678u);
}

inline  ::uint32_t TestDefaults::Reader::getUInt32Field() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, 3456789012u);
}

inline  ::uint32_t TestDefaults::Builder::getUInt32Field() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, 3456789012u);
}
inline void TestDefaults::Builder::setUInt32Field( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value, 3456789012u);
}

inline  ::uint64_t TestDefaults::Reader::getUInt64Field() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 12345678901234567890ull);
}

inline  ::uint64_t TestDefaults::Builder::getUInt64Field() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 12345678901234567890ull);
}
inline void TestDefaults::Builder::setUInt64Field( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value, 12345678901234567890ull);
}

inline float TestDefaults::Reader::getFloat32Field() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, 1150963712u);
}

inline float TestDefaults::Builder::getFloat32Field() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, 1150963712u);
}
inline void TestDefaults::Builder::setFloat32Field(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value, 1150963712u);
}

inline double TestDefaults::Reader::getFloat64Field() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, 14534676766106106624ull);
}

inline double TestDefaults::Builder::getFloat64Field() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, 14534676766106106624ull);
}
inline void TestDefaults::Builder::setFloat64Field(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value, 14534676766106106624ull);
}

inline bool TestDefaults::Reader::hasTextField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasTextField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestDefaults::Reader::getTextField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 377, 3);
}
inline  ::capnp::Text::Builder TestDefaults::Builder::getTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 377, 3);
}
inline void TestDefaults::Builder::setTextField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestDefaults::Builder::initTextField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptTextField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestDefaults::Builder::disownTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasDataField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasDataField() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader TestDefaults::Reader::getDataField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 387, 3);
}
inline  ::capnp::Data::Builder TestDefaults::Builder::getDataField() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 387, 3);
}
inline void TestDefaults::Builder::setDataField( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder TestDefaults::Builder::initDataField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptDataField(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> TestDefaults::Builder::disownDataField() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasStructField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasStructField() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Reader TestDefaults::Reader::getStructField() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 396);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestDefaults::Builder::getStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 396);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline TestDefaults::Pipeline::getStructField() {
  return  ::capnproto_test::capnp::test::TestAllTypes::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TestDefaults::Builder::setStructField( ::capnproto_test::capnp::test::TestAllTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestDefaults::Builder::initStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestDefaults::Builder::adoptStructField(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> TestDefaults::Builder::disownStructField() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestEnum TestDefaults::Reader::getEnumField() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, 5u);
}

inline  ::capnproto_test::capnp::test::TestEnum TestDefaults::Builder::getEnumField() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, 5u);
}
inline void TestDefaults::Builder::setEnumField( ::capnproto_test::capnp::test::TestEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestEnum>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value, 5u);
}

inline  ::capnp::Void TestDefaults::Reader::getInterfaceField() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestDefaults::Builder::getInterfaceField() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestDefaults::Builder::setInterfaceField( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestDefaults::Reader::hasVoidList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasVoidList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Void>::Reader TestDefaults::Reader::getVoidList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 634);
}
inline  ::capnp::List< ::capnp::Void>::Builder TestDefaults::Builder::getVoidList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 634);
}
inline void TestDefaults::Builder::setVoidList( ::capnp::List< ::capnp::Void>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setVoidList(::kj::ArrayPtr<const  ::capnp::Void> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Void>::Builder TestDefaults::Builder::initVoidList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptVoidList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> TestDefaults::Builder::disownVoidList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasBoolList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasBoolList() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool>::Reader TestDefaults::Reader::getBoolList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 647);
}
inline  ::capnp::List<bool>::Builder TestDefaults::Builder::getBoolList() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 647);
}
inline void TestDefaults::Builder::setBoolList( ::capnp::List<bool>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setBoolList(::kj::ArrayPtr<const bool> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool>::Builder TestDefaults::Builder::initBoolList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptBoolList(
    ::capnp::Orphan< ::capnp::List<bool>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool>> TestDefaults::Builder::disownBoolList() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasInt8List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasInt8List() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int8_t>::Reader TestDefaults::Reader::getInt8List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 661);
}
inline  ::capnp::List< ::int8_t>::Builder TestDefaults::Builder::getInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 661);
}
inline void TestDefaults::Builder::setInt8List( ::capnp::List< ::int8_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setInt8List(::kj::ArrayPtr<const  ::int8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int8_t>::Builder TestDefaults::Builder::initInt8List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptInt8List(
    ::capnp::Orphan< ::capnp::List< ::int8_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int8_t>> TestDefaults::Builder::disownInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasInt16List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasInt16List() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int16_t>::Reader TestDefaults::Reader::getInt16List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 675);
}
inline  ::capnp::List< ::int16_t>::Builder TestDefaults::Builder::getInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 675);
}
inline void TestDefaults::Builder::setInt16List( ::capnp::List< ::int16_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setInt16List(::kj::ArrayPtr<const  ::int16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int16_t>::Builder TestDefaults::Builder::initInt16List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptInt16List(
    ::capnp::Orphan< ::capnp::List< ::int16_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int16_t>> TestDefaults::Builder::disownInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasInt32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasInt32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader TestDefaults::Reader::getInt32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 689);
}
inline  ::capnp::List< ::int32_t>::Builder TestDefaults::Builder::getInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 689);
}
inline void TestDefaults::Builder::setInt32List( ::capnp::List< ::int32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setInt32List(::kj::ArrayPtr<const  ::int32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder TestDefaults::Builder::initInt32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptInt32List(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> TestDefaults::Builder::disownInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasInt64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasInt64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t>::Reader TestDefaults::Reader::getInt64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 703);
}
inline  ::capnp::List< ::int64_t>::Builder TestDefaults::Builder::getInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 703);
}
inline void TestDefaults::Builder::setInt64List( ::capnp::List< ::int64_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setInt64List(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t>::Builder TestDefaults::Builder::initInt64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptInt64List(
    ::capnp::Orphan< ::capnp::List< ::int64_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t>> TestDefaults::Builder::disownInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasUInt8List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasUInt8List() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t>::Reader TestDefaults::Reader::getUInt8List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 718);
}
inline  ::capnp::List< ::uint8_t>::Builder TestDefaults::Builder::getUInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 718);
}
inline void TestDefaults::Builder::setUInt8List( ::capnp::List< ::uint8_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setUInt8List(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t>::Builder TestDefaults::Builder::initUInt8List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptUInt8List(
    ::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> TestDefaults::Builder::disownUInt8List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasUInt16List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasUInt16List() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint16_t>::Reader TestDefaults::Reader::getUInt16List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 732);
}
inline  ::capnp::List< ::uint16_t>::Builder TestDefaults::Builder::getUInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 732);
}
inline void TestDefaults::Builder::setUInt16List( ::capnp::List< ::uint16_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setUInt16List(::kj::ArrayPtr<const  ::uint16_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint16_t>::Builder TestDefaults::Builder::initUInt16List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptUInt16List(
    ::capnp::Orphan< ::capnp::List< ::uint16_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint16_t>> TestDefaults::Builder::disownUInt16List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasUInt32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasUInt32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader TestDefaults::Reader::getUInt32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 746);
}
inline  ::capnp::List< ::uint32_t>::Builder TestDefaults::Builder::getUInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 746);
}
inline void TestDefaults::Builder::setUInt32List( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setUInt32List(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder TestDefaults::Builder::initUInt32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptUInt32List(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> TestDefaults::Builder::disownUInt32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasUInt64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasUInt64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t>::Reader TestDefaults::Reader::getUInt64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 760);
}
inline  ::capnp::List< ::uint64_t>::Builder TestDefaults::Builder::getUInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 760);
}
inline void TestDefaults::Builder::setUInt64List( ::capnp::List< ::uint64_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setUInt64List(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t>::Builder TestDefaults::Builder::initUInt64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptUInt64List(
    ::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> TestDefaults::Builder::disownUInt64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasFloat32List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasFloat32List() {
  return !_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float>::Reader TestDefaults::Reader::getFloat32List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 774);
}
inline  ::capnp::List<float>::Builder TestDefaults::Builder::getFloat32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 774);
}
inline void TestDefaults::Builder::setFloat32List( ::capnp::List<float>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setFloat32List(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float>::Builder TestDefaults::Builder::initFloat32List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptFloat32List(
    ::capnp::Orphan< ::capnp::List<float>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float>> TestDefaults::Builder::disownFloat32List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasFloat64List() const {
  return !_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasFloat64List() {
  return !_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double>::Reader TestDefaults::Reader::getFloat64List() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 789);
}
inline  ::capnp::List<double>::Builder TestDefaults::Builder::getFloat64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 789);
}
inline void TestDefaults::Builder::setFloat64List( ::capnp::List<double>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setFloat64List(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double>::Builder TestDefaults::Builder::initFloat64List(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::init(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptFloat64List(
    ::capnp::Orphan< ::capnp::List<double>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::adopt(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double>> TestDefaults::Builder::disownFloat64List() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::disown(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasTextList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasTextList() {
  return !_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader TestDefaults::Reader::getTextList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 806);
}
inline  ::capnp::List< ::capnp::Text>::Builder TestDefaults::Builder::getTextList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 806);
}
inline void TestDefaults::Builder::setTextList( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setTextList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder TestDefaults::Builder::initTextList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptTextList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> TestDefaults::Builder::disownTextList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasDataList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasDataList() {
  return !_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data>::Reader TestDefaults::Reader::getDataList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 825);
}
inline  ::capnp::List< ::capnp::Data>::Builder TestDefaults::Builder::getDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::get(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 825);
}
inline void TestDefaults::Builder::setDataList( ::capnp::List< ::capnp::Data>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setDataList(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data>::Builder TestDefaults::Builder::initDataList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::init(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptDataList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::adopt(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data>> TestDefaults::Builder::disownDataList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data>>::disown(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasStructList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasStructList() {
  return !_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader TestDefaults::Reader::getStructList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::get(_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 845);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder TestDefaults::Builder::getStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::get(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 845);
}
inline void TestDefaults::Builder::setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::set(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Builder TestDefaults::Builder::initStructList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::init(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptStructList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::adopt(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>> TestDefaults::Builder::disownStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::disown(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasEnumList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasEnumList() {
  return !_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader TestDefaults::Reader::getEnumList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::get(_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 943);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder TestDefaults::Builder::getEnumList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::get(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eb3f9ebe98c73cb6 + 943);
}
inline void TestDefaults::Builder::setEnumList( ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setEnumList(::kj::ArrayPtr<const  ::capnproto_test::capnp::test::TestEnum> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestEnum>::Builder TestDefaults::Builder::initEnumList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::init(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptEnumList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::adopt(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>> TestDefaults::Builder::disownEnumList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestEnum>>::disown(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}

inline bool TestDefaults::Reader::hasInterfaceList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline bool TestDefaults::Builder::hasInterfaceList() {
  return !_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Void>::Reader TestDefaults::Reader::getInterfaceList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Void>::Builder TestDefaults::Builder::getInterfaceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::get(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline void TestDefaults::Builder::setInterfaceList( ::capnp::List< ::capnp::Void>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), value);
}
inline void TestDefaults::Builder::setInterfaceList(::kj::ArrayPtr<const  ::capnp::Void> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Void>::Builder TestDefaults::Builder::initInterfaceList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::init(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), size);
}
inline void TestDefaults::Builder::adoptInterfaceList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Void>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::adopt(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Void>> TestDefaults::Builder::disownInterfaceList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Void>>::disown(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}

inline bool TestAnyPointer::Reader::hasAnyPointerField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyPointer::Builder::hasAnyPointerField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader TestAnyPointer::Reader::getAnyPointerField() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointer::Builder::getAnyPointerField() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointer::Builder::initAnyPointerField() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool TestAnyOthers::Reader::hasAnyStructField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyOthers::Builder::hasAnyStructField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyStruct::Reader TestAnyOthers::Reader::getAnyStructField() const {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyStruct::Builder TestAnyOthers::Builder::getAnyStructField() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::AnyStruct::Pipeline TestAnyOthers::Pipeline::getAnyStructField() {
  return  ::capnp::AnyStruct::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestAnyOthers::Builder::setAnyStructField( ::capnp::AnyStruct::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> TestAnyOthers::Builder::initAnyStructFieldAs() {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::STRUCT,
                "anyStructField must be a struct");
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestAnyOthers::Builder::adoptAnyStructField(
    ::capnp::Orphan< ::capnp::AnyStruct>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyStruct> TestAnyOthers::Builder::disownAnyStructField() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestAnyOthers::Reader::hasAnyListField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyOthers::Builder::hasAnyListField() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyList::Reader TestAnyOthers::Reader::getAnyListField() const {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyList::Builder TestAnyOthers::Builder::getAnyListField() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestAnyOthers::Builder::setAnyListField( ::capnp::AnyList::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyList>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> TestAnyOthers::Builder::initAnyListFieldAs(unsigned int size) {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::LIST,
                "anyListField must be a list");
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestAnyOthers::Builder::adoptAnyListField(
    ::capnp::Orphan< ::capnp::AnyList>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyList>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyList> TestAnyOthers::Builder::disownAnyListField() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestAnyOthers::Reader::hasCapabilityField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyOthers::Builder::hasCapabilityField() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client TestAnyOthers::Reader::getCapabilityField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestAnyOthers::Builder::getCapabilityField() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestAnyOthers::Pipeline::getCapabilityField() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(2).asCap());
}
inline void TestAnyOthers::Builder::setCapabilityField( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestAnyOthers::Builder::setCapabilityField( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), cap);
}
inline void TestAnyOthers::Builder::adoptCapabilityField(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> TestAnyOthers::Builder::disownCapabilityField() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestOutOfOrder::Reader::hasQux() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasQux() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getQux() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getQux() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setQux( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initQux(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptQux(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownQux() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasGrault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasGrault() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getGrault() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setGrault( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initGrault(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptGrault(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getBar() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getBar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setBar( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptBar(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownBar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getFoo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setFoo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptFoo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasCorge() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasCorge() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getCorge() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getCorge() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setCorge( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initCorge(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptCorge(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownCorge() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasWaldo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasWaldo() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getWaldo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setWaldo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initWaldo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptWaldo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasQuux() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasQuux() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getQuux() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getQuux() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setQuux( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initQuux(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptQuux(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownQuux() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasGarply() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasGarply() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getGarply() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setGarply( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initGarply(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptGarply(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool TestOutOfOrder::Reader::hasBaz() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TestOutOfOrder::Builder::hasBaz() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOutOfOrder::Reader::getBaz() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::getBaz() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void TestOutOfOrder::Builder::setBaz( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOutOfOrder::Builder::initBaz(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void TestOutOfOrder::Builder::adoptBaz(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOutOfOrder::Builder::disownBaz() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline typename TestUnion::Union0::Reader TestUnion::Reader::getUnion0() const {
  return typename TestUnion::Union0::Reader(_reader);
}
inline typename TestUnion::Union0::Builder TestUnion::Builder::getUnion0() {
  return typename TestUnion::Union0::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestUnion::Union0::Pipeline TestUnion::Pipeline::getUnion0() {
  return typename TestUnion::Union0::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestUnion::Union0::Builder TestUnion::Builder::initUnion0() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename TestUnion::Union0::Builder(_builder);
}
inline typename TestUnion::Union1::Reader TestUnion::Reader::getUnion1() const {
  return typename TestUnion::Union1::Reader(_reader);
}
inline typename TestUnion::Union1::Builder TestUnion::Builder::getUnion1() {
  return typename TestUnion::Union1::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestUnion::Union1::Pipeline TestUnion::Pipeline::getUnion1() {
  return typename TestUnion::Union1::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestUnion::Union1::Builder TestUnion::Builder::initUnion1() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<129>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<17>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<9>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename TestUnion::Union1::Builder(_builder);
}
inline typename TestUnion::Union2::Reader TestUnion::Reader::getUnion2() const {
  return typename TestUnion::Union2::Reader(_reader);
}
inline typename TestUnion::Union2::Builder TestUnion::Builder::getUnion2() {
  return typename TestUnion::Union2::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestUnion::Union2::Pipeline TestUnion::Pipeline::getUnion2() {
  return typename TestUnion::Union2::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestUnion::Union2::Builder TestUnion::Builder::initUnion2() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<256>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<33>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<18>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<10>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  return typename TestUnion::Union2::Builder(_builder);
}
inline typename TestUnion::Union3::Reader TestUnion::Reader::getUnion3() const {
  return typename TestUnion::Union3::Reader(_reader);
}
inline typename TestUnion::Union3::Builder TestUnion::Builder::getUnion3() {
  return typename TestUnion::Union3::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestUnion::Union3::Pipeline TestUnion::Pipeline::getUnion3() {
  return typename TestUnion::Union3::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestUnion::Union3::Builder TestUnion::Builder::initUnion3() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<257>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<34>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<19>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<11>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<7>() * ::capnp::ELEMENTS, 0);
  return typename TestUnion::Union3::Builder(_builder);
}
inline bool TestUnion::Reader::getBit0() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit0() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit0(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit2() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<130>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit2() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<130>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit2(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<130>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit3() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<131>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit3() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<131>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit3(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<131>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit4() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<132>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit4() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<132>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit4(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<132>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit5() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<133>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit5() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<133>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit5(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<133>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit6() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<134>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit6() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<134>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit6(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<134>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Reader::getBit7() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<135>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Builder::getBit7() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<135>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setBit7(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<135>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TestUnion::Reader::getByte0() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TestUnion::Builder::getByte0() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Builder::setByte0( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<35>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestUnion::Union0::Which TestUnion::Union0::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnion::Union0::Which TestUnion::Union0::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union0::Reader::isU0f0s0() const {
  return which() == TestUnion::Union0::U0F0S0;
}
inline bool TestUnion::Union0::Builder::isU0f0s0() {
  return which() == TestUnion::Union0::U0F0S0;
}
inline  ::capnp::Void TestUnion::Union0::Reader::getU0f0s0() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S0),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestUnion::Union0::Builder::getU0f0s0() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S0),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s0( ::capnp::Void value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S0);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0s1() const {
  return which() == TestUnion::Union0::U0F0S1;
}
inline bool TestUnion::Union0::Builder::isU0f0s1() {
  return which() == TestUnion::Union0::U0F0S1;
}
inline bool TestUnion::Union0::Reader::getU0f0s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union0::Builder::getU0f0s1() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s1(bool value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0s8() const {
  return which() == TestUnion::Union0::U0F0S8;
}
inline bool TestUnion::Union0::Builder::isU0f0s8() {
  return which() == TestUnion::Union0::U0F0S8;
}
inline  ::int8_t TestUnion::Union0::Reader::getU0f0s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union0::Builder::getU0f0s8() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0s16() const {
  return which() == TestUnion::Union0::U0F0S16;
}
inline bool TestUnion::Union0::Builder::isU0f0s16() {
  return which() == TestUnion::Union0::U0F0S16;
}
inline  ::int16_t TestUnion::Union0::Reader::getU0f0s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union0::Builder::getU0f0s16() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0s32() const {
  return which() == TestUnion::Union0::U0F0S32;
}
inline bool TestUnion::Union0::Builder::isU0f0s32() {
  return which() == TestUnion::Union0::U0F0S32;
}
inline  ::int32_t TestUnion::Union0::Reader::getU0f0s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union0::Builder::getU0f0s32() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0s64() const {
  return which() == TestUnion::Union0::U0F0S64;
}
inline bool TestUnion::Union0::Builder::isU0f0s64() {
  return which() == TestUnion::Union0::U0F0S64;
}
inline  ::int64_t TestUnion::Union0::Reader::getU0f0s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union0::Builder::getU0f0s64() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f0s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f0sp() const {
  return which() == TestUnion::Union0::U0F0SP;
}
inline bool TestUnion::Union0::Builder::isU0f0sp() {
  return which() == TestUnion::Union0::U0F0SP;
}
inline bool TestUnion::Union0::Reader::hasU0f0sp() const {
  if (which() != TestUnion::Union0::U0F0SP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnion::Union0::Builder::hasU0f0sp() {
  if (which() != TestUnion::Union0::U0F0SP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnion::Union0::Reader::getU0f0sp() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnion::Union0::Builder::getU0f0sp() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestUnion::Union0::Builder::setU0f0sp( ::capnp::Text::Reader value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnion::Union0::Builder::initU0f0sp(unsigned int size) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0SP);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestUnion::Union0::Builder::adoptU0f0sp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F0SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnion::Union0::Builder::disownU0f0sp() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestUnion::Union0::Reader::isU0f1s0() const {
  return which() == TestUnion::Union0::U0F1S0;
}
inline bool TestUnion::Union0::Builder::isU0f1s0() {
  return which() == TestUnion::Union0::U0F1S0;
}
inline  ::capnp::Void TestUnion::Union0::Reader::getU0f1s0() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S0),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestUnion::Union0::Builder::getU0f1s0() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S0),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s0( ::capnp::Void value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S0);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1s1() const {
  return which() == TestUnion::Union0::U0F1S1;
}
inline bool TestUnion::Union0::Builder::isU0f1s1() {
  return which() == TestUnion::Union0::U0F1S1;
}
inline bool TestUnion::Union0::Reader::getU0f1s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union0::Builder::getU0f1s1() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s1(bool value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1s8() const {
  return which() == TestUnion::Union0::U0F1S8;
}
inline bool TestUnion::Union0::Builder::isU0f1s8() {
  return which() == TestUnion::Union0::U0F1S8;
}
inline  ::int8_t TestUnion::Union0::Reader::getU0f1s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union0::Builder::getU0f1s8() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1s16() const {
  return which() == TestUnion::Union0::U0F1S16;
}
inline bool TestUnion::Union0::Builder::isU0f1s16() {
  return which() == TestUnion::Union0::U0F1S16;
}
inline  ::int16_t TestUnion::Union0::Reader::getU0f1s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union0::Builder::getU0f1s16() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1s32() const {
  return which() == TestUnion::Union0::U0F1S32;
}
inline bool TestUnion::Union0::Builder::isU0f1s32() {
  return which() == TestUnion::Union0::U0F1S32;
}
inline  ::int32_t TestUnion::Union0::Reader::getU0f1s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union0::Builder::getU0f1s32() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1s64() const {
  return which() == TestUnion::Union0::U0F1S64;
}
inline bool TestUnion::Union0::Builder::isU0f1s64() {
  return which() == TestUnion::Union0::U0F1S64;
}
inline  ::int64_t TestUnion::Union0::Reader::getU0f1s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union0::Builder::getU0f1s64() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union0::Builder::setU0f1s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union0::Reader::isU0f1sp() const {
  return which() == TestUnion::Union0::U0F1SP;
}
inline bool TestUnion::Union0::Builder::isU0f1sp() {
  return which() == TestUnion::Union0::U0F1SP;
}
inline bool TestUnion::Union0::Reader::hasU0f1sp() const {
  if (which() != TestUnion::Union0::U0F1SP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnion::Union0::Builder::hasU0f1sp() {
  if (which() != TestUnion::Union0::U0F1SP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnion::Union0::Reader::getU0f1sp() const {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnion::Union0::Builder::getU0f1sp() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestUnion::Union0::Builder::setU0f1sp( ::capnp::Text::Reader value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnion::Union0::Builder::initU0f1sp(unsigned int size) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1SP);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestUnion::Union0::Builder::adoptU0f1sp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestUnion::Union0::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestUnion::Union0::U0F1SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnion::Union0::Builder::disownU0f1sp() {
  KJ_IREQUIRE((which() == TestUnion::Union0::U0F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestUnion::Union1::Which TestUnion::Union1::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnion::Union1::Which TestUnion::Union1::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union1::Reader::isU1f0s0() const {
  return which() == TestUnion::Union1::U1F0S0;
}
inline bool TestUnion::Union1::Builder::isU1f0s0() {
  return which() == TestUnion::Union1::U1F0S0;
}
inline  ::capnp::Void TestUnion::Union1::Reader::getU1f0s0() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S0),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestUnion::Union1::Builder::getU1f0s0() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S0),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s0( ::capnp::Void value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S0);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0s1() const {
  return which() == TestUnion::Union1::U1F0S1;
}
inline bool TestUnion::Union1::Builder::isU1f0s1() {
  return which() == TestUnion::Union1::U1F0S1;
}
inline bool TestUnion::Union1::Reader::getU1f0s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union1::Builder::getU1f0s1() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s1(bool value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f1s1() const {
  return which() == TestUnion::Union1::U1F1S1;
}
inline bool TestUnion::Union1::Builder::isU1f1s1() {
  return which() == TestUnion::Union1::U1F1S1;
}
inline bool TestUnion::Union1::Reader::getU1f1s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union1::Builder::getU1f1s1() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f1s1(bool value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0s8() const {
  return which() == TestUnion::Union1::U1F0S8;
}
inline bool TestUnion::Union1::Builder::isU1f0s8() {
  return which() == TestUnion::Union1::U1F0S8;
}
inline  ::int8_t TestUnion::Union1::Reader::getU1f0s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union1::Builder::getU1f0s8() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f1s8() const {
  return which() == TestUnion::Union1::U1F1S8;
}
inline bool TestUnion::Union1::Builder::isU1f1s8() {
  return which() == TestUnion::Union1::U1F1S8;
}
inline  ::int8_t TestUnion::Union1::Reader::getU1f1s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union1::Builder::getU1f1s8() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f1s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0s16() const {
  return which() == TestUnion::Union1::U1F0S16;
}
inline bool TestUnion::Union1::Builder::isU1f0s16() {
  return which() == TestUnion::Union1::U1F0S16;
}
inline  ::int16_t TestUnion::Union1::Reader::getU1f0s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union1::Builder::getU1f0s16() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f1s16() const {
  return which() == TestUnion::Union1::U1F1S16;
}
inline bool TestUnion::Union1::Builder::isU1f1s16() {
  return which() == TestUnion::Union1::U1F1S16;
}
inline  ::int16_t TestUnion::Union1::Reader::getU1f1s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union1::Builder::getU1f1s16() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f1s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0s32() const {
  return which() == TestUnion::Union1::U1F0S32;
}
inline bool TestUnion::Union1::Builder::isU1f0s32() {
  return which() == TestUnion::Union1::U1F0S32;
}
inline  ::int32_t TestUnion::Union1::Reader::getU1f0s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union1::Builder::getU1f0s32() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f1s32() const {
  return which() == TestUnion::Union1::U1F1S32;
}
inline bool TestUnion::Union1::Builder::isU1f1s32() {
  return which() == TestUnion::Union1::U1F1S32;
}
inline  ::int32_t TestUnion::Union1::Reader::getU1f1s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union1::Builder::getU1f1s32() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f1s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0s64() const {
  return which() == TestUnion::Union1::U1F0S64;
}
inline bool TestUnion::Union1::Builder::isU1f0s64() {
  return which() == TestUnion::Union1::U1F0S64;
}
inline  ::int64_t TestUnion::Union1::Reader::getU1f0s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union1::Builder::getU1f0s64() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f0s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f1s64() const {
  return which() == TestUnion::Union1::U1F1S64;
}
inline bool TestUnion::Union1::Builder::isU1f1s64() {
  return which() == TestUnion::Union1::U1F1S64;
}
inline  ::int64_t TestUnion::Union1::Reader::getU1f1s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union1::Builder::getU1f1s64() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f1s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f0sp() const {
  return which() == TestUnion::Union1::U1F0SP;
}
inline bool TestUnion::Union1::Builder::isU1f0sp() {
  return which() == TestUnion::Union1::U1F0SP;
}
inline bool TestUnion::Union1::Reader::hasU1f0sp() const {
  if (which() != TestUnion::Union1::U1F0SP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnion::Union1::Builder::hasU1f0sp() {
  if (which() != TestUnion::Union1::U1F0SP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnion::Union1::Reader::getU1f0sp() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::getU1f0sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUnion::Union1::Builder::setU1f0sp( ::capnp::Text::Reader value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::initU1f0sp(unsigned int size) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0SP);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestUnion::Union1::Builder::adoptU1f0sp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F0SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnion::Union1::Builder::disownU1f0sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F0SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestUnion::Union1::Reader::isU1f1sp() const {
  return which() == TestUnion::Union1::U1F1SP;
}
inline bool TestUnion::Union1::Builder::isU1f1sp() {
  return which() == TestUnion::Union1::U1F1SP;
}
inline bool TestUnion::Union1::Reader::hasU1f1sp() const {
  if (which() != TestUnion::Union1::U1F1SP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnion::Union1::Builder::hasU1f1sp() {
  if (which() != TestUnion::Union1::U1F1SP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnion::Union1::Reader::getU1f1sp() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::getU1f1sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUnion::Union1::Builder::setU1f1sp( ::capnp::Text::Reader value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::initU1f1sp(unsigned int size) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1SP);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestUnion::Union1::Builder::adoptU1f1sp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F1SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnion::Union1::Builder::disownU1f1sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F1SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestUnion::Union1::Reader::isU1f2s0() const {
  return which() == TestUnion::Union1::U1F2S0;
}
inline bool TestUnion::Union1::Builder::isU1f2s0() {
  return which() == TestUnion::Union1::U1F2S0;
}
inline  ::capnp::Void TestUnion::Union1::Reader::getU1f2s0() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S0),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestUnion::Union1::Builder::getU1f2s0() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S0),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s0( ::capnp::Void value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S0);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2s1() const {
  return which() == TestUnion::Union1::U1F2S1;
}
inline bool TestUnion::Union1::Builder::isU1f2s1() {
  return which() == TestUnion::Union1::U1F2S1;
}
inline bool TestUnion::Union1::Reader::getU1f2s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union1::Builder::getU1f2s1() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s1(bool value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<129>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2s8() const {
  return which() == TestUnion::Union1::U1F2S8;
}
inline bool TestUnion::Union1::Builder::isU1f2s8() {
  return which() == TestUnion::Union1::U1F2S8;
}
inline  ::int8_t TestUnion::Union1::Reader::getU1f2s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union1::Builder::getU1f2s8() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2s16() const {
  return which() == TestUnion::Union1::U1F2S16;
}
inline bool TestUnion::Union1::Builder::isU1f2s16() {
  return which() == TestUnion::Union1::U1F2S16;
}
inline  ::int16_t TestUnion::Union1::Reader::getU1f2s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union1::Builder::getU1f2s16() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2s32() const {
  return which() == TestUnion::Union1::U1F2S32;
}
inline bool TestUnion::Union1::Builder::isU1f2s32() {
  return which() == TestUnion::Union1::U1F2S32;
}
inline  ::int32_t TestUnion::Union1::Reader::getU1f2s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union1::Builder::getU1f2s32() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2s64() const {
  return which() == TestUnion::Union1::U1F2S64;
}
inline bool TestUnion::Union1::Builder::isU1f2s64() {
  return which() == TestUnion::Union1::U1F2S64;
}
inline  ::int64_t TestUnion::Union1::Reader::getU1f2s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union1::Builder::getU1f2s64() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union1::Builder::setU1f2s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union1::Reader::isU1f2sp() const {
  return which() == TestUnion::Union1::U1F2SP;
}
inline bool TestUnion::Union1::Builder::isU1f2sp() {
  return which() == TestUnion::Union1::U1F2SP;
}
inline bool TestUnion::Union1::Reader::hasU1f2sp() const {
  if (which() != TestUnion::Union1::U1F2SP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnion::Union1::Builder::hasU1f2sp() {
  if (which() != TestUnion::Union1::U1F2SP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnion::Union1::Reader::getU1f2sp() const {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::getU1f2sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUnion::Union1::Builder::setU1f2sp( ::capnp::Text::Reader value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnion::Union1::Builder::initU1f2sp(unsigned int size) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2SP);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestUnion::Union1::Builder::adoptU1f2sp(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestUnion::Union1::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, TestUnion::Union1::U1F2SP);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnion::Union1::Builder::disownU1f2sp() {
  KJ_IREQUIRE((which() == TestUnion::Union1::U1F2SP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestUnion::Union2::Which TestUnion::Union2::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnion::Union2::Which TestUnion::Union2::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union2::Reader::isU2f0s1() const {
  return which() == TestUnion::Union2::U2F0S1;
}
inline bool TestUnion::Union2::Builder::isU2f0s1() {
  return which() == TestUnion::Union2::U2F0S1;
}
inline bool TestUnion::Union2::Reader::getU2f0s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union2::Builder::getU2f0s1() {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union2::Builder::setU2f0s1(bool value) {
  _builder.setDataField<TestUnion::Union2::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnion::Union2::U2F0S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union2::Reader::isU2f0s8() const {
  return which() == TestUnion::Union2::U2F0S8;
}
inline bool TestUnion::Union2::Builder::isU2f0s8() {
  return which() == TestUnion::Union2::U2F0S8;
}
inline  ::int8_t TestUnion::Union2::Reader::getU2f0s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union2::Builder::getU2f0s8() {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union2::Builder::setU2f0s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union2::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnion::Union2::U2F0S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union2::Reader::isU2f0s16() const {
  return which() == TestUnion::Union2::U2F0S16;
}
inline bool TestUnion::Union2::Builder::isU2f0s16() {
  return which() == TestUnion::Union2::U2F0S16;
}
inline  ::int16_t TestUnion::Union2::Reader::getU2f0s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union2::Builder::getU2f0s16() {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union2::Builder::setU2f0s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union2::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnion::Union2::U2F0S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<18>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union2::Reader::isU2f0s32() const {
  return which() == TestUnion::Union2::U2F0S32;
}
inline bool TestUnion::Union2::Builder::isU2f0s32() {
  return which() == TestUnion::Union2::U2F0S32;
}
inline  ::int32_t TestUnion::Union2::Reader::getU2f0s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union2::Builder::getU2f0s32() {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union2::Builder::setU2f0s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union2::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnion::Union2::U2F0S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<10>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union2::Reader::isU2f0s64() const {
  return which() == TestUnion::Union2::U2F0S64;
}
inline bool TestUnion::Union2::Builder::isU2f0s64() {
  return which() == TestUnion::Union2::U2F0S64;
}
inline  ::int64_t TestUnion::Union2::Reader::getU2f0s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union2::Builder::getU2f0s64() {
  KJ_IREQUIRE((which() == TestUnion::Union2::U2F0S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union2::Builder::setU2f0s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union2::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnion::Union2::U2F0S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestUnion::Union3::Which TestUnion::Union3::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnion::Union3::Which TestUnion::Union3::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union3::Reader::isU3f0s1() const {
  return which() == TestUnion::Union3::U3F0S1;
}
inline bool TestUnion::Union3::Builder::isU3f0s1() {
  return which() == TestUnion::Union3::U3F0S1;
}
inline bool TestUnion::Union3::Reader::getU3f0s1() const {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS);
}

inline bool TestUnion::Union3::Builder::getU3f0s1() {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union3::Builder::setU3f0s1(bool value) {
  _builder.setDataField<TestUnion::Union3::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestUnion::Union3::U3F0S1);
  _builder.setDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union3::Reader::isU3f0s8() const {
  return which() == TestUnion::Union3::U3F0S8;
}
inline bool TestUnion::Union3::Builder::isU3f0s8() {
  return which() == TestUnion::Union3::U3F0S8;
}
inline  ::int8_t TestUnion::Union3::Reader::getU3f0s8() const {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}

inline  ::int8_t TestUnion::Union3::Builder::getU3f0s8() {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union3::Builder::setU3f0s8( ::int8_t value) {
  _builder.setDataField<TestUnion::Union3::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestUnion::Union3::U3F0S8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union3::Reader::isU3f0s16() const {
  return which() == TestUnion::Union3::U3F0S16;
}
inline bool TestUnion::Union3::Builder::isU3f0s16() {
  return which() == TestUnion::Union3::U3F0S16;
}
inline  ::int16_t TestUnion::Union3::Reader::getU3f0s16() const {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestUnion::Union3::Builder::getU3f0s16() {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union3::Builder::setU3f0s16( ::int16_t value) {
  _builder.setDataField<TestUnion::Union3::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestUnion::Union3::U3F0S16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<19>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union3::Reader::isU3f0s32() const {
  return which() == TestUnion::Union3::U3F0S32;
}
inline bool TestUnion::Union3::Builder::isU3f0s32() {
  return which() == TestUnion::Union3::U3F0S32;
}
inline  ::int32_t TestUnion::Union3::Reader::getU3f0s32() const {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnion::Union3::Builder::getU3f0s32() {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union3::Builder::setU3f0s32( ::int32_t value) {
  _builder.setDataField<TestUnion::Union3::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestUnion::Union3::U3F0S32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<11>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnion::Union3::Reader::isU3f0s64() const {
  return which() == TestUnion::Union3::U3F0S64;
}
inline bool TestUnion::Union3::Builder::isU3f0s64() {
  return which() == TestUnion::Union3::U3F0S64;
}
inline  ::int64_t TestUnion::Union3::Reader::getU3f0s64() const {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestUnion::Union3::Builder::getU3f0s64() {
  KJ_IREQUIRE((which() == TestUnion::Union3::U3F0S64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void TestUnion::Union3::Builder::setU3f0s64( ::int64_t value) {
  _builder.setDataField<TestUnion::Union3::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestUnion::Union3::U3F0S64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Which TestUnnamedUnion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Which TestUnnamedUnion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool TestUnnamedUnion::Reader::hasBefore() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnnamedUnion::Builder::hasBefore() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnnamedUnion::Reader::getBefore() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnnamedUnion::Builder::getBefore() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestUnnamedUnion::Builder::setBefore( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnnamedUnion::Builder::initBefore(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestUnnamedUnion::Builder::adoptBefore(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnnamedUnion::Builder::disownBefore() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestUnnamedUnion::Reader::isFoo() const {
  return which() == TestUnnamedUnion::FOO;
}
inline bool TestUnnamedUnion::Builder::isFoo() {
  return which() == TestUnnamedUnion::FOO;
}
inline  ::uint16_t TestUnnamedUnion::Reader::getFoo() const {
  KJ_IREQUIRE((which() == TestUnnamedUnion::FOO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestUnnamedUnion::Builder::getFoo() {
  KJ_IREQUIRE((which() == TestUnnamedUnion::FOO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnnamedUnion::Builder::setFoo( ::uint16_t value) {
  _builder.setDataField<TestUnnamedUnion::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnnamedUnion::FOO);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TestUnnamedUnion::Reader::getMiddle() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestUnnamedUnion::Builder::getMiddle() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestUnnamedUnion::Builder::setMiddle( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnnamedUnion::Reader::isBar() const {
  return which() == TestUnnamedUnion::BAR;
}
inline bool TestUnnamedUnion::Builder::isBar() {
  return which() == TestUnnamedUnion::BAR;
}
inline  ::uint32_t TestUnnamedUnion::Reader::getBar() const {
  KJ_IREQUIRE((which() == TestUnnamedUnion::BAR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestUnnamedUnion::Builder::getBar() {
  KJ_IREQUIRE((which() == TestUnnamedUnion::BAR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestUnnamedUnion::Builder::setBar( ::uint32_t value) {
  _builder.setDataField<TestUnnamedUnion::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnnamedUnion::BAR);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnnamedUnion::Reader::hasAfter() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnnamedUnion::Builder::hasAfter() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUnnamedUnion::Reader::getAfter() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestUnnamedUnion::Builder::getAfter() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUnnamedUnion::Builder::setAfter( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUnnamedUnion::Builder::initAfter(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestUnnamedUnion::Builder::adoptAfter(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUnnamedUnion::Builder::disownAfter() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline typename TestUnionInUnion::Outer::Reader TestUnionInUnion::Reader::getOuter() const {
  return typename TestUnionInUnion::Outer::Reader(_reader);
}
inline typename TestUnionInUnion::Outer::Builder TestUnionInUnion::Builder::getOuter() {
  return typename TestUnionInUnion::Outer::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestUnionInUnion::Outer::Pipeline TestUnionInUnion::Pipeline::getOuter() {
  return typename TestUnionInUnion::Outer::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestUnionInUnion::Outer::Builder TestUnionInUnion::Builder::initOuter() {
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  return typename TestUnionInUnion::Outer::Builder(_builder);
}
inline  ::capnproto_test::capnp::test::TestUnionInUnion::Outer::Which TestUnionInUnion::Outer::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnionInUnion::Outer::Which TestUnionInUnion::Outer::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool TestUnionInUnion::Outer::Reader::isInner() const {
  return which() == TestUnionInUnion::Outer::INNER;
}
inline bool TestUnionInUnion::Outer::Builder::isInner() {
  return which() == TestUnionInUnion::Outer::INNER;
}
inline typename TestUnionInUnion::Outer::Inner::Reader TestUnionInUnion::Outer::Reader::getInner() const {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::INNER),
              "Must check which() before get()ing a union member.");
  return typename TestUnionInUnion::Outer::Inner::Reader(_reader);
}
inline typename TestUnionInUnion::Outer::Inner::Builder TestUnionInUnion::Outer::Builder::getInner() {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::INNER),
              "Must check which() before get()ing a union member.");
  return typename TestUnionInUnion::Outer::Inner::Builder(_builder);
}
inline typename TestUnionInUnion::Outer::Inner::Builder TestUnionInUnion::Outer::Builder::initInner() {
  _builder.setDataField<TestUnionInUnion::Outer::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TestUnionInUnion::Outer::INNER);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename TestUnionInUnion::Outer::Inner::Builder(_builder);
}
inline bool TestUnionInUnion::Outer::Reader::isBaz() const {
  return which() == TestUnionInUnion::Outer::BAZ;
}
inline bool TestUnionInUnion::Outer::Builder::isBaz() {
  return which() == TestUnionInUnion::Outer::BAZ;
}
inline  ::int32_t TestUnionInUnion::Outer::Reader::getBaz() const {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::BAZ),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnionInUnion::Outer::Builder::getBaz() {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::BAZ),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnionInUnion::Outer::Builder::setBaz( ::int32_t value) {
  _builder.setDataField<TestUnionInUnion::Outer::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TestUnionInUnion::Outer::BAZ);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestUnionInUnion::Outer::Inner::Which TestUnionInUnion::Outer::Inner::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestUnionInUnion::Outer::Inner::Which TestUnionInUnion::Outer::Inner::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool TestUnionInUnion::Outer::Inner::Reader::isFoo() const {
  return which() == TestUnionInUnion::Outer::Inner::FOO;
}
inline bool TestUnionInUnion::Outer::Inner::Builder::isFoo() {
  return which() == TestUnionInUnion::Outer::Inner::FOO;
}
inline  ::int32_t TestUnionInUnion::Outer::Inner::Reader::getFoo() const {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::Inner::FOO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnionInUnion::Outer::Inner::Builder::getFoo() {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::Inner::FOO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnionInUnion::Outer::Inner::Builder::setFoo( ::int32_t value) {
  _builder.setDataField<TestUnionInUnion::Outer::Inner::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnionInUnion::Outer::Inner::FOO);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestUnionInUnion::Outer::Inner::Reader::isBar() const {
  return which() == TestUnionInUnion::Outer::Inner::BAR;
}
inline bool TestUnionInUnion::Outer::Inner::Builder::isBar() {
  return which() == TestUnionInUnion::Outer::Inner::BAR;
}
inline  ::int32_t TestUnionInUnion::Outer::Inner::Reader::getBar() const {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::Inner::BAR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestUnionInUnion::Outer::Inner::Builder::getBar() {
  KJ_IREQUIRE((which() == TestUnionInUnion::Outer::Inner::BAR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestUnionInUnion::Outer::Inner::Builder::setBar( ::int32_t value) {
  _builder.setDataField<TestUnionInUnion::Outer::Inner::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestUnionInUnion::Outer::Inner::BAR);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline typename TestGroups::Groups::Reader TestGroups::Reader::getGroups() const {
  return typename TestGroups::Groups::Reader(_reader);
}
inline typename TestGroups::Groups::Builder TestGroups::Builder::getGroups() {
  return typename TestGroups::Groups::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestGroups::Groups::Pipeline TestGroups::Pipeline::getGroups() {
  return typename TestGroups::Groups::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestGroups::Groups::Builder TestGroups::Builder::initGroups() {
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename TestGroups::Groups::Builder(_builder);
}
inline  ::capnproto_test::capnp::test::TestGroups::Groups::Which TestGroups::Groups::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestGroups::Groups::Which TestGroups::Groups::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool TestGroups::Groups::Reader::isFoo() const {
  return which() == TestGroups::Groups::FOO;
}
inline bool TestGroups::Groups::Builder::isFoo() {
  return which() == TestGroups::Groups::FOO;
}
inline typename TestGroups::Groups::Foo::Reader TestGroups::Groups::Reader::getFoo() const {
  KJ_IREQUIRE((which() == TestGroups::Groups::FOO),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Foo::Reader(_reader);
}
inline typename TestGroups::Groups::Foo::Builder TestGroups::Groups::Builder::getFoo() {
  KJ_IREQUIRE((which() == TestGroups::Groups::FOO),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Foo::Builder(_builder);
}
inline typename TestGroups::Groups::Foo::Builder TestGroups::Groups::Builder::initFoo() {
  _builder.setDataField<TestGroups::Groups::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestGroups::Groups::FOO);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename TestGroups::Groups::Foo::Builder(_builder);
}
inline bool TestGroups::Groups::Reader::isBaz() const {
  return which() == TestGroups::Groups::BAZ;
}
inline bool TestGroups::Groups::Builder::isBaz() {
  return which() == TestGroups::Groups::BAZ;
}
inline typename TestGroups::Groups::Baz::Reader TestGroups::Groups::Reader::getBaz() const {
  KJ_IREQUIRE((which() == TestGroups::Groups::BAZ),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Baz::Reader(_reader);
}
inline typename TestGroups::Groups::Baz::Builder TestGroups::Groups::Builder::getBaz() {
  KJ_IREQUIRE((which() == TestGroups::Groups::BAZ),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Baz::Builder(_builder);
}
inline typename TestGroups::Groups::Baz::Builder TestGroups::Groups::Builder::initBaz() {
  _builder.setDataField<TestGroups::Groups::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestGroups::Groups::BAZ);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename TestGroups::Groups::Baz::Builder(_builder);
}
inline bool TestGroups::Groups::Reader::isBar() const {
  return which() == TestGroups::Groups::BAR;
}
inline bool TestGroups::Groups::Builder::isBar() {
  return which() == TestGroups::Groups::BAR;
}
inline typename TestGroups::Groups::Bar::Reader TestGroups::Groups::Reader::getBar() const {
  KJ_IREQUIRE((which() == TestGroups::Groups::BAR),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Bar::Reader(_reader);
}
inline typename TestGroups::Groups::Bar::Builder TestGroups::Groups::Builder::getBar() {
  KJ_IREQUIRE((which() == TestGroups::Groups::BAR),
              "Must check which() before get()ing a union member.");
  return typename TestGroups::Groups::Bar::Builder(_builder);
}
inline typename TestGroups::Groups::Bar::Builder TestGroups::Groups::Builder::initBar() {
  _builder.setDataField<TestGroups::Groups::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, TestGroups::Groups::BAR);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename TestGroups::Groups::Bar::Builder(_builder);
}
inline  ::int32_t TestGroups::Groups::Foo::Reader::getCorge() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestGroups::Groups::Foo::Builder::getCorge() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestGroups::Groups::Foo::Builder::setCorge( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t TestGroups::Groups::Foo::Reader::getGrault() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestGroups::Groups::Foo::Builder::getGrault() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestGroups::Groups::Foo::Builder::setGrault( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TestGroups::Groups::Foo::Reader::hasGarply() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestGroups::Groups::Foo::Builder::hasGarply() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestGroups::Groups::Foo::Reader::getGarply() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestGroups::Groups::Foo::Builder::getGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestGroups::Groups::Foo::Builder::setGarply( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestGroups::Groups::Foo::Builder::initGarply(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestGroups::Groups::Foo::Builder::adoptGarply(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestGroups::Groups::Foo::Builder::disownGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t TestGroups::Groups::Baz::Reader::getCorge() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestGroups::Groups::Baz::Builder::getCorge() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestGroups::Groups::Baz::Builder::setCorge( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestGroups::Groups::Baz::Reader::hasGrault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestGroups::Groups::Baz::Builder::hasGrault() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestGroups::Groups::Baz::Reader::getGrault() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestGroups::Groups::Baz::Builder::getGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestGroups::Groups::Baz::Builder::setGrault( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestGroups::Groups::Baz::Builder::initGrault(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestGroups::Groups::Baz::Builder::adoptGrault(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestGroups::Groups::Baz::Builder::disownGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestGroups::Groups::Baz::Reader::hasGarply() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestGroups::Groups::Baz::Builder::hasGarply() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestGroups::Groups::Baz::Reader::getGarply() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestGroups::Groups::Baz::Builder::getGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestGroups::Groups::Baz::Builder::setGarply( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestGroups::Groups::Baz::Builder::initGarply(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestGroups::Groups::Baz::Builder::adoptGarply(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestGroups::Groups::Baz::Builder::disownGarply() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t TestGroups::Groups::Bar::Reader::getCorge() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestGroups::Groups::Bar::Builder::getCorge() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestGroups::Groups::Bar::Builder::setCorge( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestGroups::Groups::Bar::Reader::hasGrault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestGroups::Groups::Bar::Builder::hasGrault() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestGroups::Groups::Bar::Reader::getGrault() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestGroups::Groups::Bar::Builder::getGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestGroups::Groups::Bar::Builder::setGrault( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestGroups::Groups::Bar::Builder::initGrault(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestGroups::Groups::Bar::Builder::adoptGrault(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestGroups::Groups::Bar::Builder::disownGrault() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int64_t TestGroups::Groups::Bar::Reader::getGarply() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestGroups::Groups::Bar::Builder::getGarply() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestGroups::Groups::Bar::Builder::setGarply( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline typename TestInterleavedGroups::Group1::Reader TestInterleavedGroups::Reader::getGroup1() const {
  return typename TestInterleavedGroups::Group1::Reader(_reader);
}
inline typename TestInterleavedGroups::Group1::Builder TestInterleavedGroups::Builder::getGroup1() {
  return typename TestInterleavedGroups::Group1::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestInterleavedGroups::Group1::Pipeline TestInterleavedGroups::Pipeline::getGroup1() {
  return typename TestInterleavedGroups::Group1::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestInterleavedGroups::Group1::Builder TestInterleavedGroups::Builder::initGroup1() {
  _builder.setDataField< ::uint32_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<12>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<14>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<4>() * ::capnp::POINTERS).clear();
  return typename TestInterleavedGroups::Group1::Builder(_builder);
}
inline typename TestInterleavedGroups::Group2::Reader TestInterleavedGroups::Reader::getGroup2() const {
  return typename TestInterleavedGroups::Group2::Reader(_reader);
}
inline typename TestInterleavedGroups::Group2::Builder TestInterleavedGroups::Builder::getGroup2() {
  return typename TestInterleavedGroups::Group2::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestInterleavedGroups::Group2::Pipeline TestInterleavedGroups::Pipeline::getGroup2() {
  return typename TestInterleavedGroups::Group2::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestInterleavedGroups::Group2::Builder TestInterleavedGroups::Builder::initGroup2() {
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<13>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<15>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<5>() * ::capnp::POINTERS).clear();
  return typename TestInterleavedGroups::Group2::Builder(_builder);
}
inline  ::capnproto_test::capnp::test::TestInterleavedGroups::Group1::Which TestInterleavedGroups::Group1::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestInterleavedGroups::Group1::Which TestInterleavedGroups::Group1::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestInterleavedGroups::Group1::Reader::getFoo() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestInterleavedGroups::Group1::Builder::getFoo() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group1::Builder::setFoo( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TestInterleavedGroups::Group1::Reader::getBar() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestInterleavedGroups::Group1::Builder::getBar() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group1::Builder::setBar( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group1::Reader::isQux() const {
  return which() == TestInterleavedGroups::Group1::QUX;
}
inline bool TestInterleavedGroups::Group1::Builder::isQux() {
  return which() == TestInterleavedGroups::Group1::QUX;
}
inline  ::uint16_t TestInterleavedGroups::Group1::Reader::getQux() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::QUX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestInterleavedGroups::Group1::Builder::getQux() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::QUX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group1::Builder::setQux( ::uint16_t value) {
  _builder.setDataField<TestInterleavedGroups::Group1::Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group1::QUX);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group1::Reader::isCorge() const {
  return which() == TestInterleavedGroups::Group1::CORGE;
}
inline bool TestInterleavedGroups::Group1::Builder::isCorge() {
  return which() == TestInterleavedGroups::Group1::CORGE;
}
inline typename TestInterleavedGroups::Group1::Corge::Reader TestInterleavedGroups::Group1::Reader::getCorge() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::CORGE),
              "Must check which() before get()ing a union member.");
  return typename TestInterleavedGroups::Group1::Corge::Reader(_reader);
}
inline typename TestInterleavedGroups::Group1::Corge::Builder TestInterleavedGroups::Group1::Builder::getCorge() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::CORGE),
              "Must check which() before get()ing a union member.");
  return typename TestInterleavedGroups::Group1::Corge::Builder(_builder);
}
inline typename TestInterleavedGroups::Group1::Corge::Builder TestInterleavedGroups::Group1::Builder::initCorge() {
  _builder.setDataField<TestInterleavedGroups::Group1::Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group1::CORGE);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<12>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<4>() * ::capnp::POINTERS).clear();
  return typename TestInterleavedGroups::Group1::Corge::Builder(_builder);
}
inline bool TestInterleavedGroups::Group1::Reader::hasWaldo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group1::Builder::hasWaldo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group1::Reader::getWaldo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Builder::getWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group1::Builder::setWaldo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Builder::initWaldo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group1::Builder::adoptWaldo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group1::Builder::disownWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestInterleavedGroups::Group1::Reader::isFred() const {
  return which() == TestInterleavedGroups::Group1::FRED;
}
inline bool TestInterleavedGroups::Group1::Builder::isFred() {
  return which() == TestInterleavedGroups::Group1::FRED;
}
inline bool TestInterleavedGroups::Group1::Reader::hasFred() const {
  if (which() != TestInterleavedGroups::Group1::FRED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group1::Builder::hasFred() {
  if (which() != TestInterleavedGroups::Group1::FRED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group1::Reader::getFred() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Builder::getFred() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group1::Builder::setFred( ::capnp::Text::Reader value) {
  _builder.setDataField<TestInterleavedGroups::Group1::Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group1::FRED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Builder::initFred(unsigned int size) {
  _builder.setDataField<TestInterleavedGroups::Group1::Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group1::FRED);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group1::Builder::adoptFred(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestInterleavedGroups::Group1::Which>(
      ::capnp::bounded<14>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group1::FRED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group1::Builder::disownFred() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group1::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t TestInterleavedGroups::Group1::Corge::Reader::getGrault() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestInterleavedGroups::Group1::Corge::Builder::getGrault() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group1::Corge::Builder::setGrault( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TestInterleavedGroups::Group1::Corge::Reader::getGarply() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestInterleavedGroups::Group1::Corge::Builder::getGarply() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group1::Corge::Builder::setGarply( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group1::Corge::Reader::hasPlugh() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group1::Corge::Builder::hasPlugh() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group1::Corge::Reader::getPlugh() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Corge::Builder::getPlugh() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group1::Corge::Builder::setPlugh( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Corge::Builder::initPlugh(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group1::Corge::Builder::adoptPlugh(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group1::Corge::Builder::disownPlugh() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestInterleavedGroups::Group1::Corge::Reader::hasXyzzy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group1::Corge::Builder::hasXyzzy() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group1::Corge::Reader::getXyzzy() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Corge::Builder::getXyzzy() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group1::Corge::Builder::setXyzzy( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group1::Corge::Builder::initXyzzy(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group1::Corge::Builder::adoptXyzzy(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group1::Corge::Builder::disownXyzzy() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestInterleavedGroups::Group2::Which TestInterleavedGroups::Group2::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestInterleavedGroups::Group2::Which TestInterleavedGroups::Group2::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestInterleavedGroups::Group2::Reader::getFoo() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestInterleavedGroups::Group2::Builder::getFoo() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group2::Builder::setFoo( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TestInterleavedGroups::Group2::Reader::getBar() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestInterleavedGroups::Group2::Builder::getBar() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group2::Builder::setBar( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group2::Reader::isQux() const {
  return which() == TestInterleavedGroups::Group2::QUX;
}
inline bool TestInterleavedGroups::Group2::Builder::isQux() {
  return which() == TestInterleavedGroups::Group2::QUX;
}
inline  ::uint16_t TestInterleavedGroups::Group2::Reader::getQux() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::QUX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestInterleavedGroups::Group2::Builder::getQux() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::QUX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group2::Builder::setQux( ::uint16_t value) {
  _builder.setDataField<TestInterleavedGroups::Group2::Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group2::QUX);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group2::Reader::isCorge() const {
  return which() == TestInterleavedGroups::Group2::CORGE;
}
inline bool TestInterleavedGroups::Group2::Builder::isCorge() {
  return which() == TestInterleavedGroups::Group2::CORGE;
}
inline typename TestInterleavedGroups::Group2::Corge::Reader TestInterleavedGroups::Group2::Reader::getCorge() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::CORGE),
              "Must check which() before get()ing a union member.");
  return typename TestInterleavedGroups::Group2::Corge::Reader(_reader);
}
inline typename TestInterleavedGroups::Group2::Corge::Builder TestInterleavedGroups::Group2::Builder::getCorge() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::CORGE),
              "Must check which() before get()ing a union member.");
  return typename TestInterleavedGroups::Group2::Corge::Builder(_builder);
}
inline typename TestInterleavedGroups::Group2::Corge::Builder TestInterleavedGroups::Group2::Builder::initCorge() {
  _builder.setDataField<TestInterleavedGroups::Group2::Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group2::CORGE);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<13>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<5>() * ::capnp::POINTERS).clear();
  return typename TestInterleavedGroups::Group2::Corge::Builder(_builder);
}
inline bool TestInterleavedGroups::Group2::Reader::hasWaldo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group2::Builder::hasWaldo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group2::Reader::getWaldo() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Builder::getWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group2::Builder::setWaldo( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Builder::initWaldo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group2::Builder::adoptWaldo(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group2::Builder::disownWaldo() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestInterleavedGroups::Group2::Reader::isFred() const {
  return which() == TestInterleavedGroups::Group2::FRED;
}
inline bool TestInterleavedGroups::Group2::Builder::isFred() {
  return which() == TestInterleavedGroups::Group2::FRED;
}
inline bool TestInterleavedGroups::Group2::Reader::hasFred() const {
  if (which() != TestInterleavedGroups::Group2::FRED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group2::Builder::hasFred() {
  if (which() != TestInterleavedGroups::Group2::FRED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group2::Reader::getFred() const {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Builder::getFred() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group2::Builder::setFred( ::capnp::Text::Reader value) {
  _builder.setDataField<TestInterleavedGroups::Group2::Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group2::FRED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Builder::initFred(unsigned int size) {
  _builder.setDataField<TestInterleavedGroups::Group2::Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group2::FRED);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group2::Builder::adoptFred(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestInterleavedGroups::Group2::Which>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, TestInterleavedGroups::Group2::FRED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group2::Builder::disownFred() {
  KJ_IREQUIRE((which() == TestInterleavedGroups::Group2::FRED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint64_t TestInterleavedGroups::Group2::Corge::Reader::getGrault() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestInterleavedGroups::Group2::Corge::Builder::getGrault() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group2::Corge::Builder::setGrault( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TestInterleavedGroups::Group2::Corge::Reader::getGarply() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestInterleavedGroups::Group2::Corge::Builder::getGarply() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void TestInterleavedGroups::Group2::Corge::Builder::setGarply( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterleavedGroups::Group2::Corge::Reader::hasPlugh() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group2::Corge::Builder::hasPlugh() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group2::Corge::Reader::getPlugh() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Corge::Builder::getPlugh() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group2::Corge::Builder::setPlugh( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Corge::Builder::initPlugh(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group2::Corge::Builder::adoptPlugh(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group2::Corge::Builder::disownPlugh() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestInterleavedGroups::Group2::Corge::Reader::hasXyzzy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterleavedGroups::Group2::Corge::Builder::hasXyzzy() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterleavedGroups::Group2::Corge::Reader::getXyzzy() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Corge::Builder::getXyzzy() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TestInterleavedGroups::Group2::Corge::Builder::setXyzzy( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterleavedGroups::Group2::Corge::Builder::initXyzzy(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TestInterleavedGroups::Group2::Corge::Builder::adoptXyzzy(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterleavedGroups::Group2::Corge::Builder::disownXyzzy() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestUnionDefaults::Reader::hasS16s8s64s8Set() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnionDefaults::Builder::hasS16s8s64s8Set() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestUnion::Reader TestUnionDefaults::Reader::getS16s8s64s8Set() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 59);
}
inline  ::capnproto_test::capnp::test::TestUnion::Builder TestUnionDefaults::Builder::getS16s8s64s8Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 59);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestUnion::Pipeline TestUnionDefaults::Pipeline::getS16s8s64s8Set() {
  return  ::capnproto_test::capnp::test::TestUnion::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestUnionDefaults::Builder::setS16s8s64s8Set( ::capnproto_test::capnp::test::TestUnion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestUnion::Builder TestUnionDefaults::Builder::initS16s8s64s8Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestUnionDefaults::Builder::adoptS16s8s64s8Set(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion> TestUnionDefaults::Builder::disownS16s8s64s8Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestUnionDefaults::Reader::hasS0sps1s32Set() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnionDefaults::Builder::hasS0sps1s32Set() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestUnion::Reader TestUnionDefaults::Reader::getS0sps1s32Set() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 78);
}
inline  ::capnproto_test::capnp::test::TestUnion::Builder TestUnionDefaults::Builder::getS0sps1s32Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 78);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestUnion::Pipeline TestUnionDefaults::Pipeline::getS0sps1s32Set() {
  return  ::capnproto_test::capnp::test::TestUnion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestUnionDefaults::Builder::setS0sps1s32Set( ::capnproto_test::capnp::test::TestUnion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestUnion::Builder TestUnionDefaults::Builder::initS0sps1s32Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUnionDefaults::Builder::adoptS0sps1s32Set(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnion> TestUnionDefaults::Builder::disownS0sps1s32Set() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestUnionDefaults::Reader::hasUnnamed1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnionDefaults::Builder::hasUnnamed1() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Reader TestUnionDefaults::Reader::getUnnamed1() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 98);
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder TestUnionDefaults::Builder::getUnnamed1() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 98);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline TestUnionDefaults::Pipeline::getUnnamed1() {
  return  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TestUnionDefaults::Builder::setUnnamed1( ::capnproto_test::capnp::test::TestUnnamedUnion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder TestUnionDefaults::Builder::initUnnamed1() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestUnionDefaults::Builder::adoptUnnamed1(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion> TestUnionDefaults::Builder::disownUnnamed1() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestUnionDefaults::Reader::hasUnnamed2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestUnionDefaults::Builder::hasUnnamed2() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Reader TestUnionDefaults::Reader::getUnnamed2() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 111);
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder TestUnionDefaults::Builder::getUnnamed2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_94f7e0b103b4b718 + 111);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline TestUnionDefaults::Pipeline::getUnnamed2() {
  return  ::capnproto_test::capnp::test::TestUnnamedUnion::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void TestUnionDefaults::Builder::setUnnamed2( ::capnproto_test::capnp::test::TestUnnamedUnion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestUnnamedUnion::Builder TestUnionDefaults::Builder::initUnnamed2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestUnionDefaults::Builder::adoptUnnamed2(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUnnamedUnion> TestUnionDefaults::Builder::disownUnnamed2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUnnamedUnion>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestNestedTypes::Reader::hasNestedStruct() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestNestedTypes::Builder::hasNestedStruct() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Reader TestNestedTypes::Reader::getNestedStruct() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Builder TestNestedTypes::Builder::getNestedStruct() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Pipeline TestNestedTypes::Pipeline::getNestedStruct() {
  return  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestNestedTypes::Builder::setNestedStruct( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::Builder TestNestedTypes::Builder::initNestedStruct() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestNestedTypes::Builder::adoptNestedStruct(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct> TestNestedTypes::Builder::disownNestedStruct() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestNestedTypes::Reader::getOuterNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestNestedTypes::Builder::getOuterNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void TestNestedTypes::Builder::setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestNestedTypes::Reader::getInnerNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestNestedTypes::Builder::getInnerNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 2u);
}
inline void TestNestedTypes::Builder::setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestNestedTypes::NestedStruct::Reader::getOuterNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestNestedTypes::NestedStruct::Builder::getOuterNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void TestNestedTypes::NestedStruct::Builder::setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestNestedTypes::NestedStruct::Reader::getInnerNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestNestedTypes::NestedStruct::Builder::getInnerNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 2u);
}
inline void TestNestedTypes::NestedStruct::Builder::setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestUsing::Reader::getInnerNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum TestUsing::Builder::getInnerNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}
inline void TestUsing::Builder::setInnerNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedStruct::NestedEnum>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 2u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestUsing::Reader::getOuterNestedEnum() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}

inline  ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum TestUsing::Builder::getOuterNestedEnum() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}
inline void TestUsing::Builder::setOuterNestedEnum( ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestNestedTypes::NestedEnum>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool TestLists::Reader::hasList0() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList0() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Reader TestLists::Reader::getList0() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Builder TestLists::Builder::getList0() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList0( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>::Builder TestLists::Builder::initList0(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList0(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>> TestLists::Builder::disownList0() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct0>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasList1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList1() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Reader TestLists::Reader::getList1() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Builder TestLists::Builder::getList1() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList1( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>::Builder TestLists::Builder::initList1(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList1(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>> TestLists::Builder::disownList1() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct1>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasList8() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList8() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Reader TestLists::Reader::getList8() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Builder TestLists::Builder::getList8() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList8( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>::Builder TestLists::Builder::initList8(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList8(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>> TestLists::Builder::disownList8() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct8>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasList16() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList16() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Reader TestLists::Reader::getList16() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Builder TestLists::Builder::getList16() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList16( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>::Builder TestLists::Builder::initList16(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList16(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>> TestLists::Builder::disownList16() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct16>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasList32() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList32() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Reader TestLists::Reader::getList32() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Builder TestLists::Builder::getList32() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList32( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>::Builder TestLists::Builder::initList32(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList32(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>> TestLists::Builder::disownList32() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct32>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasList64() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasList64() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Reader TestLists::Reader::getList64() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Builder TestLists::Builder::getList64() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setList64( ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>::Builder TestLists::Builder::initList64(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptList64(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>> TestLists::Builder::disownList64() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::Struct64>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasListP() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasListP() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Reader TestLists::Reader::getListP() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Builder TestLists::Builder::getListP() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setListP( ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>::Builder TestLists::Builder::initListP(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptListP(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>> TestLists::Builder::disownListP() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestLists::StructP>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasInt32ListList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasInt32ListList() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::int32_t>>::Reader TestLists::Reader::getInt32ListList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::int32_t>>::Builder TestLists::Builder::getInt32ListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setInt32ListList( ::capnp::List< ::capnp::List< ::int32_t>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline void TestLists::Builder::setInt32ListList(::kj::ArrayPtr<const  ::capnp::List< ::int32_t>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::int32_t>>::Builder TestLists::Builder::initInt32ListList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptInt32ListList(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::int32_t>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::int32_t>>> TestLists::Builder::disownInt32ListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::int32_t>>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasTextListList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasTextListList() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Reader TestLists::Reader::getTextListList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Builder TestLists::Builder::getTextListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setTextListList( ::capnp::List< ::capnp::List< ::capnp::Text>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline void TestLists::Builder::setTextListList(::kj::ArrayPtr<const  ::capnp::List< ::capnp::Text>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::capnp::Text>>::Builder TestLists::Builder::initTextListList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptTextListList(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnp::Text>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnp::Text>>> TestLists::Builder::disownTextListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnp::Text>>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool TestLists::Reader::hasStructListList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Builder::hasStructListList() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Reader TestLists::Reader::getStructListList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Builder TestLists::Builder::getStructListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void TestLists::Builder::setStructListList( ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline void TestLists::Builder::setStructListList(::kj::ArrayPtr<const  ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>::Builder TestLists::Builder::initStructListList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), size);
}
inline void TestLists::Builder::adoptStructListList(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>> TestLists::Builder::disownStructListList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::capnproto_test::capnp::test::TestAllTypes>>>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline  ::capnp::Void TestLists::Struct0::Reader::getF() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestLists::Struct0::Builder::getF() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct0::Builder::setF( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct1::Reader::getF() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestLists::Struct1::Builder::getF() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct1::Builder::setF(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t TestLists::Struct8::Reader::getF() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TestLists::Struct8::Builder::getF() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct8::Builder::setF( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TestLists::Struct16::Reader::getF() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestLists::Struct16::Builder::getF() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct16::Builder::setF( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TestLists::Struct32::Reader::getF() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestLists::Struct32::Builder::getF() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct32::Builder::setF( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TestLists::Struct64::Reader::getF() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestLists::Struct64::Builder::getF() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct64::Builder::setF( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::StructP::Reader::hasF() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::StructP::Builder::hasF() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::StructP::Reader::getF() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::StructP::Builder::getF() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::StructP::Builder::setF( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::StructP::Builder::initF(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::StructP::Builder::adoptF(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::StructP::Builder::disownF() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::Void TestLists::Struct0c::Reader::getF() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestLists::Struct0c::Builder::getF() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct0c::Builder::setF( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct0c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct0c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct0c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct0c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct0c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct0c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct0c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct0c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestLists::Struct1c::Reader::getF() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestLists::Struct1c::Builder::getF() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct1c::Builder::setF(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct1c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct1c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct1c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct1c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct1c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct1c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct1c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct1c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint8_t TestLists::Struct8c::Reader::getF() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t TestLists::Struct8c::Builder::getF() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct8c::Builder::setF( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct8c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct8c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct8c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct8c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct8c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct8c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct8c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct8c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t TestLists::Struct16c::Reader::getF() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TestLists::Struct16c::Builder::getF() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct16c::Builder::setF( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct16c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct16c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct16c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct16c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct16c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct16c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct16c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct16c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TestLists::Struct32c::Reader::getF() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestLists::Struct32c::Builder::getF() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct32c::Builder::setF( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct32c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct32c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct32c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct32c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct32c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct32c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct32c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct32c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t TestLists::Struct64c::Reader::getF() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestLists::Struct64c::Builder::getF() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::Struct64c::Builder::setF( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLists::Struct64c::Reader::hasPad() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::Struct64c::Builder::hasPad() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::Struct64c::Reader::getPad() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::Struct64c::Builder::getPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::Struct64c::Builder::setPad( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::Struct64c::Builder::initPad(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::Struct64c::Builder::adoptPad(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::Struct64c::Builder::disownPad() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestLists::StructPc::Reader::hasF() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLists::StructPc::Builder::hasF() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLists::StructPc::Reader::getF() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLists::StructPc::Builder::getF() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLists::StructPc::Builder::setF( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLists::StructPc::Builder::initF(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLists::StructPc::Builder::adoptF(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLists::StructPc::Builder::disownF() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t TestLists::StructPc::Reader::getPad() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestLists::StructPc::Builder::getPad() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLists::StructPc::Builder::setPad( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestFieldZeroIsBit::Reader::getBit() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestFieldZeroIsBit::Builder::getBit() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestFieldZeroIsBit::Builder::setBit(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestFieldZeroIsBit::Reader::getSecondBit() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, true);
}

inline bool TestFieldZeroIsBit::Builder::getSecondBit() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, true);
}
inline void TestFieldZeroIsBit::Builder::setSecondBit(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, true);
}

inline  ::uint8_t TestFieldZeroIsBit::Reader::getThirdField() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 123u);
}

inline  ::uint8_t TestFieldZeroIsBit::Builder::getThirdField() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 123u);
}
inline void TestFieldZeroIsBit::Builder::setThirdField( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 123u);
}

inline bool TestListDefaults::Reader::hasLists() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestListDefaults::Builder::hasLists() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestLists::Reader TestListDefaults::Reader::getLists() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_a851ad32cbc2ffea + 36);
}
inline  ::capnproto_test::capnp::test::TestLists::Builder TestListDefaults::Builder::getLists() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_a851ad32cbc2ffea + 36);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestLists::Pipeline TestListDefaults::Pipeline::getLists() {
  return  ::capnproto_test::capnp::test::TestLists::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestListDefaults::Builder::setLists( ::capnproto_test::capnp::test::TestLists::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestLists::Builder TestListDefaults::Builder::initLists() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestListDefaults::Builder::adoptLists(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestLists>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestLists> TestListDefaults::Builder::disownLists() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestLists>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t TestLateUnion::Reader::getFoo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestLateUnion::Builder::getFoo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestLateUnion::Builder::setFoo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestLateUnion::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestLateUnion::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLateUnion::Reader::getBar() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLateUnion::Builder::getBar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestLateUnion::Builder::setBar( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLateUnion::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestLateUnion::Builder::adoptBar(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLateUnion::Builder::disownBar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int16_t TestLateUnion::Reader::getBaz() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int16_t TestLateUnion::Builder::getBaz() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestLateUnion::Builder::setBaz( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline typename TestLateUnion::TheUnion::Reader TestLateUnion::Reader::getTheUnion() const {
  return typename TestLateUnion::TheUnion::Reader(_reader);
}
inline typename TestLateUnion::TheUnion::Builder TestLateUnion::Builder::getTheUnion() {
  return typename TestLateUnion::TheUnion::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestLateUnion::TheUnion::Pipeline TestLateUnion::Pipeline::getTheUnion() {
  return typename TestLateUnion::TheUnion::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestLateUnion::TheUnion::Builder TestLateUnion::Builder::initTheUnion() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename TestLateUnion::TheUnion::Builder(_builder);
}
inline typename TestLateUnion::AnotherUnion::Reader TestLateUnion::Reader::getAnotherUnion() const {
  return typename TestLateUnion::AnotherUnion::Reader(_reader);
}
inline typename TestLateUnion::AnotherUnion::Builder TestLateUnion::Builder::getAnotherUnion() {
  return typename TestLateUnion::AnotherUnion::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestLateUnion::AnotherUnion::Pipeline TestLateUnion::Pipeline::getAnotherUnion() {
  return typename TestLateUnion::AnotherUnion::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestLateUnion::AnotherUnion::Builder TestLateUnion::Builder::initAnotherUnion() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename TestLateUnion::AnotherUnion::Builder(_builder);
}
inline  ::capnproto_test::capnp::test::TestLateUnion::TheUnion::Which TestLateUnion::TheUnion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestLateUnion::TheUnion::Which TestLateUnion::TheUnion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool TestLateUnion::TheUnion::Reader::isQux() const {
  return which() == TestLateUnion::TheUnion::QUX;
}
inline bool TestLateUnion::TheUnion::Builder::isQux() {
  return which() == TestLateUnion::TheUnion::QUX;
}
inline bool TestLateUnion::TheUnion::Reader::hasQux() const {
  if (which() != TestLateUnion::TheUnion::QUX) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestLateUnion::TheUnion::Builder::hasQux() {
  if (which() != TestLateUnion::TheUnion::QUX) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLateUnion::TheUnion::Reader::getQux() const {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLateUnion::TheUnion::Builder::getQux() {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestLateUnion::TheUnion::Builder::setQux( ::capnp::Text::Reader value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLateUnion::TheUnion::Builder::initQux(unsigned int size) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::QUX);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestLateUnion::TheUnion::Builder::adoptQux(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLateUnion::TheUnion::Builder::disownQux() {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestLateUnion::TheUnion::Reader::isCorge() const {
  return which() == TestLateUnion::TheUnion::CORGE;
}
inline bool TestLateUnion::TheUnion::Builder::isCorge() {
  return which() == TestLateUnion::TheUnion::CORGE;
}
inline bool TestLateUnion::TheUnion::Reader::hasCorge() const {
  if (which() != TestLateUnion::TheUnion::CORGE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestLateUnion::TheUnion::Builder::hasCorge() {
  if (which() != TestLateUnion::TheUnion::CORGE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader TestLateUnion::TheUnion::Reader::getCorge() const {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder TestLateUnion::TheUnion::Builder::getCorge() {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestLateUnion::TheUnion::Builder::setCorge( ::capnp::List< ::int32_t>::Reader value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void TestLateUnion::TheUnion::Builder::setCorge(::kj::ArrayPtr<const  ::int32_t> value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder TestLateUnion::TheUnion::Builder::initCorge(unsigned int size) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::CORGE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestLateUnion::TheUnion::Builder::adoptCorge(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> TestLateUnion::TheUnion::Builder::disownCorge() {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestLateUnion::TheUnion::Reader::isGrault() const {
  return which() == TestLateUnion::TheUnion::GRAULT;
}
inline bool TestLateUnion::TheUnion::Builder::isGrault() {
  return which() == TestLateUnion::TheUnion::GRAULT;
}
inline float TestLateUnion::TheUnion::Reader::getGrault() const {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::GRAULT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float TestLateUnion::TheUnion::Builder::getGrault() {
  KJ_IREQUIRE((which() == TestLateUnion::TheUnion::GRAULT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestLateUnion::TheUnion::Builder::setGrault(float value) {
  _builder.setDataField<TestLateUnion::TheUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, TestLateUnion::TheUnion::GRAULT);
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestLateUnion::AnotherUnion::Which TestLateUnion::AnotherUnion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestLateUnion::AnotherUnion::Which TestLateUnion::AnotherUnion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline bool TestLateUnion::AnotherUnion::Reader::isQux() const {
  return which() == TestLateUnion::AnotherUnion::QUX;
}
inline bool TestLateUnion::AnotherUnion::Builder::isQux() {
  return which() == TestLateUnion::AnotherUnion::QUX;
}
inline bool TestLateUnion::AnotherUnion::Reader::hasQux() const {
  if (which() != TestLateUnion::AnotherUnion::QUX) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestLateUnion::AnotherUnion::Builder::hasQux() {
  if (which() != TestLateUnion::AnotherUnion::QUX) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestLateUnion::AnotherUnion::Reader::getQux() const {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestLateUnion::AnotherUnion::Builder::getQux() {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestLateUnion::AnotherUnion::Builder::setQux( ::capnp::Text::Reader value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestLateUnion::AnotherUnion::Builder::initQux(unsigned int size) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::QUX);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestLateUnion::AnotherUnion::Builder::adoptQux(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestLateUnion::AnotherUnion::Builder::disownQux() {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestLateUnion::AnotherUnion::Reader::isCorge() const {
  return which() == TestLateUnion::AnotherUnion::CORGE;
}
inline bool TestLateUnion::AnotherUnion::Builder::isCorge() {
  return which() == TestLateUnion::AnotherUnion::CORGE;
}
inline bool TestLateUnion::AnotherUnion::Reader::hasCorge() const {
  if (which() != TestLateUnion::AnotherUnion::CORGE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestLateUnion::AnotherUnion::Builder::hasCorge() {
  if (which() != TestLateUnion::AnotherUnion::CORGE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t>::Reader TestLateUnion::AnotherUnion::Reader::getCorge() const {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t>::Builder TestLateUnion::AnotherUnion::Builder::getCorge() {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestLateUnion::AnotherUnion::Builder::setCorge( ::capnp::List< ::int32_t>::Reader value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void TestLateUnion::AnotherUnion::Builder::setCorge(::kj::ArrayPtr<const  ::int32_t> value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t>::Builder TestLateUnion::AnotherUnion::Builder::initCorge(unsigned int size) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::CORGE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestLateUnion::AnotherUnion::Builder::adoptCorge(
    ::capnp::Orphan< ::capnp::List< ::int32_t>>&& value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::CORGE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t>> TestLateUnion::AnotherUnion::Builder::disownCorge() {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::CORGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestLateUnion::AnotherUnion::Reader::isGrault() const {
  return which() == TestLateUnion::AnotherUnion::GRAULT;
}
inline bool TestLateUnion::AnotherUnion::Builder::isGrault() {
  return which() == TestLateUnion::AnotherUnion::GRAULT;
}
inline float TestLateUnion::AnotherUnion::Reader::getGrault() const {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::GRAULT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float TestLateUnion::AnotherUnion::Builder::getGrault() {
  KJ_IREQUIRE((which() == TestLateUnion::AnotherUnion::GRAULT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TestLateUnion::AnotherUnion::Builder::setGrault(float value) {
  _builder.setDataField<TestLateUnion::AnotherUnion::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, TestLateUnion::AnotherUnion::GRAULT);
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t TestOldVersion::Reader::getOld1() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestOldVersion::Builder::getOld1() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestOldVersion::Builder::setOld1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestOldVersion::Reader::hasOld2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestOldVersion::Builder::hasOld2() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestOldVersion::Reader::getOld2() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestOldVersion::Builder::getOld2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestOldVersion::Builder::setOld2( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestOldVersion::Builder::initOld2(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestOldVersion::Builder::adoptOld2(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestOldVersion::Builder::disownOld2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestOldVersion::Reader::hasOld3() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestOldVersion::Builder::hasOld3() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestOldVersion::Reader TestOldVersion::Reader::getOld3() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestOldVersion::Builder TestOldVersion::Builder::getOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestOldVersion::Pipeline TestOldVersion::Pipeline::getOld3() {
  return  ::capnproto_test::capnp::test::TestOldVersion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestOldVersion::Builder::setOld3( ::capnproto_test::capnp::test::TestOldVersion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestOldVersion::Builder TestOldVersion::Builder::initOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestOldVersion::Builder::adoptOld3(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestOldVersion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestOldVersion> TestOldVersion::Builder::disownOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestOldVersion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int64_t TestNewVersion::Reader::getOld1() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t TestNewVersion::Builder::getOld1() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestNewVersion::Builder::setOld1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestNewVersion::Reader::hasOld2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestNewVersion::Builder::hasOld2() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestNewVersion::Reader::getOld2() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestNewVersion::Builder::getOld2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestNewVersion::Builder::setOld2( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestNewVersion::Builder::initOld2(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestNewVersion::Builder::adoptOld2(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestNewVersion::Builder::disownOld2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestNewVersion::Reader::hasOld3() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestNewVersion::Builder::hasOld3() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestNewVersion::Reader TestNewVersion::Reader::getOld3() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestNewVersion::Builder TestNewVersion::Builder::getOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestNewVersion::Pipeline TestNewVersion::Pipeline::getOld3() {
  return  ::capnproto_test::capnp::test::TestNewVersion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestNewVersion::Builder::setOld3( ::capnproto_test::capnp::test::TestNewVersion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestNewVersion::Builder TestNewVersion::Builder::initOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestNewVersion::Builder::adoptOld3(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestNewVersion>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestNewVersion> TestNewVersion::Builder::disownOld3() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestNewVersion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int64_t TestNewVersion::Reader::getNew1() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 987ll);
}

inline  ::int64_t TestNewVersion::Builder::getNew1() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 987ll);
}
inline void TestNewVersion::Builder::setNew1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 987ll);
}

inline bool TestNewVersion::Reader::hasNew2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestNewVersion::Builder::hasNew2() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestNewVersion::Reader::getNew2() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_8ed75a7469f04ce3 + 97, 3);
}
inline  ::capnp::Text::Builder TestNewVersion::Builder::getNew2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_8ed75a7469f04ce3 + 97, 3);
}
inline void TestNewVersion::Builder::setNew2( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestNewVersion::Builder::initNew2(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestNewVersion::Builder::adoptNew2(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestNewVersion::Builder::disownNew2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestOldUnionVersion::Which TestOldUnionVersion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestOldUnionVersion::Which TestOldUnionVersion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestOldUnionVersion::Reader::isA() const {
  return which() == TestOldUnionVersion::A;
}
inline bool TestOldUnionVersion::Builder::isA() {
  return which() == TestOldUnionVersion::A;
}
inline  ::capnp::Void TestOldUnionVersion::Reader::getA() const {
  KJ_IREQUIRE((which() == TestOldUnionVersion::A),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestOldUnionVersion::Builder::getA() {
  KJ_IREQUIRE((which() == TestOldUnionVersion::A),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestOldUnionVersion::Builder::setA( ::capnp::Void value) {
  _builder.setDataField<TestOldUnionVersion::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestOldUnionVersion::A);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestOldUnionVersion::Reader::isB() const {
  return which() == TestOldUnionVersion::B;
}
inline bool TestOldUnionVersion::Builder::isB() {
  return which() == TestOldUnionVersion::B;
}
inline  ::uint64_t TestOldUnionVersion::Reader::getB() const {
  KJ_IREQUIRE((which() == TestOldUnionVersion::B),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestOldUnionVersion::Builder::getB() {
  KJ_IREQUIRE((which() == TestOldUnionVersion::B),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestOldUnionVersion::Builder::setB( ::uint64_t value) {
  _builder.setDataField<TestOldUnionVersion::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestOldUnionVersion::B);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestNewUnionVersion::Which TestNewUnionVersion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestNewUnionVersion::Which TestNewUnionVersion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestNewUnionVersion::Reader::isA() const {
  return which() == TestNewUnionVersion::A;
}
inline bool TestNewUnionVersion::Builder::isA() {
  return which() == TestNewUnionVersion::A;
}
inline typename TestNewUnionVersion::A::Reader TestNewUnionVersion::Reader::getA() const {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A),
              "Must check which() before get()ing a union member.");
  return typename TestNewUnionVersion::A::Reader(_reader);
}
inline typename TestNewUnionVersion::A::Builder TestNewUnionVersion::Builder::getA() {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A),
              "Must check which() before get()ing a union member.");
  return typename TestNewUnionVersion::A::Builder(_builder);
}
inline typename TestNewUnionVersion::A::Builder TestNewUnionVersion::Builder::initA() {
  _builder.setDataField<TestNewUnionVersion::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestNewUnionVersion::A);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename TestNewUnionVersion::A::Builder(_builder);
}
inline bool TestNewUnionVersion::Reader::isB() const {
  return which() == TestNewUnionVersion::B;
}
inline bool TestNewUnionVersion::Builder::isB() {
  return which() == TestNewUnionVersion::B;
}
inline  ::uint64_t TestNewUnionVersion::Reader::getB() const {
  KJ_IREQUIRE((which() == TestNewUnionVersion::B),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestNewUnionVersion::Builder::getB() {
  KJ_IREQUIRE((which() == TestNewUnionVersion::B),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TestNewUnionVersion::Builder::setB( ::uint64_t value) {
  _builder.setDataField<TestNewUnionVersion::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestNewUnionVersion::B);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::TestNewUnionVersion::A::Which TestNewUnionVersion::A::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestNewUnionVersion::A::Which TestNewUnionVersion::A::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool TestNewUnionVersion::A::Reader::isA0() const {
  return which() == TestNewUnionVersion::A::A0;
}
inline bool TestNewUnionVersion::A::Builder::isA0() {
  return which() == TestNewUnionVersion::A::A0;
}
inline  ::capnp::Void TestNewUnionVersion::A::Reader::getA0() const {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A::A0),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void TestNewUnionVersion::A::Builder::getA0() {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A::A0),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestNewUnionVersion::A::Builder::setA0( ::capnp::Void value) {
  _builder.setDataField<TestNewUnionVersion::A::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TestNewUnionVersion::A::A0);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestNewUnionVersion::A::Reader::isA1() const {
  return which() == TestNewUnionVersion::A::A1;
}
inline bool TestNewUnionVersion::A::Builder::isA1() {
  return which() == TestNewUnionVersion::A::A1;
}
inline  ::uint64_t TestNewUnionVersion::A::Reader::getA1() const {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A::A1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TestNewUnionVersion::A::Builder::getA1() {
  KJ_IREQUIRE((which() == TestNewUnionVersion::A::A1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TestNewUnionVersion::A::Builder::setA1( ::uint64_t value) {
  _builder.setDataField<TestNewUnionVersion::A::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, TestNewUnionVersion::A::A1);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline typename TestStructUnion::Un::Reader TestStructUnion::Reader::getUn() const {
  return typename TestStructUnion::Un::Reader(_reader);
}
inline typename TestStructUnion::Un::Builder TestStructUnion::Builder::getUn() {
  return typename TestStructUnion::Un::Builder(_builder);
}
#if !CAPNP_LITE
inline typename TestStructUnion::Un::Pipeline TestStructUnion::Pipeline::getUn() {
  return typename TestStructUnion::Un::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename TestStructUnion::Un::Builder TestStructUnion::Builder::initUn() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename TestStructUnion::Un::Builder(_builder);
}
inline bool TestStructUnion::SomeStruct::Reader::hasSomeText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestStructUnion::SomeStruct::Builder::hasSomeText() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestStructUnion::SomeStruct::Reader::getSomeText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestStructUnion::SomeStruct::Builder::getSomeText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestStructUnion::SomeStruct::Builder::setSomeText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestStructUnion::SomeStruct::Builder::initSomeText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestStructUnion::SomeStruct::Builder::adoptSomeText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestStructUnion::SomeStruct::Builder::disownSomeText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestStructUnion::SomeStruct::Reader::hasMoreText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestStructUnion::SomeStruct::Builder::hasMoreText() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestStructUnion::SomeStruct::Reader::getMoreText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestStructUnion::SomeStruct::Builder::getMoreText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestStructUnion::SomeStruct::Builder::setMoreText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestStructUnion::SomeStruct::Builder::initMoreText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestStructUnion::SomeStruct::Builder::adoptMoreText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestStructUnion::SomeStruct::Builder::disownMoreText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestStructUnion::Un::Which TestStructUnion::Un::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::TestStructUnion::Un::Which TestStructUnion::Un::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestStructUnion::Un::Reader::isStruct() const {
  return which() == TestStructUnion::Un::STRUCT;
}
inline bool TestStructUnion::Un::Builder::isStruct() {
  return which() == TestStructUnion::Un::STRUCT;
}
inline bool TestStructUnion::Un::Reader::hasStruct() const {
  if (which() != TestStructUnion::Un::STRUCT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestStructUnion::Un::Builder::hasStruct() {
  if (which() != TestStructUnion::Un::STRUCT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Reader TestStructUnion::Un::Reader::getStruct() const {
  KJ_IREQUIRE((which() == TestStructUnion::Un::STRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Builder TestStructUnion::Un::Builder::getStruct() {
  KJ_IREQUIRE((which() == TestStructUnion::Un::STRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestStructUnion::Un::Builder::setStruct( ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Reader value) {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::STRUCT);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestStructUnion::SomeStruct::Builder TestStructUnion::Un::Builder::initStruct() {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::STRUCT);
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestStructUnion::Un::Builder::adoptStruct(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>&& value) {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::STRUCT);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct> TestStructUnion::Un::Builder::disownStruct() {
  KJ_IREQUIRE((which() == TestStructUnion::Un::STRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestStructUnion::SomeStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestStructUnion::Un::Reader::isObject() const {
  return which() == TestStructUnion::Un::OBJECT;
}
inline bool TestStructUnion::Un::Builder::isObject() {
  return which() == TestStructUnion::Un::OBJECT;
}
inline bool TestStructUnion::Un::Reader::hasObject() const {
  if (which() != TestStructUnion::Un::OBJECT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestStructUnion::Un::Builder::hasObject() {
  if (which() != TestStructUnion::Un::OBJECT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestAnyPointer::Reader TestStructUnion::Un::Reader::getObject() const {
  KJ_IREQUIRE((which() == TestStructUnion::Un::OBJECT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestAnyPointer::Builder TestStructUnion::Un::Builder::getObject() {
  KJ_IREQUIRE((which() == TestStructUnion::Un::OBJECT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestStructUnion::Un::Builder::setObject( ::capnproto_test::capnp::test::TestAnyPointer::Reader value) {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::OBJECT);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestAnyPointer::Builder TestStructUnion::Un::Builder::initObject() {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::OBJECT);
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestStructUnion::Un::Builder::adoptObject(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestAnyPointer>&& value) {
  _builder.setDataField<TestStructUnion::Un::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestStructUnion::Un::OBJECT);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAnyPointer> TestStructUnion::Un::Builder::disownObject() {
  KJ_IREQUIRE((which() == TestStructUnion::Un::OBJECT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAnyPointer>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestPrintInlineStructs::Reader::hasSomeText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPrintInlineStructs::Builder::hasSomeText() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestPrintInlineStructs::Reader::getSomeText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestPrintInlineStructs::Builder::getSomeText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestPrintInlineStructs::Builder::setSomeText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestPrintInlineStructs::Builder::initSomeText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestPrintInlineStructs::Builder::adoptSomeText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestPrintInlineStructs::Builder::disownSomeText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestPrintInlineStructs::Reader::hasStructList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestPrintInlineStructs::Builder::hasStructList() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Reader TestPrintInlineStructs::Reader::getStructList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Builder TestPrintInlineStructs::Builder::getStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestPrintInlineStructs::Builder::setStructList( ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>::Builder TestPrintInlineStructs::Builder::initStructList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestPrintInlineStructs::Builder::adoptStructList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>> TestPrintInlineStructs::Builder::disownStructList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestPrintInlineStructs::InlineStruct>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t TestPrintInlineStructs::InlineStruct::Reader::getInt32Field() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestPrintInlineStructs::InlineStruct::Builder::getInt32Field() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestPrintInlineStructs::InlineStruct::Builder::setInt32Field( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestPrintInlineStructs::InlineStruct::Reader::hasTextField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPrintInlineStructs::InlineStruct::Builder::hasTextField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestPrintInlineStructs::InlineStruct::Reader::getTextField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestPrintInlineStructs::InlineStruct::Builder::getTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestPrintInlineStructs::InlineStruct::Builder::setTextField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestPrintInlineStructs::InlineStruct::Builder::initTextField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestPrintInlineStructs::InlineStruct::Builder::adoptTextField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestPrintInlineStructs::InlineStruct::Builder::disownTextField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float TestWholeFloatDefault::Reader::getField() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1123418112u);
}

inline float TestWholeFloatDefault::Builder::getField() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1123418112u);
}
inline void TestWholeFloatDefault::Builder::setField(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1123418112u);
}

inline float TestWholeFloatDefault::Reader::getBigField() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1909060298u);
}

inline float TestWholeFloatDefault::Builder::getBigField() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1909060298u);
}
inline void TestWholeFloatDefault::Builder::setBigField(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1909060298u);
}

template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Which TestGenerics<Foo, Bar>::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Which TestGenerics<Foo, Bar>::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Foo> TestGenerics<Foo, Bar>::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<Foo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<Foo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline  ::capnp::PipelineFor<Foo> TestGenerics<Foo, Bar>::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<Foo>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Builder::setFoo( ::capnp::ReaderFor<Foo> value) {
  ::capnp::_::PointerHelpers<Foo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Builder::adoptFoo(
    ::capnp::Orphan<Foo>&& value) {
  ::capnp::_::PointerHelpers<Foo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Foo> TestGenerics<Foo, Bar>::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<Foo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Reader::hasRev() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Builder::hasRev() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Reader TestGenerics<Foo, Bar>::Reader::getRev() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Builder TestGenerics<Foo, Bar>::Builder::getRev() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Pipeline TestGenerics<Foo, Bar>::Pipeline::getRev() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Builder::setRev(typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::Builder TestGenerics<Foo, Bar>::Builder::initRev() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Builder::adoptRev(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>> TestGenerics<Foo, Bar>::Builder::disownRev() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Reader::isUv() const {
  return which() == TestGenerics<Foo, Bar>::UV;
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Builder::isUv() {
  return which() == TestGenerics<Foo, Bar>::UV;
}
template <typename Foo, typename Bar>
inline  ::capnp::Void TestGenerics<Foo, Bar>::Reader::getUv() const {
  KJ_IREQUIRE((which() == TestGenerics<Foo, Bar>::UV),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Foo, typename Bar>
inline  ::capnp::Void TestGenerics<Foo, Bar>::Builder::getUv() {
  KJ_IREQUIRE((which() == TestGenerics<Foo, Bar>::UV),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Builder::setUv( ::capnp::Void value) {
  _builder.setDataField<TestGenerics<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenerics<Foo, Bar>::UV);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Reader::isUg() const {
  return which() == TestGenerics<Foo, Bar>::UG;
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Builder::isUg() {
  return which() == TestGenerics<Foo, Bar>::UG;
}
template <typename Foo, typename Bar>
inline typename TestGenerics<Foo, Bar>::Ug::Reader TestGenerics<Foo, Bar>::Reader::getUg() const {
  KJ_IREQUIRE((which() == TestGenerics<Foo, Bar>::UG),
              "Must check which() before get()ing a union member.");
  return typename TestGenerics<Foo, Bar>::Ug::Reader(_reader);
}
template <typename Foo, typename Bar>
inline typename TestGenerics<Foo, Bar>::Ug::Builder TestGenerics<Foo, Bar>::Builder::getUg() {
  KJ_IREQUIRE((which() == TestGenerics<Foo, Bar>::UG),
              "Must check which() before get()ing a union member.");
  return typename TestGenerics<Foo, Bar>::Ug::Builder(_builder);
}
template <typename Foo, typename Bar>
inline typename TestGenerics<Foo, Bar>::Ug::Builder TestGenerics<Foo, Bar>::Builder::initUg() {
  _builder.setDataField<TestGenerics<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenerics<Foo, Bar>::UG);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename TestGenerics<Foo, Bar>::Ug::Builder(_builder);
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Inner::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Inner::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Foo> TestGenerics<Foo, Bar>::Inner::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<Foo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<Foo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline  ::capnp::PipelineFor<Foo> TestGenerics<Foo, Bar>::Inner::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<Foo>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Inner::Builder::setFoo( ::capnp::ReaderFor<Foo> value) {
  ::capnp::_::PointerHelpers<Foo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Inner::Builder::adoptFoo(
    ::capnp::Orphan<Foo>&& value) {
  ::capnp::_::PointerHelpers<Foo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Foo> TestGenerics<Foo, Bar>::Inner::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<Foo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Inner::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::Inner::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Bar> TestGenerics<Foo, Bar>::Inner::Reader::getBar() const {
  return ::capnp::_::PointerHelpers<Bar>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner::Builder::getBar() {
  return ::capnp::_::PointerHelpers<Bar>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline  ::capnp::PipelineFor<Bar> TestGenerics<Foo, Bar>::Inner::Pipeline::getBar() {
  return  ::capnp::PipelineFor<Bar>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Inner::Builder::setBar( ::capnp::ReaderFor<Bar> value) {
  ::capnp::_::PointerHelpers<Bar>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner::Builder::initBar() {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Inner::Builder::adoptBar(
    ::capnp::Orphan<Bar>&& value) {
  ::capnp::_::PointerHelpers<Bar>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Bar> TestGenerics<Foo, Bar>::Inner::Builder::disownBar() {
  return ::capnp::_::PointerHelpers<Bar>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// TestGenerics<Foo, Bar>::Inner
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f6a841117e19ac73, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::ReaderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::getBar() const {
  return ::capnp::_::PointerHelpers<Bar>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::getBar() {
  return ::capnp::_::PointerHelpers<Bar>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::PipelineFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Pipeline::getBar() {
  return  ::capnp::PipelineFor<Bar>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::setBar( ::capnp::ReaderFor<Bar> value) {
  ::capnp::_::PointerHelpers<Bar>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initBar() {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::adoptBar(
    ::capnp::Orphan<Bar>&& value) {
  ::capnp::_::PointerHelpers<Bar>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline ::capnp::Orphan<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::disownBar() {
  return ::capnp::_::PointerHelpers<Bar>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::hasBaz() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::hasBaz() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::ReaderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::getBaz() const {
  return ::capnp::_::PointerHelpers<Baz>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::getBaz() {
  return ::capnp::_::PointerHelpers<Baz>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::PipelineFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Pipeline::getBaz() {
  return  ::capnp::PipelineFor<Baz>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::setBaz( ::capnp::ReaderFor<Baz> value) {
  ::capnp::_::PointerHelpers<Baz>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initBaz() {
  return ::capnp::_::PointerHelpers<Baz>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initBaz(unsigned int size) {
  return ::capnp::_::PointerHelpers<Baz>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::adoptBaz(
    ::capnp::Orphan<Baz>&& value) {
  ::capnp::_::PointerHelpers<Baz>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline ::capnp::Orphan<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::disownBaz() {
  return ::capnp::_::PointerHelpers<Baz>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::hasInnerBound() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::hasInnerBound() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::getInnerBound() const {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::getInnerBound() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline TestGenerics<Foo, Bar>::Inner2<Baz>::Pipeline::getInnerBound() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::setInnerBound(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initInnerBound() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::adoptInnerBound(
    ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>&& value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::disownInnerBound() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::hasInnerUnbound() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::hasInnerUnbound() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Reader TestGenerics<Foo, Bar>::Inner2<Baz>::Reader::getInnerUnbound() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Builder TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::getInnerUnbound() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Pipeline TestGenerics<Foo, Bar>::Inner2<Baz>::Pipeline::getInnerUnbound() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::setInnerUnbound( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner::Builder TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::initInnerUnbound() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::adoptInnerUnbound(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner> TestGenerics<Foo, Bar>::Inner2<Baz>::Builder::disownInnerUnbound() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::ReaderFor<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<Foo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<Foo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::PipelineFor<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<Foo>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::setFoo( ::capnp::ReaderFor<Foo> value) {
  ::capnp::_::PointerHelpers<Foo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::adoptFoo(
    ::capnp::Orphan<Foo>&& value) {
  ::capnp::_::PointerHelpers<Foo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline ::capnp::Orphan<Foo> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<Foo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::ReaderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::getBar() const {
  return ::capnp::_::PointerHelpers<Bar>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::getBar() {
  return ::capnp::_::PointerHelpers<Bar>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::PipelineFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Pipeline::getBar() {
  return  ::capnp::PipelineFor<Bar>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::setBar( ::capnp::ReaderFor<Bar> value) {
  ::capnp::_::PointerHelpers<Bar>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initBar() {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::adoptBar(
    ::capnp::Orphan<Bar>&& value) {
  ::capnp::_::PointerHelpers<Bar>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline ::capnp::Orphan<Bar> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::disownBar() {
  return ::capnp::_::PointerHelpers<Bar>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::hasBaz() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::hasBaz() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::ReaderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::getBaz() const {
  return ::capnp::_::PointerHelpers<Baz>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::getBaz() {
  return ::capnp::_::PointerHelpers<Baz>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::PipelineFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Pipeline::getBaz() {
  return  ::capnp::PipelineFor<Baz>(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::setBaz( ::capnp::ReaderFor<Baz> value) {
  ::capnp::_::PointerHelpers<Baz>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initBaz() {
  return ::capnp::_::PointerHelpers<Baz>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initBaz(unsigned int size) {
  return ::capnp::_::PointerHelpers<Baz>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::adoptBaz(
    ::capnp::Orphan<Baz>&& value) {
  ::capnp::_::PointerHelpers<Baz>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline ::capnp::Orphan<Baz> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::disownBaz() {
  return ::capnp::_::PointerHelpers<Baz>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::hasQux() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::hasQux() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::ReaderFor<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Reader::getQux() const {
  return ::capnp::_::PointerHelpers<Qux>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::getQux() {
  return ::capnp::_::PointerHelpers<Qux>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::PipelineFor<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Pipeline::getQux() {
  return  ::capnp::PipelineFor<Qux>(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::setQux( ::capnp::ReaderFor<Qux> value) {
  ::capnp::_::PointerHelpers<Qux>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initQux() {
  return ::capnp::_::PointerHelpers<Qux>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::initQux(unsigned int size) {
  return ::capnp::_::PointerHelpers<Qux>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::adoptQux(
    ::capnp::Orphan<Qux>&& value) {
  ::capnp::_::PointerHelpers<Qux>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
inline ::capnp::Orphan<Qux> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::Builder::disownQux() {
  return ::capnp::_::PointerHelpers<Qux>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
inline TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
inline TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
template <typename _t, typename>
inline TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
template <typename _t, typename>
inline TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
inline TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::Client& TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::Client& TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::brandScopes[] = {
  { 0x8839ed86c9794287, brandBindings + 0, 1, false},
  { 0x9d5b8cd8de9922eb, brandBindings + 1, 2, false},
  { 0xa9ab42b118d6d435, brandBindings + 3, 1, false},
  { 0xb6a0829c762b06f3, brandBindings + 4, 1, false},
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Quux>(),
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Baz>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b84eecc799437049, brandScopes, nullptr,
  4, 0, nullptr
};
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::brandScopes[] = {
  { 0x8839ed86c9794287, brandBindings + 0, 1, false},
  { 0x9d5b8cd8de9922eb, brandBindings + 1, 2, false},
  { 0xa9ab42b118d6d435, brandBindings + 3, 1, false},
  { 0xb6a0829c762b06f3, brandBindings + 4, 1, false},
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Quux>(),
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Baz>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::CallResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e080f0fc54614f6f, brandScopes, nullptr,
  4, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults>)
TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Client::callRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults>(
      0x8839ed86c9794287ull, 0, sizeHint);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Server::call(CallContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Inner2.DeepNest.DeepNestInterface", "call",
      0x8839ed86c9794287ull, 0);
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x8839ed86c9794287ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Inner2.DeepNest.DeepNestInterface", interfaceId);
  }
}
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return call(::capnp::Capability::Server::internalGetTypedContext<
          typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults>(context));
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Inner2.DeepNest.DeepNestInterface",
          0x8839ed86c9794287ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::brandScopes[] = {
  { 0x8839ed86c9794287, brandBindings + 0, 1, false},
  { 0x9d5b8cd8de9922eb, brandBindings + 1, 2, false},
  { 0xa9ab42b118d6d435, brandBindings + 3, 1, false},
  { 0xb6a0829c762b06f3, brandBindings + 4, 1, false},
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Quux>(),
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Baz>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallParams::_capnpPrivate::brand() },
  { 50331648,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2<Baz>::template DeepNest<Qux>::template DeepNestInterface<Quux>::CallResults::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
template <typename Quux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::DeepNestInterface<Quux>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8839ed86c9794287, brandScopes, brandDependencies,
  4, 2, nullptr
};
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
  { 0xa9ab42b118d6d435, brandBindings + 2, 1, false},
  { 0xb6a0829c762b06f3, brandBindings + 3, 1, false},
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Baz>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Baz>
template <typename Qux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner2<Baz>::DeepNest<Qux>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b6a0829c762b06f3, brandScopes, nullptr,
  3, 0, nullptr
};
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>::Inner2<Baz>
template <typename Foo, typename Bar>
template <typename Baz>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
template <typename Baz>
constexpr uint16_t TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Baz>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Baz>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Baz>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
  { 0xa9ab42b118d6d435, brandBindings + 2, 1, false},
};
template <typename Foo, typename Bar>
template <typename Baz>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Baz>(),
};
template <typename Foo, typename Bar>
template <typename Baz>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::brandDependencies[] = {
  { 16777218,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
template <typename Baz>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Inner2<Baz>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a9ab42b118d6d435, brandScopes, brandDependencies,
  2, 1, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline TestGenerics<Foo, Bar>::Interface<Qux>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Foo, typename Bar>
template <typename Qux>
inline TestGenerics<Foo, Bar>::Interface<Qux>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Foo, typename Bar>
template <typename Qux>
template <typename _t, typename>
inline TestGenerics<Foo, Bar>::Interface<Qux>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Foo, typename Bar>
template <typename Qux>
template <typename _t, typename>
inline TestGenerics<Foo, Bar>::Interface<Qux>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Foo, typename Bar>
template <typename Qux>
inline TestGenerics<Foo, Bar>::Interface<Qux>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Foo, typename Bar>
template <typename Qux>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::Client& TestGenerics<Foo, Bar>::Interface<Qux>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Foo, typename Bar>
template <typename Qux>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::Client& TestGenerics<Foo, Bar>::Interface<Qux>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Reader::hasQux() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::hasQux() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnp::ReaderFor<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Reader::getQux() const {
  return ::capnp::_::PointerHelpers<Qux>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::getQux() {
  return ::capnp::_::PointerHelpers<Qux>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnp::PipelineFor<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Pipeline::getQux() {
  return  ::capnp::PipelineFor<Qux>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::setQux( ::capnp::ReaderFor<Qux> value) {
  ::capnp::_::PointerHelpers<Qux>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::initQux() {
  return ::capnp::_::PointerHelpers<Qux>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnp::BuilderFor<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::initQux(unsigned int size) {
  return ::capnp::_::PointerHelpers<Qux>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::adoptQux(
    ::capnp::Orphan<Qux>&& value) {
  ::capnp::_::PointerHelpers<Qux>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline ::capnp::Orphan<Qux> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::disownQux() {
  return ::capnp::_::PointerHelpers<Qux>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Reader::hasGen() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Qux>
inline bool TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::hasGen() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Reader::getGen() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::getGen() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Pipeline::getGen() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::setGen( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
template <typename Qux>
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::initGen() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline void TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::adoptGen(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
template <typename Qux>
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::Builder::disownGen() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// TestGenerics<Foo, Bar>::Interface<Qux>::CallResults
template <typename Foo, typename Bar>
template <typename Qux>
constexpr uint16_t TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
template <typename Qux>
constexpr uint16_t TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Qux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
  { 0xc9e749e8dd54da5c, brandBindings + 2, 1, false},
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Interface<Qux>::CallResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a5b46224e33581ad, brandScopes, brandDependencies,
  2, 1, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults>)
TestGenerics<Foo, Bar>::Interface<Qux>::Client::callRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults>(
      0xc9e749e8dd54da5cull, 0, sizeHint);
}
template <typename Foo, typename Bar>
template <typename Qux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Interface<Qux>::Server::call(CallContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Interface", "call",
      0xc9e749e8dd54da5cull, 0);
}
template <typename Foo, typename Bar>
template <typename Qux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Interface<Qux>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xc9e749e8dd54da5cull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Interface", interfaceId);
  }
}
template <typename Foo, typename Bar>
template <typename Qux>
::kj::Promise<void> TestGenerics<Foo, Bar>::Interface<Qux>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return call(::capnp::Capability::Server::internalGetTypedContext<
          typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>, typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults>(context));
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "packages/capnpc-ts/test/integration/test.capnp:TestGenerics.Interface",
          0xc9e749e8dd54da5cull, methodId);
  }
}
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>::Interface<Qux>
#if !CAPNP_LITE
template <typename Foo, typename Bar>
template <typename Qux>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
template <typename Qux>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
  { 0xc9e749e8dd54da5c, brandBindings + 2, 1, false},
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
  ::capnp::_::brandBindingFor<Qux>(),
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::_capnpPrivate::brand() },
  { 50331648,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Interface<Qux>::CallResults::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
template <typename Qux>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Interface<Qux>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c9e749e8dd54da5c, brandScopes, brandDependencies,
  2, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Foo> TestGenerics<Foo, Bar>::UseAliases::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<Foo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::UseAliases::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<Foo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline  ::capnp::PipelineFor<Foo> TestGenerics<Foo, Bar>::UseAliases::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<Foo>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setFoo( ::capnp::ReaderFor<Foo> value) {
  ::capnp::_::PointerHelpers<Foo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::UseAliases::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenerics<Foo, Bar>::UseAliases::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptFoo(
    ::capnp::Orphan<Foo>&& value) {
  ::capnp::_::PointerHelpers<Foo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Foo> TestGenerics<Foo, Bar>::UseAliases::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<Foo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasInner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasInner() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader TestGenerics<Foo, Bar>::UseAliases::Reader::getInner() const {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::getInner() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline TestGenerics<Foo, Bar>::UseAliases::Pipeline::getInner() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setInner(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::initInner() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptInner(
    ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>&& value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner> TestGenerics<Foo, Bar>::UseAliases::Builder::disownInner() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasInner2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasInner2() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Reader TestGenerics<Foo, Bar>::UseAliases::Reader::getInner2() const {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::getInner2() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Pipeline TestGenerics<Foo, Bar>::UseAliases::Pipeline::getInner2() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setInner2(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::initInner2() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptInner2(
    ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
#ifndef _MSC_VER
// Excluded under MSVC because bugs may make it unable to compile this method.
template <typename Foo, typename Bar>
inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>> TestGenerics<Foo, Bar>::UseAliases::Builder::disownInner2() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !_MSC_VER

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasInner2Bind() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasInner2Bind() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader TestGenerics<Foo, Bar>::UseAliases::Reader::getInner2Bind() const {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::getInner2Bind() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline TestGenerics<Foo, Bar>::UseAliases::Pipeline::getInner2Bind() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setInner2Bind(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::initInner2Bind() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptInner2Bind(
    ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
#ifndef _MSC_VER
// Excluded under MSVC because bugs may make it unable to compile this method.
template <typename Foo, typename Bar>
inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>> TestGenerics<Foo, Bar>::UseAliases::Builder::disownInner2Bind() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#endif  // !_MSC_VER

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasInner2Text() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasInner2Text() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader TestGenerics<Foo, Bar>::UseAliases::Reader::getInner2Text() const {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::getInner2Text() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline TestGenerics<Foo, Bar>::UseAliases::Pipeline::getInner2Text() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setInner2Text(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::Builder TestGenerics<Foo, Bar>::UseAliases::Builder::initInner2Text() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptInner2Text(
    ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
#ifndef _MSC_VER
// Excluded under MSVC because bugs may make it unable to compile this method.
template <typename Foo, typename Bar>
inline ::capnp::Orphan<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>> TestGenerics<Foo, Bar>::UseAliases::Builder::disownInner2Text() {
  return ::capnp::_::PointerHelpers<typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#endif  // !_MSC_VER

template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Reader::hasRevFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenerics<Foo, Bar>::UseAliases::Builder::hasRevFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Bar> TestGenerics<Foo, Bar>::UseAliases::Reader::getRevFoo() const {
  return ::capnp::_::PointerHelpers<Bar>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::UseAliases::Builder::getRevFoo() {
  return ::capnp::_::PointerHelpers<Bar>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline  ::capnp::PipelineFor<Bar> TestGenerics<Foo, Bar>::UseAliases::Pipeline::getRevFoo() {
  return  ::capnp::PipelineFor<Bar>(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::setRevFoo( ::capnp::ReaderFor<Bar> value) {
  ::capnp::_::PointerHelpers<Bar>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::UseAliases::Builder::initRevFoo() {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenerics<Foo, Bar>::UseAliases::Builder::initRevFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::UseAliases::Builder::adoptRevFoo(
    ::capnp::Orphan<Bar>&& value) {
  ::capnp::_::PointerHelpers<Bar>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Bar> TestGenerics<Foo, Bar>::UseAliases::Builder::disownRevFoo() {
  return ::capnp::_::PointerHelpers<Bar>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

// TestGenerics<Foo, Bar>::UseAliases
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Inner::_capnpPrivate::brand() },
  { 16777218,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::AnyPointer>::_capnpPrivate::brand() },
  { 16777219,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::_capnpPrivate::brand() },
  { 16777220,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::template Inner2< ::capnp::Text>::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::UseAliases::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8e656edfb45ba6cf, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
inline  ::int32_t TestGenerics<Foo, Bar>::Ug::Reader::getUgfoo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename Foo, typename Bar>
inline  ::int32_t TestGenerics<Foo, Bar>::Ug::Builder::getUgfoo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename Foo, typename Bar>
inline void TestGenerics<Foo, Bar>::Ug::Builder::setUgfoo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

// TestGenerics<Foo, Bar>::Ug
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::Ug::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::Ug::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::Ug::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::Ug::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::Ug::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::Ug::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::Ug::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b46a779beaf3384e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// TestGenerics<Foo, Bar>
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenerics<Foo, Bar>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenerics<Foo, Bar>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenerics<Foo, Bar>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenerics<Foo, Bar>::_capnpPrivate::brandScopes[] = {
  { 0x9d5b8cd8de9922eb, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenerics<Foo, Bar>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Dependency TestGenerics<Foo, Bar>::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::capnproto_test::capnp::test::TestGenerics<Bar, Foo>::_capnpPrivate::brand() },
  { 16777219,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Ug::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenerics<Foo, Bar>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9d5b8cd8de9922eb, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
inline bool TestGenericsWrapper<Foo, Bar>::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenericsWrapper<Foo, Bar>::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Reader TestGenericsWrapper<Foo, Bar>::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Builder TestGenericsWrapper<Foo, Bar>::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Pipeline TestGenericsWrapper<Foo, Bar>::Pipeline::getValue() {
  return typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Foo, typename Bar>
inline void TestGenericsWrapper<Foo, Bar>::Builder::setValue(typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::Builder TestGenericsWrapper<Foo, Bar>::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenericsWrapper<Foo, Bar>::Builder::adoptValue(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>> TestGenericsWrapper<Foo, Bar>::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// TestGenericsWrapper<Foo, Bar>
template <typename Foo, typename Bar>
constexpr uint16_t TestGenericsWrapper<Foo, Bar>::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenericsWrapper<Foo, Bar>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenericsWrapper<Foo, Bar>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenericsWrapper<Foo, Bar>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenericsWrapper<Foo, Bar>::_capnpPrivate::brandScopes[] = {
  { 0xa9b2b1f52dde845d, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenericsWrapper<Foo, Bar>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Dependency TestGenericsWrapper<Foo, Bar>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::capnproto_test::capnp::test::TestGenerics<Foo, Bar>::_capnpPrivate::brand() },
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenericsWrapper<Foo, Bar>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a9b2b1f52dde845d, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

inline bool TestGenericsWrapper2::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestGenericsWrapper2::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader TestGenericsWrapper2::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder TestGenericsWrapper2::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline TestGenericsWrapper2::Pipeline::getValue() {
  return  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestGenericsWrapper2::Builder::setValue( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder TestGenericsWrapper2::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestGenericsWrapper2::Builder::adoptValue(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>> TestGenericsWrapper2::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline TestImplicitMethodParams::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestImplicitMethodParams::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestImplicitMethodParams::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestImplicitMethodParams::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestImplicitMethodParams::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestImplicitMethodParams::Client& TestImplicitMethodParams::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestImplicitMethodParams::Client& TestImplicitMethodParams::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

template <typename T, typename U>
::capnp::Request< ::capnproto_test::capnp::test::TestImplicitMethodParams::CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>>
TestImplicitMethodParams::Client::callRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall< ::capnproto_test::capnp::test::TestImplicitMethodParams::CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>>(
      0x8b9717a3f8d85a9aull, 0, sizeHint);
}
#endif  // !CAPNP_LITE
template <typename T, typename U>
inline bool TestImplicitMethodParams::CallParams<T, U>::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T, typename U>
inline bool TestImplicitMethodParams::CallParams<T, U>::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T, typename U>
inline  ::capnp::ReaderFor<T> TestImplicitMethodParams::CallParams<T, U>::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParams::CallParams<T, U>::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T, typename U>
inline  ::capnp::PipelineFor<T> TestImplicitMethodParams::CallParams<T, U>::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename T, typename U>
inline void TestImplicitMethodParams::CallParams<T, U>::Builder::setFoo( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParams::CallParams<T, U>::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParams::CallParams<T, U>::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T, typename U>
inline void TestImplicitMethodParams::CallParams<T, U>::Builder::adoptFoo(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T, typename U>
inline ::capnp::Orphan<T> TestImplicitMethodParams::CallParams<T, U>::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename T, typename U>
inline bool TestImplicitMethodParams::CallParams<T, U>::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T, typename U>
inline bool TestImplicitMethodParams::CallParams<T, U>::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename T, typename U>
inline  ::capnp::ReaderFor<U> TestImplicitMethodParams::CallParams<T, U>::Reader::getBar() const {
  return ::capnp::_::PointerHelpers<U>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParams::CallParams<T, U>::Builder::getBar() {
  return ::capnp::_::PointerHelpers<U>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T, typename U>
inline  ::capnp::PipelineFor<U> TestImplicitMethodParams::CallParams<T, U>::Pipeline::getBar() {
  return  ::capnp::PipelineFor<U>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename T, typename U>
inline void TestImplicitMethodParams::CallParams<T, U>::Builder::setBar( ::capnp::ReaderFor<U> value) {
  ::capnp::_::PointerHelpers<U>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParams::CallParams<T, U>::Builder::initBar() {
  return ::capnp::_::PointerHelpers<U>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParams::CallParams<T, U>::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers<U>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename T, typename U>
inline void TestImplicitMethodParams::CallParams<T, U>::Builder::adoptBar(
    ::capnp::Orphan<U>&& value) {
  ::capnp::_::PointerHelpers<U>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T, typename U>
inline ::capnp::Orphan<U> TestImplicitMethodParams::CallParams<T, U>::Builder::disownBar() {
  return ::capnp::_::PointerHelpers<U>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// TestImplicitMethodParams::CallParams<T, U>
template <typename T, typename U>
constexpr uint16_t TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::dataWordSize;
template <typename T, typename U>
constexpr uint16_t TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T, typename U>
constexpr ::capnp::Kind TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::kind;
template <typename T, typename U>
constexpr ::capnp::_::RawSchema const* TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::schema;
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema::Scope TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::brandScopes[] = {
  { 0xf83f8caf54bdc486, brandBindings + 0, 2, false},
};
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema::Binding TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
  ::capnp::_::brandBindingFor<U>(),
};
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema TestImplicitMethodParams::CallParams<T, U>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f83f8caf54bdc486, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline TestImplicitMethodParamsInGeneric<V>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline TestImplicitMethodParamsInGeneric<V>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline TestImplicitMethodParamsInGeneric<V>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline TestImplicitMethodParamsInGeneric<V>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline TestImplicitMethodParamsInGeneric<V>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::Client& TestImplicitMethodParamsInGeneric<V>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::Client& TestImplicitMethodParamsInGeneric<V>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

template <typename V>
template <typename T, typename U>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>>)
TestImplicitMethodParamsInGeneric<V>::Client::callRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<T, U>,  ::capnproto_test::capnp::test::TestGenerics<T, U>>(
      0xdf9ccdeb81a704c9ull, 0, sizeHint);
}
#endif  // !CAPNP_LITE
template <typename V>
template <typename T, typename U>
inline bool TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Reader::hasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
template <typename T, typename U>
inline bool TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::hasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::ReaderFor<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Reader::getFoo() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::getFoo() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename V>
template <typename T, typename U>
inline  ::capnp::PipelineFor<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Pipeline::getFoo() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename V>
template <typename T, typename U>
inline void TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::setFoo( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::initFoo() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::initFoo(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename V>
template <typename T, typename U>
inline void TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::adoptFoo(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
template <typename T, typename U>
inline ::capnp::Orphan<T> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::disownFoo() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
template <typename T, typename U>
inline bool TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Reader::hasBar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
template <typename T, typename U>
inline bool TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::hasBar() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::ReaderFor<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Reader::getBar() const {
  return ::capnp::_::PointerHelpers<U>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::getBar() {
  return ::capnp::_::PointerHelpers<U>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename V>
template <typename T, typename U>
inline  ::capnp::PipelineFor<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Pipeline::getBar() {
  return  ::capnp::PipelineFor<U>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename V>
template <typename T, typename U>
inline void TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::setBar( ::capnp::ReaderFor<U> value) {
  ::capnp::_::PointerHelpers<U>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::initBar() {
  return ::capnp::_::PointerHelpers<U>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
template <typename T, typename U>
inline  ::capnp::BuilderFor<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::initBar(unsigned int size) {
  return ::capnp::_::PointerHelpers<U>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename V>
template <typename T, typename U>
inline void TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::adoptBar(
    ::capnp::Orphan<U>&& value) {
  ::capnp::_::PointerHelpers<U>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
template <typename T, typename U>
inline ::capnp::Orphan<U> TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::Builder::disownBar() {
  return ::capnp::_::PointerHelpers<U>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>
template <typename V>
template <typename T, typename U>
constexpr uint16_t TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::dataWordSize;
template <typename V>
template <typename T, typename U>
constexpr uint16_t TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
template <typename T, typename U>
constexpr ::capnp::Kind TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::kind;
template <typename V>
template <typename T, typename U>
constexpr ::capnp::_::RawSchema const* TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::schema;
template <typename V>
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema::Scope TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::brandScopes[] = {
  { 0x9aab8e25c808d71e, brandBindings + 0, 2, false},
  { 0xdf9ccdeb81a704c9, brandBindings + 2, 1, false},
};
template <typename V>
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema::Binding TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
  ::capnp::_::brandBindingFor<U>(),
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
template <typename T, typename U>
const ::capnp::_::RawBrandedSchema TestImplicitMethodParamsInGeneric<V>::CallParams<T, U>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9aab8e25c808d71e, brandScopes, nullptr,
  2, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
::kj::Promise<void> TestImplicitMethodParamsInGeneric<V>::Server::call(CallContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "packages/capnpc-ts/test/integration/test.capnp:TestImplicitMethodParamsInGeneric", "call",
      0xdf9ccdeb81a704c9ull, 0);
}
template <typename V>
::kj::Promise<void> TestImplicitMethodParamsInGeneric<V>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xdf9ccdeb81a704c9ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("packages/capnpc-ts/test/integration/test.capnp:TestImplicitMethodParamsInGeneric", interfaceId);
  }
}
template <typename V>
::kj::Promise<void> TestImplicitMethodParamsInGeneric<V>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return call(::capnp::Capability::Server::internalGetTypedContext<
          typename  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<>,  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>(context));
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "packages/capnpc-ts/test/integration/test.capnp:TestImplicitMethodParamsInGeneric",
          0xdf9ccdeb81a704c9ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// TestImplicitMethodParamsInGeneric<V>
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::brandScopes[] = {
  { 0xdf9ccdeb81a704c9, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::capnproto_test::capnp::test::TestImplicitMethodParamsInGeneric<V>::template CallParams<>::_capnpPrivate::brand() },
  { 50331648,  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema TestImplicitMethodParamsInGeneric<V>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_df9ccdeb81a704c9, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenericsUnion<Foo, Bar>::Which TestGenericsUnion<Foo, Bar>::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Foo, typename Bar>
inline typename  ::capnproto_test::capnp::test::TestGenericsUnion<Foo, Bar>::Which TestGenericsUnion<Foo, Bar>::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Reader::isFoo() const {
  return which() == TestGenericsUnion<Foo, Bar>::FOO;
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Builder::isFoo() {
  return which() == TestGenericsUnion<Foo, Bar>::FOO;
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Reader::hasFoo() const {
  if (which() != TestGenericsUnion<Foo, Bar>::FOO) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Builder::hasFoo() {
  if (which() != TestGenericsUnion<Foo, Bar>::FOO) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Foo> TestGenericsUnion<Foo, Bar>::Reader::getFoo() const {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::FOO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Foo>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenericsUnion<Foo, Bar>::Builder::getFoo() {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::FOO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Foo>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenericsUnion<Foo, Bar>::Builder::setFoo( ::capnp::ReaderFor<Foo> value) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::FOO);
  ::capnp::_::PointerHelpers<Foo>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenericsUnion<Foo, Bar>::Builder::initFoo() {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::FOO);
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Foo> TestGenericsUnion<Foo, Bar>::Builder::initFoo(unsigned int size) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::FOO);
  return ::capnp::_::PointerHelpers<Foo>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenericsUnion<Foo, Bar>::Builder::adoptFoo(
    ::capnp::Orphan<Foo>&& value) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::FOO);
  ::capnp::_::PointerHelpers<Foo>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Foo> TestGenericsUnion<Foo, Bar>::Builder::disownFoo() {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::FOO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Foo>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Reader::isBar() const {
  return which() == TestGenericsUnion<Foo, Bar>::BAR;
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Builder::isBar() {
  return which() == TestGenericsUnion<Foo, Bar>::BAR;
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Reader::hasBar() const {
  if (which() != TestGenericsUnion<Foo, Bar>::BAR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline bool TestGenericsUnion<Foo, Bar>::Builder::hasBar() {
  if (which() != TestGenericsUnion<Foo, Bar>::BAR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Foo, typename Bar>
inline  ::capnp::ReaderFor<Bar> TestGenericsUnion<Foo, Bar>::Reader::getBar() const {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::BAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Bar>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenericsUnion<Foo, Bar>::Builder::getBar() {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::BAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Bar>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline void TestGenericsUnion<Foo, Bar>::Builder::setBar( ::capnp::ReaderFor<Bar> value) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::BAR);
  ::capnp::_::PointerHelpers<Bar>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenericsUnion<Foo, Bar>::Builder::initBar() {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::BAR);
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Foo, typename Bar>
inline  ::capnp::BuilderFor<Bar> TestGenericsUnion<Foo, Bar>::Builder::initBar(unsigned int size) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::BAR);
  return ::capnp::_::PointerHelpers<Bar>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Foo, typename Bar>
inline void TestGenericsUnion<Foo, Bar>::Builder::adoptBar(
    ::capnp::Orphan<Bar>&& value) {
  _builder.setDataField<TestGenericsUnion<Foo, Bar>::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, TestGenericsUnion<Foo, Bar>::BAR);
  ::capnp::_::PointerHelpers<Bar>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Foo, typename Bar>
inline ::capnp::Orphan<Bar> TestGenericsUnion<Foo, Bar>::Builder::disownBar() {
  KJ_IREQUIRE((which() == TestGenericsUnion<Foo, Bar>::BAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<Bar>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// TestGenericsUnion<Foo, Bar>
template <typename Foo, typename Bar>
constexpr uint16_t TestGenericsUnion<Foo, Bar>::_capnpPrivate::dataWordSize;
template <typename Foo, typename Bar>
constexpr uint16_t TestGenericsUnion<Foo, Bar>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Foo, typename Bar>
constexpr ::capnp::Kind TestGenericsUnion<Foo, Bar>::_capnpPrivate::kind;
template <typename Foo, typename Bar>
constexpr ::capnp::_::RawSchema const* TestGenericsUnion<Foo, Bar>::_capnpPrivate::schema;
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Scope TestGenericsUnion<Foo, Bar>::_capnpPrivate::brandScopes[] = {
  { 0xa54870440e919063, brandBindings + 0, 2, false},
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema::Binding TestGenericsUnion<Foo, Bar>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Foo>(),
  ::capnp::_::brandBindingFor<Bar>(),
};
template <typename Foo, typename Bar>
const ::capnp::_::RawBrandedSchema TestGenericsUnion<Foo, Bar>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a54870440e919063, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

inline bool TestUseGenerics::Reader::hasBasic() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasBasic() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader TestUseGenerics::Reader::getBasic() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestUseGenerics::Builder::getBasic() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline TestUseGenerics::Pipeline::getBasic() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setBasic( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestUseGenerics::Builder::initBasic() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptBasic(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> TestUseGenerics::Builder::disownBasic() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasInner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasInner() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader TestUseGenerics::Reader::getInner() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder TestUseGenerics::Builder::getInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline TestUseGenerics::Pipeline::getInner() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder TestUseGenerics::Builder::initInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptInner(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner> TestUseGenerics::Builder::disownInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasInner2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasInner2() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader TestUseGenerics::Reader::getInner2() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::getInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline TestUseGenerics::Pipeline::getInner2() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setInner2( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::initInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptInner2(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>> TestUseGenerics::Builder::disownInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasUnspecified() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasUnspecified() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Reader TestUseGenerics::Reader::getUnspecified() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Builder TestUseGenerics::Builder::getUnspecified() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Pipeline TestUseGenerics::Pipeline::getUnspecified() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setUnspecified( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Builder TestUseGenerics::Builder::initUnspecified() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptUnspecified(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>> TestUseGenerics::Builder::disownUnspecified() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasUnspecifiedInner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasUnspecifiedInner() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Reader TestUseGenerics::Reader::getUnspecifiedInner() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::getUnspecifiedInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Pipeline TestUseGenerics::Pipeline::getUnspecifiedInner() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setUnspecifiedInner( ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::initUnspecifiedInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptUnspecifiedInner(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>> TestUseGenerics::Builder::disownUnspecifiedInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnp::AnyPointer,  ::capnp::AnyPointer>::Inner2< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasDefault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasDefault() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Reader TestUseGenerics::Reader::getDefault() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 332);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Builder TestUseGenerics::Builder::getDefault() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 332);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Pipeline TestUseGenerics::Pipeline::getDefault() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setDefault( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Builder TestUseGenerics::Builder::initDefault() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptDefault(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>> TestUseGenerics::Builder::disownDefault() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasDefaultInner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasDefaultInner() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Reader TestUseGenerics::Reader::getDefaultInner() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 421);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Builder TestUseGenerics::Builder::getDefaultInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 421);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Pipeline TestUseGenerics::Pipeline::getDefaultInner() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setDefaultInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner::Builder TestUseGenerics::Builder::initDefaultInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptDefaultInner(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner> TestUseGenerics::Builder::disownDefaultInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::Text>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasDefaultUser() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasDefaultUser() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestUseGenerics::Reader TestUseGenerics::Reader::getDefaultUser() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 459);
}
inline  ::capnproto_test::capnp::test::TestUseGenerics::Builder TestUseGenerics::Builder::getDefaultUser() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 459);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestUseGenerics::Pipeline TestUseGenerics::Pipeline::getDefaultUser() {
  return  ::capnproto_test::capnp::test::TestUseGenerics::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setDefaultUser( ::capnproto_test::capnp::test::TestUseGenerics::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestUseGenerics::Builder TestUseGenerics::Builder::initDefaultUser() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptDefaultUser(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestUseGenerics>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestUseGenerics> TestUseGenerics::Builder::disownDefaultUser() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestUseGenerics>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasWrapper() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasWrapper() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader TestUseGenerics::Reader::getWrapper() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestUseGenerics::Builder::getWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline TestUseGenerics::Pipeline::getWrapper() {
  return  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setWrapper( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Builder TestUseGenerics::Builder::initWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptWrapper(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>> TestUseGenerics::Builder::disownWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasDefaultWrapper() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasDefaultWrapper() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader TestUseGenerics::Reader::getDefaultWrapper() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 561);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder TestUseGenerics::Builder::getDefaultWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 561);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline TestUseGenerics::Pipeline::getDefaultWrapper() {
  return  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setDefaultWrapper( ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>::Builder TestUseGenerics::Builder::initDefaultWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptDefaultWrapper(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>> TestUseGenerics::Builder::disownDefaultWrapper() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper< ::capnp::Text,  ::capnproto_test::capnp::test::TestAllTypes>>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasDefaultWrapper2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasDefaultWrapper2() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Reader TestUseGenerics::Reader::getDefaultWrapper2() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 604);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Builder TestUseGenerics::Builder::getDefaultWrapper2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 604);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Pipeline TestUseGenerics::Pipeline::getDefaultWrapper2() {
  return  ::capnproto_test::capnp::test::TestGenericsWrapper2::Pipeline(_typeless.getPointerField(10));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setDefaultWrapper2( ::capnproto_test::capnp::test::TestGenericsWrapper2::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenericsWrapper2::Builder TestUseGenerics::Builder::initDefaultWrapper2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptDefaultWrapper2(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper2>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenericsWrapper2> TestUseGenerics::Builder::disownDefaultWrapper2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenericsWrapper2>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasFoo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasFoo() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Reader TestUseGenerics::Reader::getAliasFoo() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 648);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestUseGenerics::Builder::getAliasFoo() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 648);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline TestUseGenerics::Pipeline::getAliasFoo() {
  return  ::capnproto_test::capnp::test::TestAllTypes::Pipeline(_typeless.getPointerField(11));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setAliasFoo( ::capnproto_test::capnp::test::TestAllTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestUseGenerics::Builder::initAliasFoo() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptAliasFoo(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> TestUseGenerics::Builder::disownAliasFoo() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasInner() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasInner() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader TestUseGenerics::Reader::getAliasInner() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 701);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder TestUseGenerics::Builder::getAliasInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 701);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline TestUseGenerics::Pipeline::getAliasInner() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Pipeline(_typeless.getPointerField(12));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setAliasInner( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner::Builder TestUseGenerics::Builder::initAliasInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptAliasInner(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner> TestUseGenerics::Builder::disownAliasInner() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasInner2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasInner2() {
  return !_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Reader TestUseGenerics::Reader::getAliasInner2() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 756);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Builder TestUseGenerics::Builder::getAliasInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 756);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Pipeline TestUseGenerics::Pipeline::getAliasInner2() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Pipeline(_typeless.getPointerField(13));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setAliasInner2( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>::Builder TestUseGenerics::Builder::initAliasInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::init(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptAliasInner2(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>> TestUseGenerics::Builder::disownAliasInner2() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasInner2Bind() const {
  return !_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasInner2Bind() {
  return !_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Reader TestUseGenerics::Reader::getAliasInner2Bind() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::get(_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 829);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Builder TestUseGenerics::Builder::getAliasInner2Bind() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::get(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 829);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Pipeline TestUseGenerics::Pipeline::getAliasInner2Bind() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Pipeline(_typeless.getPointerField(14));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setAliasInner2Bind( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>::Builder TestUseGenerics::Builder::initAliasInner2Bind() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::init(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptAliasInner2Bind(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>> TestUseGenerics::Builder::disownAliasInner2Bind() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::List< ::uint32_t>>>::disown(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasInner2Text() const {
  return !_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasInner2Text() {
  return !_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader TestUseGenerics::Reader::getAliasInner2Text() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 899);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::getAliasInner2Text() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 899);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline TestUseGenerics::Pipeline::getAliasInner2Text() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Pipeline(_typeless.getPointerField(15));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setAliasInner2Text( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>::Builder TestUseGenerics::Builder::initAliasInner2Text() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptAliasInner2Text(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>> TestUseGenerics::Builder::disownAliasInner2Text() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnproto_test::capnp::test::TestAnyPointer>::Inner2< ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasAliasRev() const {
  return !_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasAliasRev() {
  return !_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestUseGenerics::Reader::getAliasRev() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 942, 4);
}
inline  ::capnp::Text::Builder TestUseGenerics::Builder::getAliasRev() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 942, 4);
}
inline void TestUseGenerics::Builder::setAliasRev( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestUseGenerics::Builder::initAliasRev(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), size);
}
inline void TestUseGenerics::Builder::adoptAliasRev(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestUseGenerics::Builder::disownAliasRev() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<16>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasUseAliases() const {
  return !_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasUseAliases() {
  return !_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Reader TestUseGenerics::Reader::getUseAliases() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::get(_reader.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 973);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Builder TestUseGenerics::Builder::getUseAliases() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::get(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9427b2a71030338f + 973);
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Pipeline TestUseGenerics::Pipeline::getUseAliases() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Pipeline(_typeless.getPointerField(17));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setUseAliases( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::set(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases::Builder TestUseGenerics::Builder::initUseAliases() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::init(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptUseAliases(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::adopt(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases> TestUseGenerics::Builder::disownUseAliases() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::UseAliases>::disown(_builder.getPointerField(
      ::capnp::bounded<17>() * ::capnp::POINTERS));
}

inline bool TestUseGenerics::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Reader TestUseGenerics::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Builder TestUseGenerics::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Pipeline TestUseGenerics::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Pipeline(_typeless.getPointerField(18));
}
#endif  // !CAPNP_LITE
inline void TestUseGenerics::Builder::setCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>::Builder TestUseGenerics::Builder::initCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
inline void TestUseGenerics::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>> TestUseGenerics::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestInterface,  ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<18>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestUseGenerics::Reader::hasGenericCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
inline bool TestUseGenerics::Builder::hasGenericCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client TestUseGenerics::Reader::getGenericCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::get(_reader.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client TestUseGenerics::Builder::getGenericCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::get(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client TestUseGenerics::Pipeline::getGenericCap() {
  return  ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client(_typeless.getPointerField(19).asCap());
}
inline void TestUseGenerics::Builder::setGenericCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestUseGenerics::Builder::setGenericCap( ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::set(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), cap);
}
inline void TestUseGenerics::Builder::adoptGenericCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::adopt(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>> TestUseGenerics::Builder::disownGenericCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestGenerics< ::capnproto_test::capnp::test::TestAllTypes,  ::capnp::List< ::uint32_t>>::Interface< ::capnp::Data>>::disown(_builder.getPointerField(
      ::capnp::bounded<19>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestAnyPointerConstants::Reader::hasAnyKindAsStruct() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyPointerConstants::Builder::hasAnyKindAsStruct() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader TestAnyPointerConstants::Reader::getAnyKindAsStruct() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointerConstants::Builder::getAnyKindAsStruct() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointerConstants::Builder::initAnyKindAsStruct() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool TestAnyPointerConstants::Reader::hasAnyStructAsStruct() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyPointerConstants::Builder::hasAnyStructAsStruct() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyStruct::Reader TestAnyPointerConstants::Reader::getAnyStructAsStruct() const {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyStruct::Builder TestAnyPointerConstants::Builder::getAnyStructAsStruct() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::AnyStruct::Pipeline TestAnyPointerConstants::Pipeline::getAnyStructAsStruct() {
  return  ::capnp::AnyStruct::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestAnyPointerConstants::Builder::setAnyStructAsStruct( ::capnp::AnyStruct::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> TestAnyPointerConstants::Builder::initAnyStructAsStructAs() {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::STRUCT,
                "anyStructAsStruct must be a struct");
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestAnyPointerConstants::Builder::adoptAnyStructAsStruct(
    ::capnp::Orphan< ::capnp::AnyStruct>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyStruct> TestAnyPointerConstants::Builder::disownAnyStructAsStruct() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestAnyPointerConstants::Reader::hasAnyKindAsList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyPointerConstants::Builder::hasAnyKindAsList() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader TestAnyPointerConstants::Reader::getAnyKindAsList() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointerConstants::Builder::getAnyKindAsList() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestAnyPointerConstants::Builder::initAnyKindAsList() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool TestAnyPointerConstants::Reader::hasAnyListAsList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TestAnyPointerConstants::Builder::hasAnyListAsList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyList::Reader TestAnyPointerConstants::Reader::getAnyListAsList() const {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyList::Builder TestAnyPointerConstants::Builder::getAnyListAsList() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TestAnyPointerConstants::Builder::setAnyListAsList( ::capnp::AnyList::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyList>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> TestAnyPointerConstants::Builder::initAnyListAsListAs(unsigned int size) {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::LIST,
                "anyListAsList must be a list");
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TestAnyPointerConstants::Builder::adoptAnyListAsList(
    ::capnp::Orphan< ::capnp::AnyList>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::AnyList>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyList> TestAnyPointerConstants::Builder::disownAnyListAsList() {
  return ::capnp::_::PointerHelpers< ::capnp::AnyList>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline TestInterface::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestInterface::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestInterface::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestInterface::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestInterface::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestInterface::Client& TestInterface::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestInterface::Client& TestInterface::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t TestInterface::FooParams::Reader::getI() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestInterface::FooParams::Builder::getI() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestInterface::FooParams::Builder::setI( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterface::FooParams::Reader::getJ() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool TestInterface::FooParams::Builder::getJ() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void TestInterface::FooParams::Builder::setJ(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool TestInterface::FooResults::Reader::hasX() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterface::FooResults::Builder::hasX() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestInterface::FooResults::Reader::getX() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestInterface::FooResults::Builder::getX() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestInterface::FooResults::Builder::setX( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestInterface::FooResults::Builder::initX(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestInterface::FooResults::Builder::adoptX(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestInterface::FooResults::Builder::disownX() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestInterface::BazParams::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestInterface::BazParams::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Reader TestInterface::BazParams::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestInterface::BazParams::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestAllTypes::Pipeline TestInterface::BazParams::Pipeline::getS() {
  return  ::capnproto_test::capnp::test::TestAllTypes::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestInterface::BazParams::Builder::setS( ::capnproto_test::capnp::test::TestAllTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestAllTypes::Builder TestInterface::BazParams::Builder::initS() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestInterface::BazParams::Builder::adoptS(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestAllTypes> TestInterface::BazParams::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestAllTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline TestExtends::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestExtends::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestExtends::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestExtends::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestExtends::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestExtends::Client& TestExtends::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestExtends::Client& TestExtends::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline TestExtends2::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestExtends2::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestExtends2::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestExtends2::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestExtends2::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestExtends2::Client& TestExtends2::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestExtends2::Client& TestExtends2::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline TestPipeline::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestPipeline::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestPipeline::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestPipeline::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestPipeline::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestPipeline::Client& TestPipeline::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestPipeline::Client& TestPipeline::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool TestPipeline::Box::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::Box::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::Box::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::Box::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::Box::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestPipeline::Box::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestPipeline::Box::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestPipeline::Box::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestPipeline::Box::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestPipeline::AnyBox::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::AnyBox::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client TestPipeline::AnyBox::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestPipeline::AnyBox::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestPipeline::AnyBox::Pipeline::getCap() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
inline void TestPipeline::AnyBox::Builder::setCap( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestPipeline::AnyBox::Builder::setCap( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestPipeline::AnyBox::Builder::adoptCap(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> TestPipeline::AnyBox::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint32_t TestPipeline::GetCapParams::Reader::getN() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestPipeline::GetCapParams::Builder::getN() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestPipeline::GetCapParams::Builder::setN( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestPipeline::GetCapParams::Reader::hasInCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetCapParams::Builder::hasInCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::GetCapParams::Reader::getInCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::GetCapParams::Builder::getInCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::GetCapParams::Pipeline::getInCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestPipeline::GetCapParams::Builder::setInCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestPipeline::GetCapParams::Builder::setInCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestPipeline::GetCapParams::Builder::adoptInCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestPipeline::GetCapParams::Builder::disownInCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestPipeline::GetCapResults::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetCapResults::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestPipeline::GetCapResults::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestPipeline::GetCapResults::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestPipeline::GetCapResults::Builder::setS( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestPipeline::GetCapResults::Builder::initS(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestPipeline::GetCapResults::Builder::adoptS(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestPipeline::GetCapResults::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestPipeline::GetCapResults::Reader::hasOutBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetCapResults::Builder::hasOutBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestPipeline::Box::Reader TestPipeline::GetCapResults::Reader::getOutBox() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestPipeline::Box::Builder TestPipeline::GetCapResults::Builder::getOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestPipeline::Box::Pipeline TestPipeline::GetCapResults::Pipeline::getOutBox() {
  return  ::capnproto_test::capnp::test::TestPipeline::Box::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestPipeline::GetCapResults::Builder::setOutBox( ::capnproto_test::capnp::test::TestPipeline::Box::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestPipeline::Box::Builder TestPipeline::GetCapResults::Builder::initOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestPipeline::GetCapResults::Builder::adoptOutBox(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::Box>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::Box> TestPipeline::GetCapResults::Builder::disownOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::Box>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestPipeline::TestPointersParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::TestPointersParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::TestPointersParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::TestPointersParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestPipeline::TestPointersParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestPipeline::TestPointersParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestPipeline::TestPointersParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestPipeline::TestPointersParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestPipeline::TestPointersParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestPipeline::TestPointersParams::Reader::hasObj() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::TestPointersParams::Builder::hasObj() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader TestPipeline::TestPointersParams::Reader::getObj() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestPipeline::TestPointersParams::Builder::getObj() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestPipeline::TestPointersParams::Builder::initObj() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool TestPipeline::TestPointersParams::Reader::hasList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::TestPointersParams::Builder::hasList() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Reader TestPipeline::TestPointersParams::Reader::getList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Builder TestPipeline::TestPointersParams::Builder::getList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TestPipeline::TestPointersParams::Builder::setList( ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestInterface>::Builder TestPipeline::TestPointersParams::Builder::initList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TestPipeline::TestPointersParams::Builder::adoptList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>> TestPipeline::TestPointersParams::Builder::disownList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestInterface>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint32_t TestPipeline::GetAnyCapParams::Reader::getN() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestPipeline::GetAnyCapParams::Builder::getN() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestPipeline::GetAnyCapParams::Builder::setN( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestPipeline::GetAnyCapParams::Reader::hasInCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetAnyCapParams::Builder::hasInCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client TestPipeline::GetAnyCapParams::Reader::getInCap() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestPipeline::GetAnyCapParams::Builder::getInCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client TestPipeline::GetAnyCapParams::Pipeline::getInCap() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
inline void TestPipeline::GetAnyCapParams::Builder::setInCap( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestPipeline::GetAnyCapParams::Builder::setInCap( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestPipeline::GetAnyCapParams::Builder::adoptInCap(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> TestPipeline::GetAnyCapParams::Builder::disownInCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestPipeline::GetAnyCapResults::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetAnyCapResults::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestPipeline::GetAnyCapResults::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestPipeline::GetAnyCapResults::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestPipeline::GetAnyCapResults::Builder::setS( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestPipeline::GetAnyCapResults::Builder::initS(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestPipeline::GetAnyCapResults::Builder::adoptS(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestPipeline::GetAnyCapResults::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestPipeline::GetAnyCapResults::Reader::hasOutBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestPipeline::GetAnyCapResults::Builder::hasOutBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Reader TestPipeline::GetAnyCapResults::Reader::getOutBox() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Builder TestPipeline::GetAnyCapResults::Builder::getOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Pipeline TestPipeline::GetAnyCapResults::Pipeline::getOutBox() {
  return  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TestPipeline::GetAnyCapResults::Builder::setOutBox( ::capnproto_test::capnp::test::TestPipeline::AnyBox::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestPipeline::AnyBox::Builder TestPipeline::GetAnyCapResults::Builder::initOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestPipeline::GetAnyCapResults::Builder::adoptOutBox(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::AnyBox>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestPipeline::AnyBox> TestPipeline::GetAnyCapResults::Builder::disownOutBox() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestPipeline::AnyBox>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline TestCallOrder::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestCallOrder::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestCallOrder::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestCallOrder::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestCallOrder::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client& TestCallOrder::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client& TestCallOrder::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t TestCallOrder::GetCallSequenceParams::Reader::getExpected() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestCallOrder::GetCallSequenceParams::Builder::getExpected() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestCallOrder::GetCallSequenceParams::Builder::setExpected( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TestCallOrder::GetCallSequenceResults::Reader::getN() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestCallOrder::GetCallSequenceResults::Builder::getN() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestCallOrder::GetCallSequenceResults::Builder::setN( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline TestTailCallee::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestTailCallee::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestTailCallee::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestTailCallee::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestTailCallee::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestTailCallee::Client& TestTailCallee::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestTailCallee::Client& TestTailCallee::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t TestTailCallee::TailResult::Reader::getI() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TestTailCallee::TailResult::Builder::getI() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestTailCallee::TailResult::Builder::setI( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestTailCallee::TailResult::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestTailCallee::TailResult::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestTailCallee::TailResult::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestTailCallee::TailResult::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestTailCallee::TailResult::Builder::setT( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestTailCallee::TailResult::Builder::initT(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestTailCallee::TailResult::Builder::adoptT(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestTailCallee::TailResult::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestTailCallee::TailResult::Reader::hasC() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestTailCallee::TailResult::Builder::hasC() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestTailCallee::TailResult::Reader::getC() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestTailCallee::TailResult::Builder::getC() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestTailCallee::TailResult::Pipeline::getC() {
  return  ::capnproto_test::capnp::test::TestCallOrder::Client(_typeless.getPointerField(1).asCap());
}
inline void TestTailCallee::TailResult::Builder::setC( ::capnproto_test::capnp::test::TestCallOrder::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestTailCallee::TailResult::Builder::setC( ::capnproto_test::capnp::test::TestCallOrder::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void TestTailCallee::TailResult::Builder::adoptC(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> TestTailCallee::TailResult::Builder::disownC() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int32_t TestTailCallee::FooParams::Reader::getI() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestTailCallee::FooParams::Builder::getI() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestTailCallee::FooParams::Builder::setI( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestTailCallee::FooParams::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestTailCallee::FooParams::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestTailCallee::FooParams::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestTailCallee::FooParams::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestTailCallee::FooParams::Builder::setT( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestTailCallee::FooParams::Builder::initT(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestTailCallee::FooParams::Builder::adoptT(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestTailCallee::FooParams::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline TestTailCaller::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestTailCaller::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestTailCaller::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestTailCaller::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestTailCaller::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestTailCaller::Client& TestTailCaller::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestTailCaller::Client& TestTailCaller::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::int32_t TestTailCaller::FooParams::Reader::getI() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t TestTailCaller::FooParams::Builder::getI() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestTailCaller::FooParams::Builder::setI( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestTailCaller::FooParams::Reader::hasCallee() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestTailCaller::FooParams::Builder::hasCallee() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestTailCallee::Client TestTailCaller::FooParams::Reader::getCallee() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestTailCallee::Client TestTailCaller::FooParams::Builder::getCallee() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestTailCallee::Client TestTailCaller::FooParams::Pipeline::getCallee() {
  return  ::capnproto_test::capnp::test::TestTailCallee::Client(_typeless.getPointerField(0).asCap());
}
inline void TestTailCaller::FooParams::Builder::setCallee( ::capnproto_test::capnp::test::TestTailCallee::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestTailCaller::FooParams::Builder::setCallee( ::capnproto_test::capnp::test::TestTailCallee::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestTailCaller::FooParams::Builder::adoptCallee(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestTailCallee>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestTailCallee> TestTailCaller::FooParams::Builder::disownCallee() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestTailCallee>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline TestHandle::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestHandle::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestHandle::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestHandle::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestHandle::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestHandle::Client& TestHandle::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestHandle::Client& TestHandle::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline TestMoreStuff::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestMoreStuff::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestMoreStuff::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestMoreStuff::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestMoreStuff::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestMoreStuff::Client& TestMoreStuff::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestMoreStuff::Client& TestMoreStuff::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool TestMoreStuff::CallFooParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::CallFooParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::CallFooParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::CallFooParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::CallFooParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::CallFooParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::CallFooResults::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::CallFooResults::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::CallFooResults::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::CallFooResults::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::CallFooResults::Builder::setS( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::CallFooResults::Builder::initS(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::CallFooResults::Builder::adoptS(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::CallFooResults::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::CallFooWhenResolvedParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::CallFooWhenResolvedParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooWhenResolvedParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooWhenResolvedParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::CallFooWhenResolvedParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::CallFooWhenResolvedParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::CallFooWhenResolvedParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::CallFooWhenResolvedParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::CallFooWhenResolvedParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::CallFooWhenResolvedResults::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::CallFooWhenResolvedResults::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::CallFooWhenResolvedResults::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::CallFooWhenResolvedResults::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::CallFooWhenResolvedResults::Builder::setS( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::CallFooWhenResolvedResults::Builder::initS(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::CallFooWhenResolvedResults::Builder::adoptS(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::CallFooWhenResolvedResults::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::NeverReturnParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::NeverReturnParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::NeverReturnParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::NeverReturnParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::NeverReturnParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::NeverReturnParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::NeverReturnResults::Reader::hasCapCopy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::NeverReturnResults::Builder::hasCapCopy() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnResults::Reader::getCapCopy() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnResults::Builder::getCapCopy() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::NeverReturnResults::Pipeline::getCapCopy() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::NeverReturnResults::Builder::setCapCopy( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::NeverReturnResults::Builder::setCapCopy( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::NeverReturnResults::Builder::adoptCapCopy(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::NeverReturnResults::Builder::disownCapCopy() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::HoldParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::HoldParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::HoldParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::HoldParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::HoldParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::HoldParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::HoldParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::HoldParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::HoldParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::CallHeldResults::Reader::hasS() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::CallHeldResults::Builder::hasS() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::CallHeldResults::Reader::getS() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::CallHeldResults::Builder::getS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::CallHeldResults::Builder::setS( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::CallHeldResults::Builder::initS(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::CallHeldResults::Builder::adoptS(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::CallHeldResults::Builder::disownS() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::GetHeldResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::GetHeldResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::GetHeldResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::GetHeldResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::GetHeldResults::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::GetHeldResults::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::GetHeldResults::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::GetHeldResults::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::GetHeldResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::EchoParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::EchoParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestCallOrder::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::EchoParams::Builder::setCap( ::capnproto_test::capnp::test::TestCallOrder::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::EchoParams::Builder::setCap( ::capnproto_test::capnp::test::TestCallOrder::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::EchoParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> TestMoreStuff::EchoParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::EchoResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::EchoResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestCallOrder::Client TestMoreStuff::EchoResults::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestCallOrder::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::EchoResults::Builder::setCap( ::capnproto_test::capnp::test::TestCallOrder::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::EchoResults::Builder::setCap( ::capnproto_test::capnp::test::TestCallOrder::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::EchoResults::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestCallOrder> TestMoreStuff::EchoResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestCallOrder>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::ExpectCancelParams::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::ExpectCancelParams::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::ExpectCancelParams::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::ExpectCancelParams::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::ExpectCancelParams::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::ExpectCancelParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::ExpectCancelParams::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::ExpectCancelParams::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::ExpectCancelParams::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::MethodWithDefaultsParams::Reader::hasA() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithDefaultsParams::Builder::hasA() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::MethodWithDefaultsParams::Reader::getA() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsParams::Builder::getA() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::MethodWithDefaultsParams::Builder::setA( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsParams::Builder::initA(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::MethodWithDefaultsParams::Builder::adoptA(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::MethodWithDefaultsParams::Builder::disownA() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TestMoreStuff::MethodWithDefaultsParams::Reader::getB() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 123u);
}

inline  ::uint32_t TestMoreStuff::MethodWithDefaultsParams::Builder::getB() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 123u);
}
inline void TestMoreStuff::MethodWithDefaultsParams::Builder::setB( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 123u);
}

inline bool TestMoreStuff::MethodWithDefaultsParams::Reader::hasC() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithDefaultsParams::Builder::hasC() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::MethodWithDefaultsParams::Reader::getC() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_99160a25fa50fbf1 + 69, 3);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsParams::Builder::getC() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_99160a25fa50fbf1 + 69, 3);
}
inline void TestMoreStuff::MethodWithDefaultsParams::Builder::setC( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsParams::Builder::initC(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::MethodWithDefaultsParams::Builder::adoptC(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::MethodWithDefaultsParams::Builder::disownC() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::MethodWithDefaultsResults::Reader::hasD() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithDefaultsResults::Builder::hasD() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::MethodWithDefaultsResults::Reader::getD() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsResults::Builder::getD() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::MethodWithDefaultsResults::Builder::setD( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsResults::Builder::initD(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::MethodWithDefaultsResults::Builder::adoptD(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::MethodWithDefaultsResults::Builder::disownD() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::MethodWithDefaultsResults::Reader::hasE() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithDefaultsResults::Builder::hasE() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::MethodWithDefaultsResults::Reader::getE() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9c7e066f845a6c56 + 54, 3);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsResults::Builder::getE() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_9c7e066f845a6c56 + 54, 3);
}
inline void TestMoreStuff::MethodWithDefaultsResults::Builder::setE( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithDefaultsResults::Builder::initE(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::MethodWithDefaultsResults::Builder::adoptE(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::MethodWithDefaultsResults::Builder::disownE() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::GetHandleResults::Reader::hasHandle() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::GetHandleResults::Builder::hasHandle() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestHandle::Client TestMoreStuff::GetHandleResults::Reader::getHandle() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestHandle::Client TestMoreStuff::GetHandleResults::Builder::getHandle() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestHandle::Client TestMoreStuff::GetHandleResults::Pipeline::getHandle() {
  return  ::capnproto_test::capnp::test::TestHandle::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::GetHandleResults::Builder::setHandle( ::capnproto_test::capnp::test::TestHandle::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::GetHandleResults::Builder::setHandle( ::capnproto_test::capnp::test::TestHandle::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::GetHandleResults::Builder::adoptHandle(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestHandle>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestHandle> TestMoreStuff::GetHandleResults::Builder::disownHandle() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestHandle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::GetNullResults::Reader::hasNullCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::GetNullResults::Builder::hasNullCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMoreStuff::Client TestMoreStuff::GetNullResults::Reader::getNullCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMoreStuff::Client TestMoreStuff::GetNullResults::Builder::getNullCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMoreStuff::Client TestMoreStuff::GetNullResults::Pipeline::getNullCap() {
  return  ::capnproto_test::capnp::test::TestMoreStuff::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMoreStuff::GetNullResults::Builder::setNullCap( ::capnproto_test::capnp::test::TestMoreStuff::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::GetNullResults::Builder::setNullCap( ::capnproto_test::capnp::test::TestMoreStuff::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::GetNullResults::Builder::adoptNullCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMoreStuff>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMoreStuff> TestMoreStuff::GetNullResults::Builder::disownNullCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMoreStuff>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMoreStuff::GetEnormousStringResults::Reader::hasStr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::GetEnormousStringResults::Builder::hasStr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::GetEnormousStringResults::Reader::getStr() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::GetEnormousStringResults::Builder::getStr() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::GetEnormousStringResults::Builder::setStr( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::GetEnormousStringResults::Builder::initStr(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::GetEnormousStringResults::Builder::adoptStr(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::GetEnormousStringResults::Builder::disownStr() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::MethodWithNullDefaultParams::Reader::hasA() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithNullDefaultParams::Builder::hasA() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMoreStuff::MethodWithNullDefaultParams::Reader::getA() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithNullDefaultParams::Builder::getA() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMoreStuff::MethodWithNullDefaultParams::Builder::setA( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMoreStuff::MethodWithNullDefaultParams::Builder::initA(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMoreStuff::MethodWithNullDefaultParams::Builder::adoptA(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMoreStuff::MethodWithNullDefaultParams::Builder::disownA() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMoreStuff::MethodWithNullDefaultParams::Reader::hasB() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestMoreStuff::MethodWithNullDefaultParams::Builder::hasB() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::MethodWithNullDefaultParams::Reader::getB() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::MethodWithNullDefaultParams::Builder::getB() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestMoreStuff::MethodWithNullDefaultParams::Pipeline::getB() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(1).asCap());
}
inline void TestMoreStuff::MethodWithNullDefaultParams::Builder::setB( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMoreStuff::MethodWithNullDefaultParams::Builder::setB( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void TestMoreStuff::MethodWithNullDefaultParams::Builder::adoptB(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestMoreStuff::MethodWithNullDefaultParams::Builder::disownB() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline TestMembrane::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestMembrane::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestMembrane::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestMembrane::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestMembrane::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestMembrane::Client& TestMembrane::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestMembrane::Client& TestMembrane::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline TestMembrane::Thing::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestMembrane::Thing::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestMembrane::Thing::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestMembrane::Thing::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestMembrane::Thing::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client& TestMembrane::Thing::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client& TestMembrane::Thing::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool TestMembrane::Result::Reader::hasText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::Result::Builder::hasText() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestMembrane::Result::Reader::getText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestMembrane::Result::Builder::getText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestMembrane::Result::Builder::setText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestMembrane::Result::Builder::initText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestMembrane::Result::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestMembrane::Result::Builder::disownText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestMembrane::MakeThingResults::Reader::hasThing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::MakeThingResults::Builder::hasThing() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::MakeThingResults::Reader::getThing() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::MakeThingResults::Builder::getThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::MakeThingResults::Pipeline::getThing() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMembrane::MakeThingResults::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMembrane::MakeThingResults::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMembrane::MakeThingResults::Builder::adoptThing(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestMembrane::MakeThingResults::Builder::disownThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMembrane::CallPassThroughParams::Reader::hasThing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::CallPassThroughParams::Builder::hasThing() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallPassThroughParams::Reader::getThing() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallPassThroughParams::Builder::getThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallPassThroughParams::Pipeline::getThing() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMembrane::CallPassThroughParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMembrane::CallPassThroughParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMembrane::CallPassThroughParams::Builder::adoptThing(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestMembrane::CallPassThroughParams::Builder::disownThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMembrane::CallPassThroughParams::Reader::getTailCall() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestMembrane::CallPassThroughParams::Builder::getTailCall() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestMembrane::CallPassThroughParams::Builder::setTailCall(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestMembrane::CallInterceptParams::Reader::hasThing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::CallInterceptParams::Builder::hasThing() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallInterceptParams::Reader::getThing() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallInterceptParams::Builder::getThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::CallInterceptParams::Pipeline::getThing() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMembrane::CallInterceptParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMembrane::CallInterceptParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMembrane::CallInterceptParams::Builder::adoptThing(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestMembrane::CallInterceptParams::Builder::disownThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMembrane::CallInterceptParams::Reader::getTailCall() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TestMembrane::CallInterceptParams::Builder::getTailCall() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestMembrane::CallInterceptParams::Builder::setTailCall(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TestMembrane::LoopbackParams::Reader::hasThing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::LoopbackParams::Builder::hasThing() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackParams::Reader::getThing() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackParams::Builder::getThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackParams::Pipeline::getThing() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMembrane::LoopbackParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMembrane::LoopbackParams::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMembrane::LoopbackParams::Builder::adoptThing(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestMembrane::LoopbackParams::Builder::disownThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestMembrane::LoopbackResults::Reader::hasThing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestMembrane::LoopbackResults::Builder::hasThing() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackResults::Reader::getThing() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackResults::Builder::getThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestMembrane::LoopbackResults::Pipeline::getThing() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestMembrane::LoopbackResults::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestMembrane::LoopbackResults::Builder::setThing( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestMembrane::LoopbackResults::Builder::adoptThing(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestMembrane::LoopbackResults::Builder::disownThing() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestContainMembrane::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestContainMembrane::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestContainMembrane::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestContainMembrane::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestMembrane::Thing::Client TestContainMembrane::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestMembrane::Thing::Client(_typeless.getPointerField(0).asCap());
}
inline void TestContainMembrane::Builder::setCap( ::capnproto_test::capnp::test::TestMembrane::Thing::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestContainMembrane::Builder::setCap( ::capnproto_test::capnp::test::TestMembrane::Thing::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TestContainMembrane::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestMembrane::Thing> TestContainMembrane::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestMembrane::Thing>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestContainMembrane::Reader::hasList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestContainMembrane::Builder::hasList() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Reader TestContainMembrane::Reader::getList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Builder TestContainMembrane::Builder::getList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TestContainMembrane::Builder::setList( ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>::Builder TestContainMembrane::Builder::initList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TestContainMembrane::Builder::adoptList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>> TestContainMembrane::Builder::disownList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestMembrane::Thing>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TestTransferCap::Reader::hasList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestTransferCap::Builder::hasList() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Reader TestTransferCap::Reader::getList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Builder TestTransferCap::Builder::getList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestTransferCap::Builder::setList( ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>::Builder TestTransferCap::Builder::initList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestTransferCap::Builder::adoptList(
    ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>> TestTransferCap::Builder::disownList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnproto_test::capnp::test::TestTransferCap::Element>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestTransferCap::Element::Reader::hasText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestTransferCap::Element::Builder::hasText() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestTransferCap::Element::Reader::getText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestTransferCap::Element::Builder::getText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestTransferCap::Element::Builder::setText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestTransferCap::Element::Builder::initText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestTransferCap::Element::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestTransferCap::Element::Builder::disownText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestTransferCap::Element::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestTransferCap::Element::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestInterface::Client TestTransferCap::Element::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestTransferCap::Element::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestInterface::Client TestTransferCap::Element::Pipeline::getCap() {
  return  ::capnproto_test::capnp::test::TestInterface::Client(_typeless.getPointerField(1).asCap());
}
inline void TestTransferCap::Element::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TestTransferCap::Element::Builder::setCap( ::capnproto_test::capnp::test::TestInterface::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void TestTransferCap::Element::Builder::adoptCap(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestInterface> TestTransferCap::Element::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline TestKeywordMethods::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TestKeywordMethods::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TestKeywordMethods::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TestKeywordMethods::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TestKeywordMethods::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::TestKeywordMethods::Client& TestKeywordMethods::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::TestKeywordMethods::Client& TestKeywordMethods::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
template <typename VatId>
inline TestAuthenticatedBootstrap<VatId>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename VatId>
inline TestAuthenticatedBootstrap<VatId>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename VatId>
template <typename _t, typename>
inline TestAuthenticatedBootstrap<VatId>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename VatId>
template <typename _t, typename>
inline TestAuthenticatedBootstrap<VatId>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename VatId>
inline TestAuthenticatedBootstrap<VatId>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename VatId>
inline typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::Client& TestAuthenticatedBootstrap<VatId>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename VatId>
inline typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::Client& TestAuthenticatedBootstrap<VatId>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// TestAuthenticatedBootstrap<VatId>::GetCallerIdParams
template <typename VatId>
constexpr uint16_t TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::dataWordSize;
template <typename VatId>
constexpr uint16_t TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename VatId>
constexpr ::capnp::Kind TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::kind;
template <typename VatId>
constexpr ::capnp::_::RawSchema const* TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::schema;
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Scope TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::brandScopes[] = {
  { 0xea72cc77253798cd, brandBindings + 0, 1, false},
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Binding TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<VatId>(),
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8ec30e2451f1cffe, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename VatId>
inline bool TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Reader::hasCaller() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename VatId>
inline bool TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::hasCaller() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename VatId>
inline  ::capnp::ReaderFor<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Reader::getCaller() const {
  return ::capnp::_::PointerHelpers<VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename VatId>
inline  ::capnp::BuilderFor<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::getCaller() {
  return ::capnp::_::PointerHelpers<VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename VatId>
inline  ::capnp::PipelineFor<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Pipeline::getCaller() {
  return  ::capnp::PipelineFor<VatId>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename VatId>
inline void TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::setCaller( ::capnp::ReaderFor<VatId> value) {
  ::capnp::_::PointerHelpers<VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename VatId>
inline  ::capnp::BuilderFor<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::initCaller() {
  return ::capnp::_::PointerHelpers<VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename VatId>
inline  ::capnp::BuilderFor<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::initCaller(unsigned int size) {
  return ::capnp::_::PointerHelpers<VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename VatId>
inline void TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::adoptCaller(
    ::capnp::Orphan<VatId>&& value) {
  ::capnp::_::PointerHelpers<VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename VatId>
inline ::capnp::Orphan<VatId> TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::Builder::disownCaller() {
  return ::capnp::_::PointerHelpers<VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// TestAuthenticatedBootstrap<VatId>::GetCallerIdResults
template <typename VatId>
constexpr uint16_t TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::dataWordSize;
template <typename VatId>
constexpr uint16_t TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename VatId>
constexpr ::capnp::Kind TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::kind;
template <typename VatId>
constexpr ::capnp::_::RawSchema const* TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::schema;
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Scope TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::brandScopes[] = {
  { 0xea72cc77253798cd, brandBindings + 0, 1, false},
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Binding TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<VatId>(),
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c71cf776034a3e67, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename VatId>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams, typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults>)
TestAuthenticatedBootstrap<VatId>::Client::getCallerIdRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams, typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults>(
      0xea72cc77253798cdull, 0, sizeHint);
}
template <typename VatId>
::kj::Promise<void> TestAuthenticatedBootstrap<VatId>::Server::getCallerId(GetCallerIdContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "packages/capnpc-ts/test/integration/test.capnp:TestAuthenticatedBootstrap", "getCallerId",
      0xea72cc77253798cdull, 0);
}
template <typename VatId>
::kj::Promise<void> TestAuthenticatedBootstrap<VatId>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xea72cc77253798cdull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("packages/capnpc-ts/test/integration/test.capnp:TestAuthenticatedBootstrap", interfaceId);
  }
}
template <typename VatId>
::kj::Promise<void> TestAuthenticatedBootstrap<VatId>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return getCallerId(::capnp::Capability::Server::internalGetTypedContext<
          typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams, typename  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults>(context));
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "packages/capnpc-ts/test/integration/test.capnp:TestAuthenticatedBootstrap",
          0xea72cc77253798cdull, methodId);
  }
}
#endif  // !CAPNP_LITE

// TestAuthenticatedBootstrap<VatId>
#if !CAPNP_LITE
template <typename VatId>
constexpr ::capnp::Kind TestAuthenticatedBootstrap<VatId>::_capnpPrivate::kind;
template <typename VatId>
constexpr ::capnp::_::RawSchema const* TestAuthenticatedBootstrap<VatId>::_capnpPrivate::schema;
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Scope TestAuthenticatedBootstrap<VatId>::_capnpPrivate::brandScopes[] = {
  { 0xea72cc77253798cd, brandBindings + 0, 1, false},
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Binding TestAuthenticatedBootstrap<VatId>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<VatId>(),
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema::Dependency TestAuthenticatedBootstrap<VatId>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdParams::_capnpPrivate::brand() },
  { 50331648,  ::capnproto_test::capnp::test::TestAuthenticatedBootstrap<VatId>::GetCallerIdResults::_capnpPrivate::brand() },
};
template <typename VatId>
const ::capnp::_::RawBrandedSchema TestAuthenticatedBootstrap<VatId>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ea72cc77253798cd, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

inline bool TestSturdyRef::Reader::hasHostId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestSturdyRef::Builder::hasHostId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Reader TestSturdyRef::Reader::getHostId() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Builder TestSturdyRef::Builder::getHostId() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Pipeline TestSturdyRef::Pipeline::getHostId() {
  return  ::capnproto_test::capnp::test::TestSturdyRefHostId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TestSturdyRef::Builder::setHostId( ::capnproto_test::capnp::test::TestSturdyRefHostId::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::TestSturdyRefHostId::Builder TestSturdyRef::Builder::initHostId() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestSturdyRef::Builder::adoptHostId(
    ::capnp::Orphan< ::capnproto_test::capnp::test::TestSturdyRefHostId>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::TestSturdyRefHostId> TestSturdyRef::Builder::disownHostId() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::TestSturdyRefHostId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TestSturdyRef::Reader::hasObjectId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TestSturdyRef::Builder::hasObjectId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader TestSturdyRef::Reader::getObjectId() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestSturdyRef::Builder::getObjectId() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder TestSturdyRef::Builder::initObjectId() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool TestSturdyRefHostId::Reader::hasHost() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TestSturdyRefHostId::Builder::hasHost() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TestSturdyRefHostId::Reader::getHost() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TestSturdyRefHostId::Builder::getHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TestSturdyRefHostId::Builder::setHost( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TestSturdyRefHostId::Builder::initHost(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TestSturdyRefHostId::Builder::adoptHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TestSturdyRefHostId::Builder::disownHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag TestSturdyRefObjectId::Reader::getTag() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag TestSturdyRefObjectId::Builder::getTag() {
  return _builder.getDataField< ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TestSturdyRefObjectId::Builder::setTag( ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag value) {
  _builder.setDataField< ::capnproto_test::capnp::test::TestSturdyRefObjectId::Tag>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::RenamedStruct::Which RenamedStruct::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::RenamedStruct::Which RenamedStruct::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool RenamedStruct::Reader::isGoodFieldName() const {
  return which() == RenamedStruct::GOOD_FIELD_NAME;
}
inline bool RenamedStruct::Builder::isGoodFieldName() {
  return which() == RenamedStruct::GOOD_FIELD_NAME;
}
inline bool RenamedStruct::Reader::getGoodFieldName() const {
  KJ_IREQUIRE((which() == RenamedStruct::GOOD_FIELD_NAME),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool RenamedStruct::Builder::getGoodFieldName() {
  KJ_IREQUIRE((which() == RenamedStruct::GOOD_FIELD_NAME),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::Builder::setGoodFieldName(bool value) {
  _builder.setDataField<RenamedStruct::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RenamedStruct::GOOD_FIELD_NAME);
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RenamedStruct::Reader::isBar() const {
  return which() == RenamedStruct::BAR;
}
inline bool RenamedStruct::Builder::isBar() {
  return which() == RenamedStruct::BAR;
}
inline  ::int8_t RenamedStruct::Reader::getBar() const {
  KJ_IREQUIRE((which() == RenamedStruct::BAR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t RenamedStruct::Builder::getBar() {
  KJ_IREQUIRE((which() == RenamedStruct::BAR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::Builder::setBar( ::int8_t value) {
  _builder.setDataField<RenamedStruct::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RenamedStruct::BAR);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum RenamedStruct::Reader::getAnotherGoodFieldName() const {
  return _reader.getDataField< ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum RenamedStruct::Builder::getAnotherGoodFieldName() {
  return _builder.getDataField< ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::Builder::setAnotherGoodFieldName( ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum value) {
  _builder.setDataField< ::capnproto_test::capnp::test::RenamedStruct::RenamedEnum>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline typename RenamedStruct::RenamedUnion::Reader RenamedStruct::Reader::getRenamedUnion() const {
  return typename RenamedStruct::RenamedUnion::Reader(_reader);
}
inline typename RenamedStruct::RenamedUnion::Builder RenamedStruct::Builder::getRenamedUnion() {
  return typename RenamedStruct::RenamedUnion::Builder(_builder);
}
#if !CAPNP_LITE
inline typename RenamedStruct::RenamedUnion::Pipeline RenamedStruct::Pipeline::getRenamedUnion() {
  return typename RenamedStruct::RenamedUnion::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename RenamedStruct::RenamedUnion::Builder RenamedStruct::Builder::initRenamedUnion() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename RenamedStruct::RenamedUnion::Builder(_builder);
}
inline bool RenamedStruct::RenamedNestedStruct::Reader::getGoodNestedFieldName() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool RenamedStruct::RenamedNestedStruct::Builder::getGoodNestedFieldName() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::RenamedNestedStruct::Builder::setGoodNestedFieldName(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RenamedStruct::RenamedNestedStruct::Reader::hasAnotherGoodNestedFieldName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RenamedStruct::RenamedNestedStruct::Builder::hasAnotherGoodNestedFieldName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader RenamedStruct::RenamedNestedStruct::Reader::getAnotherGoodNestedFieldName() const {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder RenamedStruct::RenamedNestedStruct::Builder::getAnotherGoodNestedFieldName() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Pipeline RenamedStruct::RenamedNestedStruct::Pipeline::getAnotherGoodNestedFieldName() {
  return  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RenamedStruct::RenamedNestedStruct::Builder::setAnotherGoodNestedFieldName( ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder RenamedStruct::RenamedNestedStruct::Builder::initAnotherGoodNestedFieldName() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RenamedStruct::RenamedNestedStruct::Builder::adoptAnotherGoodNestedFieldName(
    ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>&& value) {
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct> RenamedStruct::RenamedNestedStruct::Builder::disownAnotherGoodNestedFieldName() {
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedUnion::Which RenamedStruct::RenamedUnion::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedUnion::Which RenamedStruct::RenamedUnion::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool RenamedStruct::RenamedUnion::Reader::isRenamedGroup() const {
  return which() == RenamedStruct::RenamedUnion::RENAMED_GROUP;
}
inline bool RenamedStruct::RenamedUnion::Builder::isRenamedGroup() {
  return which() == RenamedStruct::RenamedUnion::RENAMED_GROUP;
}
inline typename RenamedStruct::RenamedUnion::RenamedGroup::Reader RenamedStruct::RenamedUnion::Reader::getRenamedGroup() const {
  KJ_IREQUIRE((which() == RenamedStruct::RenamedUnion::RENAMED_GROUP),
              "Must check which() before get()ing a union member.");
  return typename RenamedStruct::RenamedUnion::RenamedGroup::Reader(_reader);
}
inline typename RenamedStruct::RenamedUnion::RenamedGroup::Builder RenamedStruct::RenamedUnion::Builder::getRenamedGroup() {
  KJ_IREQUIRE((which() == RenamedStruct::RenamedUnion::RENAMED_GROUP),
              "Must check which() before get()ing a union member.");
  return typename RenamedStruct::RenamedUnion::RenamedGroup::Builder(_builder);
}
inline typename RenamedStruct::RenamedUnion::RenamedGroup::Builder RenamedStruct::RenamedUnion::Builder::initRenamedGroup() {
  _builder.setDataField<RenamedStruct::RenamedUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, RenamedStruct::RenamedUnion::RENAMED_GROUP);
  return typename RenamedStruct::RenamedUnion::RenamedGroup::Builder(_builder);
}
inline bool RenamedStruct::RenamedUnion::Reader::isQux() const {
  return which() == RenamedStruct::RenamedUnion::QUX;
}
inline bool RenamedStruct::RenamedUnion::Builder::isQux() {
  return which() == RenamedStruct::RenamedUnion::QUX;
}
inline bool RenamedStruct::RenamedUnion::Reader::hasQux() const {
  if (which() != RenamedStruct::RenamedUnion::QUX) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RenamedStruct::RenamedUnion::Builder::hasQux() {
  if (which() != RenamedStruct::RenamedUnion::QUX) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader RenamedStruct::RenamedUnion::Reader::getQux() const {
  KJ_IREQUIRE((which() == RenamedStruct::RenamedUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder RenamedStruct::RenamedUnion::Builder::getQux() {
  KJ_IREQUIRE((which() == RenamedStruct::RenamedUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RenamedStruct::RenamedUnion::Builder::setQux( ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Reader value) {
  _builder.setDataField<RenamedStruct::RenamedUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, RenamedStruct::RenamedUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct::Builder RenamedStruct::RenamedUnion::Builder::initQux() {
  _builder.setDataField<RenamedStruct::RenamedUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, RenamedStruct::RenamedUnion::QUX);
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RenamedStruct::RenamedUnion::Builder::adoptQux(
    ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>&& value) {
  _builder.setDataField<RenamedStruct::RenamedUnion::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, RenamedStruct::RenamedUnion::QUX);
  ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct> RenamedStruct::RenamedUnion::Builder::disownQux() {
  KJ_IREQUIRE((which() == RenamedStruct::RenamedUnion::QUX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnproto_test::capnp::test::RenamedStruct::RenamedNestedStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::Void RenamedStruct::RenamedUnion::RenamedGroup::Reader::getFoo() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void RenamedStruct::RenamedUnion::RenamedGroup::Builder::getFoo() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::RenamedUnion::RenamedGroup::Builder::setFoo( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void RenamedStruct::RenamedUnion::RenamedGroup::Reader::getBar() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void RenamedStruct::RenamedUnion::RenamedGroup::Builder::getBar() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedStruct::RenamedUnion::RenamedGroup::Builder::setBar( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline RenamedInterface::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline RenamedInterface::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline RenamedInterface::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline RenamedInterface::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline RenamedInterface::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::capnproto_test::capnp::test::RenamedInterface::Client& RenamedInterface::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::capnproto_test::capnp::test::RenamedInterface::Client& RenamedInterface::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint8_t RenamedInterface::RenamedMethodParams::Reader::getRenamedParam() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t RenamedInterface::RenamedMethodParams::Builder::getRenamedParam() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RenamedInterface::RenamedMethodParams::Builder::setRenamedParam( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_d508eebdc2dc42b8_
