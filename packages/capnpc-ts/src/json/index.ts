import * as fs from 'fs';
import * as R from 'ramda';

import {c2s, c2t, d2h} from '../util';
import {Field, Node, Primitive, Type, Value} from './interface';
import {
  ICodeGeneratorRequest,
  ICodeGeneratorRequest_RequestedFile,
  IField,
  IField_Slot,
  INode,
  INode_NestedNode,
  IType,
  Node_Which,
  Type_Which,
} from './types';

const IMPORT_ANNOTATION_ID = 'e37ded525a68a7c9';

interface GenContext {
  cgr: ICodeGeneratorRequest;
  genNodeIds: string[];
  nodeMap: {[id: string]: INode};
}

interface FileGenContext extends GenContext {
  concreteListInitializers: string[];
  fd: number;
  requestedFile: ICodeGeneratorRequest_RequestedFile;
  fileNode: INode;
}

const lookupNode = R.curry((ctx: GenContext, req: INode_NestedNode | string): INode => {

  if (typeof req === 'string') return ctx.nodeMap[req];

  return ctx.nodeMap[req.id];

});

const generateHeaderComment = R.curry((ctx: FileGenContext): void => {

  const {fd} = ctx;

  fs.writeSync(fd, `/**
 * This file has been automatically generated by the [capnpc-ts utility]
 * (https://github.com/jdiaz5513/capnpc-ts).
 */
/* tslint:disable:no-use-before-declare */
`);

});

const generateImports = R.curry((ctx: FileGenContext): void => {

  const {fd, fileNode} = ctx;
  const importAnnotation = R.find((a) => a.id === IMPORT_ANNOTATION_ID, fileNode.annotations);
  const importPath = (importAnnotation && importAnnotation.value.text) || 'capnp-ts';

  fs.writeSync(fd, `
import * as capnp from '${importPath}';

export const _id = '${d2h(fileNode.id)}';
`);

});

const generateUnnamedUnionEnum = R.curry((ctx: FileGenContext, node: INode): void => {

  if (node.struct === undefined) throw new Error('wat');

  const {fd} = ctx;
  const unionFields = Node.getUnnamedUnionFields(node);
  const NodeClassName = Node.getFullClassName(node);

  fs.writeSync(fd, `
export enum ${NodeClassName}_Which {
${R.map((field) => `  ${c2s(field.name)} = ${field.discriminantValue},`, unionFields).join('\n')}
}
`);

});

const ConcreteListType = {
  [Type.ANY_POINTER]: 'capnp.AnyPointerList',
  [Type.BOOL]: 'capnp.BoolList',
  [Type.DATA]: 'capnp.DataList',
  [Type.ENUM]: 'capnp.Uint16List',
  [Type.FLOAT32]: 'capnp.Float32List',
  [Type.FLOAT64]: 'capnp.Float64List',
  [Type.INT16]: 'capnp.Int16List',
  [Type.INT32]: 'capnp.Int32List',
  [Type.INT64]: 'capnp.Int64List',
  [Type.INT8]: 'capnp.Int8List',
  [Type.INTERFACE]: 'capnp.InterfaceList',
  [Type.LIST]: 'capnp.PointerList',
  [Type.STRUCT]: 'capnp.CompositeList',
  [Type.TEXT]: 'capnp.TextList',
  [Type.UINT16]: 'capnp.Uint16List',
  [Type.UINT32]: 'capnp.Uint32List',
  [Type.UINT64]: 'capnp.Uint64List',
  [Type.UINT8]: 'capnp.Uint8List',
};

const toJsType = R.curry((ctx: FileGenContext, type: IType, constructor: boolean): string => {

  const whichType = Type.which(type);

  switch (whichType) {

    case Type.ANY_POINTER:

      return 'capnp.Pointer';

    case Type.BOOL:

      return 'boolean';

    case Type.DATA:

      return 'capnp.Data';

    case Type.ENUM:

      if (type.enum === undefined) throw new Error('wat');

      return Node.getFullClassName(lookupNode(ctx, type.enum.typeId));

    case Type.FLOAT32:
    case Type.FLOAT64:
    case Type.INT16:
    case Type.INT32:
    case Type.INT8:
    case Type.UINT16:
    case Type.UINT32:
    case Type.UINT8:

      return 'number';

    case Type.INT64:

      return 'capnp.Int64';

    case Type.INTERFACE:

      return 'capnp.Interface';

    case Type.LIST:

      if (type.list === undefined) throw new Error('wat');

      return `capnp.List${constructor ? 'Ctor' : ''}<${toJsType(ctx, type.list.elementType, false)}>`;

    case Type.STRUCT:

      if (type.struct === undefined) throw new Error('wat');

      const c = Node.getFullClassName(lookupNode(ctx, type.struct.typeId));

      return constructor ? `capnp.StructCtor<${c}>` : c;

    case Type.UINT64:

      return 'capnp.Uint64';

    case Type.TEXT:

      return 'string';

    case Type.VOID:

      return 'void';

    default:

      throw new Error(`don't know field class for slot type ${whichType}`);

  }

});

const toConcreteListType = R.curry((ctx: FileGenContext, type: IType): string => {

  if (type.list === undefined) return toJsType(ctx, type, false);

  const elementType = Type.which(type.list.elementType);

  if (elementType === Type.LIST) {

    return `capnp.PointerList(${toConcreteListType(ctx, type.list.elementType)})`;

  } else if (elementType === Type.STRUCT) {

    if (type.list.elementType.struct === undefined) throw new Error('wat');

    const structNode = lookupNode(ctx, type.list.elementType.struct.typeId);

    if (structNode.struct === undefined) throw new Error('wat');

    if (structNode.struct.preferredListEncoding !== 'inlineComposite') {

      throw new Error(`don't know how to make non-inline struct lists with: ${structNode}`);

    }

    return `capnp.CompositeList(${toJsType(ctx, type.list.elementType, false)})`;

  }

  return ConcreteListType[elementType];

});

const generateStructField = R.curry((ctx: FileGenContext, node: INode, field: IField): void => {

  if (node.struct === undefined) throw new Error('wat');

  let JsType: string;
  let whichType: Type_Which | string;

  if (field.slot) {

    JsType = toJsType(ctx, field.slot.type, false);
    whichType = Type.which(field.slot.type);

  } else if (field.group) {

    JsType = Node.getFullClassName(lookupNode(ctx, field.group.typeId));
    whichType = 'group';

  } else {

    throw new Error(`don't know how to generate struct field: ${JSON.stringify(field)}`);

  }

  const {fd} = ctx;
  const {discriminantOffset} = node.struct;
  const Name = c2t(field.name);
  const {discriminantValue, name} = field;
  const StructClass = Node.getFullClassName(node);
  const union = discriminantValue !== Type.NO_DISCRIMINANT;
  const offset = (field.slot && field.slot.offset) || 0;
  let adopt = false;
  let disown = false;
  let init;
  let has = false;
  let get;
  let set;

  if (field.slot) {

    whichType = Type.which(field.slot.type);

  } else if (field.group) {

    whichType = 'group';

  }

  switch (whichType) {

    case Type.ANY_POINTER:

      adopt = true;
      disown = true;
      get = `this._getPointer(${offset})`;
      has = true;
      set = `this._getPointer(${offset})._copyFrom(value)`;

      break;

    case Type.BOOL:
    case Type.ENUM:
    case Type.FLOAT32:
    case Type.FLOAT64:
    case Type.INT16:
    case Type.INT32:
    case Type.INT64:
    case Type.INT8:
    case Type.UINT16:
    case Type.UINT32:
    case Type.UINT64:
    case Type.UINT8:

      if (typeof whichType !== 'number') throw new Error('wat');

      const {byteLength, getter, setter} = Primitive[whichType];
      const byteOffset = offset * byteLength;

      get = `this._${getter}(${byteOffset})`;
      set = `this._${setter}(${byteOffset}, value)`;

      break;

    case Type.DATA:

      adopt = true;
      disown = true;
      get = `this._getData(${offset})`;
      has = true;
      init = `this._initData(${offset}, length)`;
      set = `this._getPointer(${offset})._copyFrom(value)`;

      break;

    case Type.INTERFACE:

      get = `this._getPointerAs(${offset}, ${JsType})`;
      set = `this._getPointer(${offset})._copyFrom(value)`;

      break;

    case Type.LIST:

      if (field.slot === undefined || field.slot.type.list === undefined) throw new Error('wat');

      const whichElementType = Type.which(field.slot.type.list.elementType);
      let ListClass = ConcreteListType[whichElementType];

      if (whichElementType === Type.LIST || whichElementType === Type.STRUCT) {

        ListClass = `${StructClass}._${Name}`;

      }

      adopt = true;
      disown = true;
      get = `this._getList(${offset}, ${ListClass})`;
      has = true;
      init = `this._initList(${offset}, ${ListClass}, length)`;
      set = `this._getPointer(${offset})._copyFrom(value)`;

      break;

    case Type.STRUCT:

      if (field.slot === undefined) throw new Error('wat');

      adopt = true;
      disown = true;
      get = `this._getStruct(${offset}, ${toJsType(ctx, field.slot.type, false)})`;
      has = true;
      init = `this._initStructAt(${offset}, ${toJsType(ctx, field.slot.type, false)})`;
      set = `this._getPointer(${offset})._copyFrom(value)`;

      break;

    case Type.TEXT:

      get = `this._getText(${offset})`;
      set = `this._setText(${offset}, value)`;

      break;

    case Type.VOID:

      break;

    case 'group':

      get = `this._getAs(${JsType})`;
      init = `this._getAs(${JsType})`;

      break;

    default:

      break;

  }

  fs.writeSync(fd, `${adopt ? `
  adopt${Name}(value: capnp.Orphan<${JsType}>): void {${union ? `

    this._setUint16(${discriminantOffset * 2}, ${discriminantValue});` : ''}

    this._getPointer(${offset}).adopt(value);

  }
` : ''}${disown ? `
  disown${Name}(): capnp.Orphan<${JsType}> {

    return this.get${Name}().disown();

  }
` : ''}${get ? `
  get${Name}(): ${JsType} {${union ? `

    this._testWhich('${name}', this._getUint16(${discriminantOffset * 2}), ${discriminantValue});` : ''}

    return ${get};

  }
` : ''}${has ? `
  has${Name}(): boolean {

    return !this._getPointer(${offset})._isNull();

  }
` : ''}${init ? `
  init${Name}(${whichType === Type.DATA || whichType === Type.LIST ? 'length: number' : ''}): ${JsType} {${union ? `

    this._setUint16(${discriminantOffset * 2}, ${discriminantValue});` : ''}

    return ${init};

  }
` : ''}${union ? `
  is${Name}(): boolean {

    return this._getUint16(${discriminantOffset * 2}) === ${discriminantValue};

  }

` : ''}${set ? `
  set${Name}(value: ${JsType}): void {${union ? `

    this._setUint16(${discriminantOffset * 2}, ${discriminantValue});` : ''}

    ${set};

  }
` : ''}`);

});

const generateStructNode = R.curry((ctx: FileGenContext, node: INode): void => {

  if (node.struct === undefined) throw new Error('wat');

  const {cgr, fd} = ctx;
  const {dataWordCount, discriminantCount, discriminantOffset, fields, pointerCount} = node.struct;
  const hasUnnamedUnion = discriminantCount !== 0;
  const nestedNodes = R.filter((n) => n.const === undefined, R.map(lookupNode(ctx), node.nestedNodes || []));
  const concreteLists = R.filter(Field.needsConcreteListClass, fields);
  const consts = R.filter((n) => n.scopeId === node.id && n.const !== undefined, cgr.nodes);
  const groups = R.filter((n) => n.scopeId === node.id && n.struct !== undefined && n.struct.isGroup, cgr.nodes);

  /* tslint:disable-next-line:no-use-before-declare */
  R.forEach(generateNode(ctx), nestedNodes);

  if (hasUnnamedUnion) generateUnnamedUnionEnum(ctx, node);

  const Class = Node.getFullClassName(node);
  const Name = Node.getDisplayNamePrefix(node);

  fs.writeSync(fd, `
export class ${Class} extends capnp.Struct {

  static readonly _displayName = '${Name}';
  static readonly _id = '${d2h(node.id)}';
  static readonly _size: capnp.ObjectSize = new capnp.ObjectSize(${dataWordCount * 8}, ${pointerCount});
`);

  if (concreteLists.length > 0) {

    fs.writeSync(fd, `
${R.map((field) => `  static _${c2t(field.name)}: ${toJsType(ctx, (field.slot as IField_Slot).type, true)};`, concreteLists).join('\n')}
`);

    // Queue up a concrete list type initializer for the end of the file. It can't be initialized within the class's
    // static initializer because the nested type might not be defined yet.

    ctx.concreteListInitializers.push.apply(ctx.concreteListInitializers, R.map((field) =>
      `${Class}._${c2t(field.name)} = ${toConcreteListType(ctx, (field.slot as IField_Slot).type)};`, concreteLists));

  }

  if (consts.length > 0) {

    fs.writeSync(fd, `
${R.map((c) => `  static readonly ${c2s(Node.getDisplayNamePrefix(c))} = ${c.const && Value.toJsPrimitive(c.const.value)};`, consts).join('\n')}
`);

  }

  if (nestedNodes.length > 0) {

    fs.writeSync(fd, `
${R.map((nested) => `  static readonly ${Node.getDisplayNamePrefix(nested)} = ${Node.getFullClassName(nested)};`, nestedNodes).join('\n')}
`);

  }

  if (groups.length > 0) {

    fs.writeSync(fd, `
`);

  }

  if (hasUnnamedUnion) {

    const unionFields = Node.getUnnamedUnionFields(node);

    if (unionFields.length !== discriminantCount) throw new Error('wat');

    fs.writeSync(fd, `
${R.map((field) => `  static readonly ${c2s(field.name)} = ${Class}_Which.${c2s(field.name)};`, unionFields).join('\n')}
`);

  }

  R.forEach(generateStructField(ctx, node), fields);

  fs.writeSync(fd, `
  toString(): string {

    return \`${Class}_\${super.toString()}\`;

  }
${hasUnnamedUnion ? `
  which(): ${Class}_Which {

    return this._getUint16(${discriminantOffset * 2});

  }
` : ''}
}
`);

});

const generateEnumNode = R.curry((ctx: FileGenContext, node: INode): void => {

  if (node.enum === undefined) throw new Error('wat');

  const {fd} = ctx;
  const Enum = Node.getFullClassName(node);

  fs.writeSync(fd, `
export enum ${Enum} {
${R.map((e) => `  ${c2s(e.name)},`, node.enum.enumerants).join('\n')}
}
`);

});

const generateNode = R.curry((ctx: FileGenContext, node: INode): void => {

  const {cgr, genNodeIds} = ctx;

  if (genNodeIds.indexOf(node.id) > -1) return;

  const groupNodes = R.filter((n) => n.scopeId === node.id && n.struct !== undefined && n.struct.isGroup, cgr.nodes);
  const nestedNodes = R.map(lookupNode(ctx), node.nestedNodes || []);

  R.forEach(generateNode(ctx), nestedNodes);
  R.forEach(generateNode(ctx), groupNodes);

  const whichNode = Node.which(node);

  switch (whichNode) {

    case Node.STRUCT:

      generateStructNode(ctx, node);

      break;

    case Node.CONST:

      // Const nodes are generated along with the containing class, ignore these.

      break;

    case Node.ENUM:

      generateEnumNode(ctx, node);

      break;

    case Node.ANNOTATION:
    case Node.FILE:
    case Node.INTERFACE:
    default:

      throw new Error(`Don't know how to generate a "${Node_Which[whichNode]}" node.`);

  }

  genNodeIds.push(node.id);

});

const generateFile = R.curry((ctx: GenContext, requestedFile: ICodeGeneratorRequest_RequestedFile): void => {

  const outPath = requestedFile.filename + '.ts';
  const fileId = requestedFile.id;
  const fileNode = ctx.nodeMap[fileId];
  const concreteListInitializers: string[] = [];
  const nodes = R.map(lookupNode(ctx), fileNode.nestedNodes);
  let fd;

  try {

    fd = fs.openSync(outPath, 'w');

    const fileState: FileGenContext = {...ctx, concreteListInitializers, fd, fileNode, requestedFile};

    generateHeaderComment(fileState);

    generateImports(fileState);

    R.forEach(generateNode(fileState), nodes);

    if (fileState.concreteListInitializers.length > 0) {

      fs.writeSync(fd, `\n${fileState.concreteListInitializers.join('\n')}\n`);

    }

  } finally {

    if (fd !== undefined) fs.closeSync(fd);

  }

});

export function generate(rawJSON: string): void {

  const cgr = JSON.parse(rawJSON) as ICodeGeneratorRequest;
  const {nodes} = cgr;
  const genNodeIds: string[] = [];
  const nodeMap = R.zipObj(R.map<INode, string>(R.prop('id'), nodes), nodes);
  const ctx: GenContext = {cgr, genNodeIds, nodeMap};

  R.forEach(generateFile(ctx), cgr.requestedFiles);

}
